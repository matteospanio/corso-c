[
  {
    "objectID": "exercises/02/power.html",
    "href": "exercises/02/power.html",
    "title": "Esercizio: elevamento a potenza",
    "section": "",
    "text": "Si vuole scrivere un programma che accetti in input due numeri interi \\(x\\) e \\(y\\) e stampi il risultato dell’operazione \\(x^y\\).\n\nQuando il programma viene eseguito deve chiedere all’utente di inserire due numeri interi \\(x\\) e \\(y\\) e stampare il risultato dell’operazione \\(x^y\\) in un loop infinito. L’esecuzione termina quando l’utente inserisce due zeri.\nAd esempio:\nInserisci due numeri interi: 2 3\n2^3 = 8\nInserisci due numeri interi: 3 2\n3^2 = 9\nInserisci due numeri interi: 4 5\n4^5 = 1024\n...\nInserisci due numeri interi: 0 0\nBye!\nPer semplicità si può assumere che \\(x, y \\in \\mathbb{N}\\) (siano sempre maggiori o uguali a zero).\nOpzionale:\n\nampliare il dominio dell’input a \\(x, y \\in \\mathbb{Z}\\) (l’input può contenere anche numeri negativi);\n\n\n\n\n\n\n\nSuggerimento\n\n\n\n\n\nIn C non esiste un operatore per l’elevamento a potenza. Tuttavia, possiamo calcolare \\(x^y\\) come \\(x \\cdot x \\cdot \\ldots \\cdot x\\) (con \\(y\\) fattori) utilizzando un ciclo for.",
    "crumbs": [
      "Lezioni",
      "Espressioni e strutture di controllo",
      "Elevamento a potenza"
    ]
  },
  {
    "objectID": "exercises/02/deal.html",
    "href": "exercises/02/deal.html",
    "title": "Esercizio: una mano di poker",
    "section": "",
    "text": "Si vuole scrivere un programma pescare una mano di poker.\n\nScrivere un programma che simuli il pescaggio di una mano di poker. Il programma deve pescare cinque carte casuali da un mazzo di 52 carte e stamparle a video.\nUn’esecuzione del programma potrebbe essere la seguente:\n$ ./poker\nLe carte pescate sono:\n7c 3d 9h 10s 2d\nOpzionale:\n\nscrivere una funzione draw_card che restituisca una carta casuale.\nimplementare una funzione discard che permetta di scartare un numero arbitrario di carte e di pescarne altrettante di nuove.\n\n\n\n\n\n\n\nSuggerimento\n\n\n\nPer pescare una carta casuale si devono generare dei numeri casuali. In C si utilizza la funzione rand per generare numeri casuali. Prima di utilizzare rand è necessario inizializzare il generatore di numeri casuali con la funzione srand. Per fare questo si può utilizzare il valore restituito dalla funzione time della libreria time.h come seme per srand. Ad esempio:\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n\nint main() {\n    srand(time(NULL)); // imposta il seed\n    int n = rand(); // genera un numero casuale\n    // se si vuole generare un numero tra 0 e 51 si può usare l'operatore modulo\n    int card = rand() % 52;\n    // ...\n}\nPer avere maggiori dettagli su rand e srand si può consultare la documentazione disponibile digitando man rand e man srand da terminale.",
    "crumbs": [
      "Lezioni",
      "Array e funzioni",
      "Una mano a poker"
    ]
  },
  {
    "objectID": "exercises/02/sum_matrix.html",
    "href": "exercises/02/sum_matrix.html",
    "title": "Esercizio: somma righe e colonne",
    "section": "",
    "text": "Si vuole scrivere un programma che legga un vettore di \\(5\\times 5\\) interi e calcoli la somma di ciascuna riga e di ciascuna colonna.\n\nUn’esecuzione del programma potrebbe essere la seguente:\n$ ./row_col_sum\nRiga 1: 8 3 9 0 10\nRiga 2: 3 5 17 1 1\nRiga 3: 2 8 6 23 1\nRiga 4: 15 7 3 2 9\nRiga 5: 6 14 2 6 0\nSomma righe: 30 27 40 36 28\nSomma colonne: 34 37 37 32 21\n\n\n\n\n\n\nSuggerimento\n\n\n\nLa maniera più semplice di iterare su tutte le righe e colonne di una matrice è utilizzare due cicli annidati.\nLa funzione scanf può essere usata all’interno di un ciclo, consumendo un valore alla volta. Ad esempio:\nint main(void)\n{\n    int arr[5];\n    printf(\"Inserisci 5 interi: \")\n    for (int i = 0; i &lt; 5; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    for (int i = 0; i &lt; 5; i++) {\n        printf(\"%d \", arr[i]);\n    }\n}\nL’esecuzione di questo programma leggerà 5 interi e li memorizzerà nell’array arr. Di seguito un esempio di esecuzione:\n$ ./a.out\nInserisci 5 interi: 1 2 3 4 5\n1 2 3 4 5",
    "crumbs": [
      "Lezioni",
      "Array e funzioni",
      "Somma di righe e colonne"
    ]
  },
  {
    "objectID": "exercises/01/cambio_valuta.html",
    "href": "exercises/01/cambio_valuta.html",
    "title": "Esercizio: cambio valuta",
    "section": "",
    "text": "L’Italia ha cambiato la sua valuta dalla lira italiana (ITL) all’euro (EUR) il 1º gennaio 2002. Questo è stato un evento storico noto come la “fase di transizione all’euro” o l’“introduzione dell’euro”. Durante questo periodo, le banconote e le monete denominate in euro sono state introdotte gradualmente in circolazione e la lira italiana è stata gradualmente ritirata. Il processo di transizione all’euro ha coinvolto un periodo di preparazione e pianificazione da parte delle istituzioni finanziarie e del governo italiano.\nGli italiani, al momento del cambio, si sono trovati a dover far fronte a un nuovo sistema di valuta. Per aiutare le persone a comprendere meglio il valore delle nuove banconote e monete, i giornali e i media hanno pubblicato tabelle di conversione tra le due valute ma il metodo più comune che venne adottato fin da subito fu la conversione esatta da lire in euro al tasso di cambio stabilito dai governi. Il valore di un euro è stato fissato a 1936,27 lire italiane.\n\nSi vuole scrivere un programma che, dato un importo in lire, lo converta in euro. Il programma deve chiedere all’utente di inserire un importo in lire e visualizzare a video l’importo corrispondente in euro.\n\nQuando il programma viene eseguito deve chiedere all’utente di inserire la quantità di lire italiane da cambiare, effettuare il calcolo e visualizzare il risultato a video a video.\nAd esempio:\nInserire l'importo in lire: 10000\n10000 lire italiane corrispondono a 5.16 euro\n\n\n\n\n\n\nSuggerimento\n\n\n\nPer convertire un importo da lire a euro, si può utilizzare la seguente formula: \\[\n\\text{euro} = \\frac{\\text{lire}}{1936.27}\n\\]\nIn C è molto comune definire le costanti in due maniere:\n\ncon la direttiva #define:\n#define TASSO_CAMBIO 1936.27\ncon la dichiarazione di una variabile const:\nconst float TASSO_CAMBIO = 1936.27;\n\n\n\nEsempio di main:\n\n\n Scarica il file \n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    // TODO: ricevere in input un importo in lire da cambiare\n\n    // TODO: stampare a monitor l'importo in euro corrispondente\n}",
    "crumbs": [
      "Lezioni",
      "Basi di C",
      "Cambio valuta"
    ]
  },
  {
    "objectID": "exercises/01/somma_razionale.html",
    "href": "exercises/01/somma_razionale.html",
    "title": "Esercizio: somma di numeri razionali",
    "section": "",
    "text": "Si vuole scrivere un programma che accetti in input due razionali nella forma n/m e ne stampi la somma (non semplificata).\nAd esempio:\nInserisci il primo numero: 3/4\nInserisci il secondo numero: 1/2\nLa somma dei due numeri è 5/4\nOpzionale:\n\nUna volta compilato il programma eseguilo con gdb controllando ad ogni step i valori delle variabili locali.\n\n\n\n\n\n\n\nSuggerimento\n\n\n\nIn questo caso possiamo richiedere all’utente che il formato includa lo slash, e quindi includerlo nel pattern di scanf.",
    "crumbs": [
      "Lezioni",
      "Basi di C",
      "Somma razionale"
    ]
  },
  {
    "objectID": "exercises.html",
    "href": "exercises.html",
    "title": "Esercizi",
    "section": "",
    "text": "Gli esercizi sono divisi per lezione. Ogni lezione tratta un numero variabile di argomenti, quindi gli esercizi sono divisi in base a questi argomenti. Gli esercizi di lezioni più avanzate fanno spesso riferimento a concetti appresi in lezioni precedenti, quindi è consigliabile svolgerli in ordine.\nPer compilare gli esercizi si suggerisce di usare il comando gcc con i warning attivati e l’opzione -std=c99 per compilare in standard C99. Di seguito il comando che si può usare per compilare un file sorgente esercizio.c:\ngcc -std=c99 -Wall -Wextra -pedantic -Werror -g -o esercizio esercizio.c\nTalvolta può essere utile usare un file Makefile per compilare più file sorgente. Di seguito un esempio di Makefile:\n\n\n Scarica il file \nFILES=esercizio.c\nEXECUTABLE=esercizio\n\nCC=gcc\nCFLAGS=-std=c99 -Wall -Wextra -pedantic -Werror -g\n\n$(EXECUTABLE): $(FILES)\n    $(CC) $(CFLAGS) -o $@ $^"
  },
  {
    "objectID": "lessons/06/index.html",
    "href": "lessons/06/index.html",
    "title": "C avanzato",
    "section": "",
    "text": "TODO\n\n\n\nRiutilizzareCC BY 4.0",
    "crumbs": [
      "Lezioni",
      "C avanzato"
    ]
  },
  {
    "objectID": "lessons/04/index.html",
    "href": "lessons/04/index.html",
    "title": "Operatori bitwise",
    "section": "",
    "text": "TODO\n\n\n\nRiutilizzareCC BY 4.0",
    "crumbs": [
      "Lezioni",
      "Operatori bitwise"
    ]
  },
  {
    "objectID": "lessons/01/index.html",
    "href": "lessons/01/index.html",
    "title": "Basi di C",
    "section": "",
    "text": "Il linguaggio C ha la fama di linguaggio di basso livello e sintassi complicata. Nel 1972 però, questo linguaggio compariva per la prima volta per semplificare la scrittura di codice, infatti a quel tempo i programmatori scrivevano soprattutto in Assembly. Vale la pena quindi ripercorrere i punti di passaggio che hanno compartecipato alla creazione e diffusione del linguaggio.",
    "crumbs": [
      "Lezioni",
      "Basi di C"
    ]
  },
  {
    "objectID": "lessons/01/index.html#storia-e-standard",
    "href": "lessons/01/index.html#storia-e-standard",
    "title": "Basi di C",
    "section": "Storia e Standard",
    "text": "Storia e Standard\n\n\n\n\n\ntimeline\n    section Birth of C\n        1972 : nasce C (New B) presso i Bell Labs.\n        1973 : UNIX viene interamente riscritto in C.\n    section Definition of C Language\n        1978 : Kerninghan & Ritchie pubblicano The C Programming Language.\n        1989 : Primo Standard C (C89)\n    section Actual C\n        1999 : Secondo standard C (C99)\n        2011 : Terzo standard C (C11)\n\n\nPrincipali momenti storici per lo sviluppo del linguaggio C\n\n\n\n\nDopo aver scritto l’intero sistema operativo UNIX in assembly i programmatori dei Bell Laboratories si accorsero che era difficile da mantenere1, così si misero a lavorare su nuovi linguaggio, prima B e successivamente New B, ribattezzato poi C, per reimplementare del tutto UNIX in C nel 1973.\nC risultò subito un linguaggio vanataggioso da usare soprattutto per la sua portabilità (di cui discuteremo più avanti in dettaglio), così, per tutti gli anni ‘70 e 80’, il suo utilizzo si diffuse enormemente. In queste situazioni, ossia quando uno strumento di lavoro viene diffuso molto rapidamente e su larga scala, è una buona idea proporre uno Standard, cioè una serie di “regole” che chiariscano come vada usato in maniera appropriata lo strumento, in questo caso un modo comune di scrivere in C; nel 1978 Brian Kernigan e Dennis Ritchie (l’inventore di C) scrissero The C Programming Language (Kernighan e Ritchie 1978), il primo tutorial di C ma questo non era uno standard, ma negli anni 80 nacquero comunque molte varianti di C ognuna con un proprio modo di scrivere.\n\nUno Standard per tutti\n\n“The nice thing about standards is that you have so many to choose from.”, Andrew S. Tanenbaum\n\nÈ in questo scenario che si vede l’intervento dell’American National Standard Institute (ANSI) che a partire dal 1983 si mise al lavoro per proporre uno standard C concludendolo nel 1989 e successivamente approvato dall’International Organization for Standardization (ISO) nel 1990 come ISO/IEC 9899:1990, meglio conosciuto come C89. Negli anni vennero poi apportate altre migliorie al linguaggio che portarono, nel 1999, alla creazione di un nuovo standard: l’ISO/IEC 9899:1999, solitamente detto C99.\nDopo il C99 sono stati creati altri standard: C11, C17 e C23. Ognuno di questi introduce variazioni che servono a mantenere il linguaggio aggiornato alle esigenze dei programmatori attuali. Dopo la creazione di uno standard però i compilatori devono essere riscritti per comprendere le nuove regole proposte, questo fa sì che spesso non sia possibile compilare i programmi con l’ultimo standard perchè questo esiste solo da un punto di vista teorico. Attualmente i compilatori più diffusi coprono gli standard C99 e C11 ma non è ancora possibile scrivere programmi in C23.",
    "crumbs": [
      "Lezioni",
      "Basi di C"
    ]
  },
  {
    "objectID": "lessons/01/index.html#caratteristiche",
    "href": "lessons/01/index.html#caratteristiche",
    "title": "Basi di C",
    "section": "Caratteristiche",
    "text": "Caratteristiche\nIn questa sezione si discutono brevemente le caratteristiche del linguaggio C evidenziandone pregi e difetti. L’aver concluso il precedente paragrafo parlando di compilatori lascia intuire che C sia un linguaggio compilato. Questo significa che il codice sorgente scritto in C deve essere tradotto in linguaggio macchina prima di poter essere eseguito. Altri punti caratteristici di C sono l’essere minimale (C rinuncia a molte astrazioni, questo, per esempio, permette di ridurre il numero di parole chiave del linguaggio), il fatto di essere fortemente tipato (le variabili devono essere dichiarate con un tipo e non possono cambiare tipo durante l’esecuzione del programma) e il fatto di essere permissivo (il compilatore non si lamenta di errori che in altri linguaggi sarebbero considerati gravi). Tecnicamente C è un linguaggio di alto livello, ma nella pratica ha molte feature che lo rendono uno dei linguaggi di più basso livello. Specialmente sulla gestione di memoria.\n\n\n\n\n\n\nCompilare o interpretare?\n\n\n\nNon tutti i linguaggi di programmazione vanno compilati. Alcuni vengono interpretati. La differenza, semplificando, è che un linguaggio compilato viene tradotto in linguaggio macchina una volta per tutte, mentre un linguaggio interpretato viene tradotto in linguaggio macchina ogni volta che viene eseguito. Esistono moltissimi linguaggi di entrambi i tipi, e non esiste una regola che renda un sistema migliore dell’altro. Generalmente i linguaggi compilati sono più veloci, ma i linguaggi interpretati sono più flessibili. Spesso per progetti di piccole dimensioni o script i programmatori preferiscono usare linguaggi interpretati, mentre per progetti di grandi dimensioni o software che deve essere veloce si preferisce usare linguaggi compilati (non è sempre così però).\nL’alternarsi tra i due tipi di linguaggi è una questione che esiste da tempo. È importante notare a riguardo che il predecessore di C, il linguaggio B, era un linguaggio interpretato. La scelta di C di essere compilato è stata una delle ragioni del suo successo. Allo stesso modo molti linguaggi interpretati si sono diffusi proprio per essere tali.\n\n\n\nPregi e difetti\nAlcuni linguaggi sono permissivi. Al programmatore basta avere solo un senso di base di come le cose funzionano. Gli errori nel codice vengono segnalati dal sistema di compilazione o di esecuzione e il programmatore può arrangiarsi e alla fine sistemare le cose in modo che funzionino correttamente. Il linguaggio C non è così.\nIl modello di programmazione in C è che il programmatore sa esattamente cosa vuole fare e come utilizzare le possibilità del linguaggio per raggiungere quel obiettivo. Il linguaggio permette al programmatore esperto di esprimere ciò che desidera nel minor tempo possibile, rimanendo fuori dal suo cammino. C è “semplice” nel senso che il numero di componenti nel linguaggio è piccolo: se due funzionalità del linguaggio realizzano più o meno la stessa cosa, C ne includerà solo una. La sintassi di C è concisa e il linguaggio non limita ciò che è “consentito”: il programmatore può praticamente fare ciò che desidera.\nIl sistema di tipi di C e i controlli degli errori esistono solo durante la compilazione. Il codice compilato viene eseguito in un modello di esecuzione ridotto senza controlli di sicurezza per conversioni di tipo errate, indici di array errati o puntatori errati. Non c’è un garbage collector per gestire la memoria. Invece, il programmatore gestisce manualmente la memoria heap. Tutto ciò rende C veloce ma fragile.\n\n\n\n\n\n\nThe billion-dollar mistake\n\n\n\n\n“I call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn’t resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.”, Tony Hoare\n\nSeppure non sia una caratteristica introdotta con C, la null reference è un problema che affligge molti linguaggi di programmazione. Tony Hoare, scrivendo il linguaggio ALGOL W, introdusse questo concetto, C, ispirandosi fortemente ad ALGOL, ereditò questa caratteristica. L’utilizzo sbagliato di un puntatore nullo è una delle cause principali di errori in C.\n\n\nDi seguito sono commentate le caratteristiche principali considerate come i maggiori pregi e difetti del C:\n\nEfficienza: il linguaggio C è nato per essere efficiente, doveva andare a sostituire il codice Assembly, è stato scritto quindi per essere veloce;\nCompattezza: il C è un linguaggio molto compatto, non ci sono molte parole chiave, non ci sono molte funzioni predefinite, non ci sono molte strutture dati predefinite, fornisce soltanto “lo stretto indispensabile”;\nPortabilità: sebbene il C non sia stato pensato per essere portabile, la creazione di uno standard e la sua associazione con UNIX ha reso il C un linguaggio solido e usato su molte piattaforme. Uno degli slogan che accompagna il C da molti anni è “write once, compile everywhere” (scrivi una volta, compila ovunque), che poi venne ripreso con l’arrivo di Java e del suo “write once, run everywhere”;\nPermissività: il C si basa su un’assunzione molto forte: il programmatore sa cosa sta facendo. Questo è sia un pro che un contro: da un lato permette al programmatore di fare tutto quello che vuole, dall’altro lato permette al programmatore di fare tutto quello che vuole. Questo significa che il programmatore può fare cose molto potenti, ma può anche fare cose molto pericolose.\nError prone: proprio per la permissività appena menzionata, c’è spazio per fare molti errori. Questo è un problema che si può risolvere con l’uso di strumenti di analisi statica e dinamica, con l’uso di buone pratiche di programmazione e con l’uso di commenti e documentazione.\nDifficile da leggere: proprio per la compattezza, il C può diventare difficile da leggere. Esistono addirittura delle competizioni di programmazione in cui il C viene usato per scrivere codice illeggibile.\nRun time: una volta compilato, il programma C perde molte informazioni, per esempio non è più possibile conoscere i tipi delle variabili, pertanto non è possibile fare controlli a run time.\nNon Object-oriented: lo stretto indispensabile fornito da C non include gli oggetti. Questo significa che non esistono le astrazioni tipiche di Java, classi, variabili di istanza, metodi… Esistono evoluzioni del C con queste caratteristiche (C++, C# e lo stesso Java ha ereditato molto dal C).",
    "crumbs": [
      "Lezioni",
      "Basi di C"
    ]
  },
  {
    "objectID": "lessons/01/index.html#installazione",
    "href": "lessons/01/index.html#installazione",
    "title": "Basi di C",
    "section": "Installazione",
    "text": "Installazione\nPer lavorare con il C, avrete bisogno di un compilatore C. Il compilatore più diffuso è gcc, è un compilatore open source, sviluppato da GNU. Storicamente lo sviluppo in C è stato fatto su sistemi Unix, quindi gcc è facilmente compatibile con tutti i sistemi Unix-like, mentre su Windows è necessario installare un ambiente di sviluppo come MinGW. Di seguito sono riportate le istruzioni per installare il compilatore su Linux e Mac. Per Windows, le istruzioni saranno caricate su Moodle.\n\n\n\n\n\n\nLinux e Mac2\n\n\n\nDebian/Ubuntu3: per installare il compilatore: sudo apt install gcc -y\nMac: se non lo avete, facendo gcc -v il sistema vi proporrà di scaricare i tool da linea di comando di Apple. Accettando, vi verrà installato.\n\n\n\n\n\n\n\n\nWindows\n\n\n\npotete installare MinGW e modificare le variabili di PATH. Le istruzioni saranno caricate su Moodle.\n\n\n\n\n\n\nflowchart LR\nA[Start]\nB{\"Scegli OS\"}\nC[Installare MinGW o WSL 2]\nE{\"digitare\\ngcc --version\"}\nF[Installare GCC]\nG[Ready to go]\n\nA --&gt; B\nB --&gt; |Windows| C\nB --&gt; |UNIX based| E\nC --&gt; E\nE --&gt; |errore| F\nE --&gt; |stampa versione| G\nF --&gt; G\n\n\nProcesso di installazione del compilatore\n\n\n\nPer scrivere effettivamente il codice è poi richiesto di installare un editor di testo adatto al codice. Dal momento che i programmatori adorano sviluppare strumenti per la programmazione è pieno di editor di testo che più o meno si equivalgono e che, in ogni caso, ricoprono abbondantemente le necessità del corso. Alcuni esempi sono: notepad++, sublime, gedit, kate, emacs, nano, vim…\n\n\n\n\n\n\nImportante\n\n\n\nÈ sconsigliato studiare su un IDE, anche se è consigliato usarli quando si lavora effettivamente.\n\n\n\n\n\n\n\n\nImpara facendo\n\n\n\nRiscrivere tutti gli esempi di codice senza usare copia e incolla aiuta a familiarizzare con la sintassi del linguaggio e gli strumenti di lavoro. Copiando si commettono errori da cui è possibile imparare, il compilatore segnalerà gli errori e si imparerà a correggerli.",
    "crumbs": [
      "Lezioni",
      "Basi di C"
    ]
  },
  {
    "objectID": "lessons/01/index.html#la-compilazione",
    "href": "lessons/01/index.html#la-compilazione",
    "title": "Basi di C",
    "section": "La compilazione",
    "text": "La compilazione\nOra che abbiamo installato il compilatore, possiamo iniziare a scrivere i nostri primi programmi.\nPrendiamo in esame il nostro primo programma, hello.c\n#include &lt;stdio.h&gt;\n\n/* Il mio primo programma in C! */\nint main(void)\n{\n    printf(\"Hello, World!\");\n}\nRispettando la tradizione, il nostro primo programma stamperà “Hello, World!” a terminale. Per il momento non concentriamoci troppo sulla sintassi, vediamo piuttosto l’esecuzione del programma. Ma come possiamo farlo eseguire? Come già anticipato in precedenza, il nostro codice sorgente non è direttamente eseguibile, ma deve essere prima compilato. Vediamo come fare.\nNel venire compilato, il nostro programma passa attraverso altri tre programmi:\n\nPreprocessor: elimina i commenti ed esegue le direttive del preprocessore (le istruzioni che iniziano con #).\nCompiler: controlla se il codice è corretto (sintatticamente) e lo converte in linguaggio macchina, generando il codice oggetto.\nLinker: combina vari file oggetto e le librerie, producendo il file eseguibile. (a.out oppure a.exe)\n\nEsistono comandi per accedere separatamente ai vari passaggi, ma in genere viene tutto gestito da gcc (GNU C Compiler \\(\\rightarrow\\) GNU Compiler Collection)\ngcc -o &lt;nome_eseguibile&gt; &lt;sorgente.c&gt; &lt;sorgente2.c&gt; ... &lt;sorgenteN.c&gt;\nIl comando chiama il preprocessore su tutti i file, per tutti compila il file oggetto e chiama il linker che li unisce nell’unico eseguibile chiamato &lt;nome_eseguibile&gt;\n\n\n\n\n\n\nNota\n\n\n\ngcc -c &lt;sorgente.c&gt; &lt;sorgente2.c&gt; ... &lt;sorgenteN.c&gt;\nNon esegue il linking (utile se non si ha ancora il main ad esempio)",
    "crumbs": [
      "Lezioni",
      "Basi di C"
    ]
  },
  {
    "objectID": "lessons/01/index.html#sintassi-di-c",
    "href": "lessons/01/index.html#sintassi-di-c",
    "title": "Basi di C",
    "section": "Sintassi di C",
    "text": "Sintassi di C\n1#include &lt;stdio.h&gt;\n2/* Il mio primo programma in C! */\n3int main(void)\n{\n4  int anno = 2024;\n5  printf(\"Hello Dati e Algoritmi %d\", anno);\n}\n\n1\n\nDirettiva: le direttive del preprocessore iniziano con # e vengono eseguite prima del resto del codice, in questo caso includiamo la libreria standard di input/output. Ci sono due principali usi delle direttive: includere librerie e definire macro. L’istruzione #include comunica al preprocessore che il programma ha bisogno delle funzioni definite in stdio.h, la libreria standard di input/output (infatti viene usato printf). L’istruzione #define la incontreremo più avanti, ad ogni modo è un sistema che viene spesso usato per definire costanti.\n\n2\n\nCommento: i commenti in C89 iniziano con /* e terminano con */. I commenti possono essere su più righe. Dal C99 si possono usare anche i commenti monoriga (//).\n\n3\n\nFunzione: la funzione main è il punto di partenza di ogni programma C. Il tipo di ritorno è int, e accetta un singolo argomento di tipo void. Il corpo della funzione è racchiuso tra parentesi graffe {}. main è una funzione speciale che indica il punto di partenza di ogni programma C. Il tipo di ritorno int indica che la funzione restituirà un valore intero (a volte il valore di ritorno del main può essere di tipo void, ma è una pratica non consigliata). L’argomento void indica che la funzione non accetta alcun argomento, si sarebbe potuto omettere, ma è buona pratica includerlo per chiarezza e attivare il controllo del compilatore.\n\n4\n\nDichiarazione e assegnazione di variabile: int anno = 2024; dichiara una variabile di tipo int chiamata anno e le assegna il valore 2024. Storicamente la dichiarazione di variabili in C doveva avvenire all’inizio di un blocco di codice, dal C99 non è più una regola da seguire rigidamente.\n\n5\n\nChiamata di funzione: in questo caso stiamo usando la funzione printf definita in stdio.h a cui vengono passati 2 argomenti.\n\n\n\nDichiarazioni e inizializzazioni\nTutte le variabili devono essere dichiarate prima di essere usate:\nint altezza;\nfloat temperatura, peso;\nUna delle fonti d’errore maggiori in C è che non esiste l’inizializzazione di default delle variabili, prima di utilizzarle nel programma bisogna assegnare un valore, come nel seguente esempio:\nint altezza;\naltezze = 175;\nfloat temperatura = 36.4f;\nNella prima riga viene dichiarata la variabile altezza e nella seconda le viene assegnato un valore, questa procedura può essere compattata in un’unica riga come nel caso di temperatura.\n\n\n\n\n\n\nImportante\n\n\n\nQuando si dichiara una variabile il compilatore crea dello spazio nella memoria per contenere la variabile del tipo dichiarato (ogni tipo ha una dimensione diversa…), per essere più efficiente C non azzera la memoria che si trova in quello spazio, pertanto, se si andasse a leggere il valore di una variabile prima del primo assegnamento si troverebbero dei valori casuali.\n\n\n\n\nKeyword riservate\nCome detto in precedenza C è un linguaggio con poche parole chiave, quelle poche che ci sono però non possono essere usate per altri scopi, pertanto le parole sotto riportate sono da considerarsi riservate per il linguaggio e non possono essere usate per dichiarazioni di variabili o macro.\nauto     break   case    char      const      continue   default   do\ndouble   else    enum    extern    float      for        goto      if\ninline*  int     long    register  restrict*  return     short     signed\nsizeof   static  struct  switch    typedef    union      unsigned  void\nvolatile while   _Bool*  _Complex* _Imaginary*\n*solo da C99\n\n\n\n\n\n\nIl C è case sensitive\n\n\n\nNomi di variabili valide sono:\nint a, A; float Auto;\nN.B. solo perché si può non vuol dire che sia una buona idea…",
    "crumbs": [
      "Lezioni",
      "Basi di C"
    ]
  },
  {
    "objectID": "lessons/01/index.html#inputoutput",
    "href": "lessons/01/index.html#inputoutput",
    "title": "Basi di C",
    "section": "Input/Output",
    "text": "Input/Output\nDifficilmente un programma può fare a meno di interagire con l’utente o con l’ambiente esterno. In C questo avviene tramite le funzioni printf e scanf. Queste funzioni fanno parte della libreria standard stdio.h, che è disponibile di default in ogni installazione di C.\nPer comprenderle meglio, è necessario capire come funzionano i formati di stampa e di lettura. Un buon punto di partenza è il manuale di printf e scanf (che si può trovare digitando man printf e man scanf in un terminale).\n\n\n\n\n\n\nIl comando man\n\n\n\nIl comando man è un comando che permette di visualizzare il manuale di un comando o di una funzione. Il numero tra parentesi tonde dopo il nome del comando indica la sezione del manuale in cui cercare. Per esempio, man 3 printf cerca il manuale della funzione printf nella sezione 3, che contiene le funzioni di libreria.\nLe sezioni del manuale sono:\n\nProgrammi eseguibili e comandi della shell\nChiamate al sistema (funzioni fornite dal kernel)\nChiamate alle librerie (funzioni all’interno delle librerie di sistema)\nFile speciali (di solito trovabili in /dev)\nFormati dei file e convenzioni p.es. /etc/passwd\nGiochi\nPacchetti di macro e convenzioni p.es. man(7), groff(7).\nComandi per l’amministrazione del sistema (solitamente solo per root)\nRoutine del kernel [Non standard]\n\nUn buon punto di partenza per saperne di più è man man.\n\n\n\nOutput con printf\n$ man 3 printf\n\nPRINTF(3)              Linux Programmer's Manual              PRINTF(3)\n\nNAME\n       printf,  fprintf, dprintf, sprintf, snprintf, vprintf, vfprintf,\n       vdprintf, vsprintf, vsnprintf - formatted output conversion\n\nSYNOPSIS\n       #include &lt;stdio.h&gt;\n\n       int printf(const char *format, ...);\n       int fprintf(FILE *stream, const char *format, ...);\n       int dprintf(int fd, const char *format, ...);\n       int sprintf(char *str, const char *format, ...);\n       int snprintf(char *str, size_t size, const char *format, ...);\n\n...\n\nDESCRIPTION\n       The functions in the printf() family produce output according to\n       a  format  as  described  below.   The  functions  printf()  and\n       vprintf()  write  output  to stdout, the standard output stream;\n       fprintf() and  vfprintf()  write  output  to  the  given  output\n       stream; sprintf(), snprintf(), vsprintf(), and vsnprintf() write\n       to the character string str.\n\nLa pagina del manuale di printf è veramente lunga e rischia di essere un po’ dispersiva. Uno dei punti cruciali è la descrizione degli specificatori di formato, che sono i simboli che permettono di formattare l’output. Questi simboli iniziano tutti con %, e per ciascuno deve esserci un parametro dopo la stringa di formattazione.\nAd esempio %d è il simbolo per stampare un intero, printf(\"%d\", 10) pertanto stampa 10. Di seguito è riportata una lista di specificatori di formato:\n\n\n\nTabella 1: Formattazione stringhe\n\n\n\n\n\nFormat specifier\nValue\nOutput\n\n\n\n\n%c\n'm'\nm\n\n\n%d\n255\n255\n\n\n%ld\n99\n99\n\n\n%x\n255\nff\n\n\n%f\n25.8\n25.799999\n\n\n%g\n25.8\n25.8\n\n\n%s\n\"hello\"\nhello\n\n\n%8.3f\n25.8\n˽˽25.800\n\n\n%6d\n255\n˽˽˽255\n\n\n%06d\n255\n000255\n\n\n%-6d\n255\n255˽˽˽\n\n\n\n\n\n\nIl seguente codice C mette in pratica i simboli di formattazione seguendo gli esempi della tabella, si noti che, per comodità, le espressioni usate più di una volta vengono salvate in variabili:\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    char c_val = 'm';\n    int i_val = 255;\n    long int l_val = 99;\n    float f_val = 25.8;\n\n    printf(\"%c\\n\", c_val);\n    printf(\"%d\\n\", i_val);\n    printf(\"%ld\\n\", l_val);\n    printf(\"%x\\n\", i_val);\n    printf(\"%f\\n\", f_val);\n    printf(\"%g\\n\", f_val);\n    printf(\"%s\\n\", \"hello\");\n    printf(\"%8.3f\\n\", f_val);\n    printf(\"%6d\\n\", i_val);\n    printf(\"%06d\\n\", i_val);\n    printf(\"%-6d\\n\", i_val);\n}\n\nLa seguente lista invece è un elenco più esaustivo di esempi di formattazione:\n\n%d per interi, es. \\(10\\)\n%f per float, es. \\(3.14\\)\n%e per float in notazione scientifica, es. \\(5.2\\times 10^4\\)\n%lf per double, es. \\(3.14\\)\n%s per stringhe, es. \"ciao\"\n%c per caratteri, es. 'a'\n%p per puntatori, es. 0x7fffbf7f3b4c\n%x per interi in esadecimale, es. ff\n%o per interi in ottale, es. 77\n%Nf per avere \\(N\\) “spazi” per la stampa, es. %5d per 112 con due spazi vuoti prima\n%.Nf per float con \\(N\\) cifre decimali, es. %.2f per \\(3.14\\)\n\n\n\nString format\nOltre ai simboli di formattazione, ci sono anche i caratteri speciali, che si scrivono con \\ (backslash) il carattere di escaping. Questi caratteri permettono di stampare a monitor dei codici che vengono interpretati in maniera speciale. Il più comune è \\n per andare a capo, ma ce ne sono altri, di seguito una lista dei più ricorrenti:\n\n\\n per andare a capo\n\\t per tabulare\n\\b per backspace\n\\\\ per stampare il backslash\n\\\" per stampare le virgolette\n\\0 per terminare una stringa\n\n\n\nInput con scanf\nPer ricevere l’input da terminale si usa la funzione scanf, questa funzione esegue pattern matching sull’input per popolare delle variabili. Per esempio:\nint base, altezza;\nscanf(\n1    \"%d%d\",\n2    &base, &altezza\n    );\n\n1\n\nPattern: %d%d indica che si aspettano due interi\n\n2\n\nVariabili da popolare: base e altezza sono le variabili che verranno popolate con i valori letti da terminale, si noti che il tipo deve essere coerente con il pattern. Se il pattern fosse stato %f le variabili avrebbero dovuto essere di tipo float.\n\n\n\n\n\n\n\n\nAvviso\n\n\n\nscanf scorre l’input ignorando ogni carattere bianco (spazi, tabulazioni, a capo). Se trova caratteri compatibili (+/-, 0-9, .) li legge e li converte nel tipo di variabile corrispondente.\n\n\nSi noti che è stato usato lo strano simbolo & davanti alle variabili base e altezza. Questo simbolo è chiamato operatore di indirizzamento e restituisce l’indirizzo di memoria della variabile. Questo è necessario perché scanf deve scrivere direttamente nella variabile, e non può farlo se non conosce l’indirizzo di memoria. Se si dimentica il simbolo & si otterrà un errore a runtime.\nDi fatto stiamo introducendo il concetto di puntatore, che è un argomento più avanzato e verrà trattato in seguito. Per ora è sufficiente sapere che un puntatore è un indirizzo di memoria. Quando si passa un puntatore a una funzione, si passa l’indirizzo di memoria della variabile, non la variabile stessa. Questo permette alla funzione di scrivere direttamente nella variabile, senza doverne fare una copia.",
    "crumbs": [
      "Lezioni",
      "Basi di C"
    ]
  },
  {
    "objectID": "lessons/01/index.html#esercizi",
    "href": "lessons/01/index.html#esercizi",
    "title": "Basi di C",
    "section": "Esercizi",
    "text": "Esercizi\n\nScrivere un programma che legga due numeri e stampi la somma.\nScrivere un programma che legga due frazioni in formato \"n/m\" e stampi la loro somma (non semplificata).\nScrivere un programma che legga un numero e stampi il suo quadrato.\nCompilare i programmi precedenti ed esplorarli usando il debugger gdb.\n\nAltri esercizi si possono trovare a questo link.",
    "crumbs": [
      "Lezioni",
      "Basi di C"
    ]
  },
  {
    "objectID": "lessons/01/index.html#footnotes",
    "href": "lessons/01/index.html#footnotes",
    "title": "Basi di C",
    "section": "Note",
    "text": "Note\n\n\nPer codice difficile da mantenere si intendono quei codici che hanno una struttura poco adatta all’aggiunta di nuove funzionalità nel tempo.↩︎\nprobabilmente è già installato. Aprire il terminale per verificarlo con gcc –v↩︎\nper altre distribuzioni non debian based, usare il package manager di sistema↩︎",
    "crumbs": [
      "Lezioni",
      "Basi di C"
    ]
  },
  {
    "objectID": "lessons/01/slide.html#storia-e-standard",
    "href": "lessons/01/slide.html#storia-e-standard",
    "title": "Basi di C",
    "section": "Storia e Standard",
    "text": "Storia e Standard\n\n\n\n\n\ntimeline\n    section Birth of C\n        1972 : nasce C (New B) presso i Bell Labs.\n        1973 : UNIX viene interamente riscritto in C.\n    section Definition of C Language\n        1978 : Kerninghan & Ritchie pubblicano The C Programming Language.\n        1989 : Primo Standard C (C89)\n    section Actual C\n        1999 : Secondo standard C (C99)\n        2011 : Terzo standard C (C11)\n\n\nPrincipali momenti storici per lo sviluppo del linguaggio C"
  },
  {
    "objectID": "lessons/01/slide.html#storia-e-standard-1",
    "href": "lessons/01/slide.html#storia-e-standard-1",
    "title": "Basi di C",
    "section": "Storia e Standard",
    "text": "Storia e Standard\n\nIl linguaggio C fu ideato nei Bell Laboratories della AT&T nel 1972 da Dennis Ritchie, la definizione formale avvenne nel 1978 a cura di Brian Kernighan e D. Ritchie.\nGià nel 1973 il linguaggio fu usato per riscrivere completamente il sistema operativo UNIX.\nLa standarizzazione del linguaggio avvenne nel 1989 a cura dell’ANSI (American NaJonal Standard Institute), e in seguito venne recepita dall’ISO (InternaJonal OrganizaJon for Standardization, ISO/IEC 9899:1990).\nNel 1999 si concluse una nuova fase di standarizzazione del C, nella quale vennero aggiunte nuove funzionalità al linguaggio (ISO/IEC 9899:1999)."
  },
  {
    "objectID": "lessons/01/slide.html#caratteristiche",
    "href": "lessons/01/slide.html#caratteristiche",
    "title": "Basi di C",
    "section": "Caratteristiche",
    "text": "Caratteristiche\n\nSi tratta di un Linguaggio Compilato\nFortemente tipato\nMinimale\nPermissivo (il compilatore non si lamenta!)\nTecnicamente un linguaggio di alto livello, nella pratica ha molte feature che lo rendono uno dei linguaggi di più basso livello. Specialmente sulla gestione di memoria."
  },
  {
    "objectID": "lessons/01/slide.html#pregi-e-difetti",
    "href": "lessons/01/slide.html#pregi-e-difetti",
    "title": "Basi di C",
    "section": "Pregi e difetti",
    "text": "Pregi e difetti\n\n\n\nPregi\nDifetti\n\n\n\n\nEfficienza\nFacile fare errori\n\n\nCompattezza\nPuò diventare difficile da leggere\n\n\nPortabilità\nNon ci sono controlli a run time\n\n\nPermissività\nPermissività"
  },
  {
    "objectID": "lessons/01/slide.html#pregi-e-difetti-2",
    "href": "lessons/01/slide.html#pregi-e-difetti-2",
    "title": "Basi di C",
    "section": "Pregi e Difetti",
    "text": "Pregi e Difetti\n\nLa permissività è sia un pro che un contro: sta al programmatore giocarla a suo vantaggio\nEvitare di farsi male da soli!\nSeguire le convenzioni di scrittura\nAttivare i warning sul compilatore (+ altri tool)\nCommentare!"
  },
  {
    "objectID": "lessons/01/slide.html#linguaggio-strutturato",
    "href": "lessons/01/slide.html#linguaggio-strutturato",
    "title": "Basi di C",
    "section": "Linguaggio Strutturato",
    "text": "Linguaggio Strutturato\n\nÈ possibile (e necessario) definire funzioni, che accettano \\(N\\) parametri in input e restituiscono un valore come output.\nC non è un linguaggio a oggetti. Non esistono quindi le astrazioni tipiche di Java, classi, variabili di istanza, metodi…\nEsistono evoluzioni del C con queste caratteristiche (C++, C# e lo stesso Java ha ereditato molto dal C)."
  },
  {
    "objectID": "lessons/01/slide.html#installazione",
    "href": "lessons/01/slide.html#installazione",
    "title": "Basi di C",
    "section": "Installazione",
    "text": "Installazione\n\n\n\n\n\n\nLinux e Mac1\n\n\nDebian/Ubuntu2: per installare il compilatore: sudo apt install gcc -y\nMac: se non lo avete, facendo gcc -v il sistema vi proporrà di scaricare i tool da linea di comando di Apple. Accettando, vi verrà installato.\n\n\n\n\n\n\n\n\n\nWindows\n\n\npotete installare MinGW e modificare le variabili di PATH. Le istruzioni saranno caricate su Moodle.\n\n\n\nprobabilmente è già installato. Aprire il terminale per verificarlo con gcc –vper altre distribuzioni non debian based, usare il package manager di sistema"
  },
  {
    "objectID": "lessons/01/slide.html#installazione-1",
    "href": "lessons/01/slide.html#installazione-1",
    "title": "Basi di C",
    "section": "Installazione",
    "text": "Installazione\n\n\n\n\nflowchart LR\nA[Start]\nB{\"Scegli OS\"}\nC[Installare MinGW o WSL 2]\nE{\"digitare\\ngcc --version\"}\nF[Installare GCC]\nG[Ready to go]\n\nA --&gt; B\nB --&gt; |Windows| C\nB --&gt; |UNIX based| E\nC --&gt; E\nE --&gt; |errore| F\nE --&gt; |stampa versione| G\nF --&gt; G\n\n\nProcesso di installazione del compilatore"
  },
  {
    "objectID": "lessons/01/slide.html#installazione-2",
    "href": "lessons/01/slide.html#installazione-2",
    "title": "Basi di C",
    "section": "Installazione",
    "text": "Installazione\nVi servirà anche un editor di testo adatto al codice.\nAd esempio notepad++, sublime, gedit, kate, emacs, nano, vim…\n\n\n\n\n\n\nImportante\n\n\nÈ sconsigliato studiare su un IDE, anche se è consigliato usarli quando si lavora effettivamente.\n\n\n\n\n\n\n\n\n\nImpara facendo\n\n\nRiscrivere tutti gli esempi di codice senza usare copia e incolla aiuta a familiarizzare con la sintassi del linguaggio e gli strumenti di lavoro. Copiando si commettono errori da cui è possibile imparare, il compilatore segnalerà gli errori e si imparerà a correggerli."
  },
  {
    "objectID": "lessons/01/slide.html#la-compilazione",
    "href": "lessons/01/slide.html#la-compilazione",
    "title": "Basi di C",
    "section": "La compilazione",
    "text": "La compilazione\nPrendiamo in esame il nostro primo programma, hello.c\n#include &lt;stdio.h&gt;\n\n/* Il mio primo programma in C! */\nint main(void)\n{\n    printf(\"Hello, World!\");\n}"
  },
  {
    "objectID": "lessons/01/slide.html#la-compilazione-1",
    "href": "lessons/01/slide.html#la-compilazione-1",
    "title": "Basi di C",
    "section": "La compilazione",
    "text": "La compilazione\nNel venire compilato, il nostro programma passa attraverso altri tre programmi:\n\nPreprocessor: elimina i commenti ed esegue le direttive del preprocessore (le istruzioni che iniziano con #).\nCompiler: controlla se il codice è corretto (sintatticamente) e lo converte in linguaggio macchina, generando il codice oggetto.\nLinker: combina vari file oggetto e le librerie, producendo il file eseguibile. (a.out oppure a.exe)"
  },
  {
    "objectID": "lessons/01/slide.html#la-compilazione-2",
    "href": "lessons/01/slide.html#la-compilazione-2",
    "title": "Basi di C",
    "section": "La compilazione",
    "text": "La compilazione\nEsistono comandi per accedere separatamente ai vari passaggi, ma in genere viene tutto gestito da gcc (GNU C Compiler \\(\\rightarrow\\) GNU Compiler Collection)\ngcc -o &lt;nome_eseguibile&gt; &lt;sorgente.c&gt; &lt;sorgente2.c&gt; ... &lt;sorgenteN.c&gt;\nIl comando chiama il preprocessore su tutti i file, per tutti compila il file oggetto e chiama il linker che li unisce nell’unico eseguibile chiamato &lt;nome_eseguibile&gt;\n\n\n\n\n\n\nNota\n\n\ngcc -c &lt;sorgente.c&gt; &lt;sorgente2.c&gt; ... &lt;sorgenteN.c&gt;\nNon esegue il linking (utile se non si ha ancora il main ad esempio)"
  },
  {
    "objectID": "lessons/01/slide.html#sintassi-di-c",
    "href": "lessons/01/slide.html#sintassi-di-c",
    "title": "Basi di C",
    "section": "Sintassi di C",
    "text": "Sintassi di C\n#include &lt;stdio.h&gt;\n/* Il mio primo programma in C! */\nint main(void)\n{\n    int anno = 2024;\n    printf(\"Hello Dati e Algoritmi %d\", anno);\n}\n\n\n\nDirettiva"
  },
  {
    "objectID": "lessons/01/slide.html#sintassi-di-c-1",
    "href": "lessons/01/slide.html#sintassi-di-c-1",
    "title": "Basi di C",
    "section": "Sintassi di C",
    "text": "Sintassi di C\n#include &lt;stdio.h&gt;\n/* Il mio primo programma in C! */\nint main(void)\n{\n    int anno = 2024;\n    printf(\"Hello Dati e Algoritmi %d\", anno);\n}\n\n\nDirettiva\nCommento"
  },
  {
    "objectID": "lessons/01/slide.html#sintassi-di-c-2",
    "href": "lessons/01/slide.html#sintassi-di-c-2",
    "title": "Basi di C",
    "section": "Sintassi di C",
    "text": "Sintassi di C\n#include &lt;stdio.h&gt;\n/* Il mio primo programma in C! */\nint main(void)\n{\n    int anno = 2024;\n    printf(\"Hello Dati e Algoritmi %d\", anno);\n}\n\n\nDirettiva\nCommento\nFunzione"
  },
  {
    "objectID": "lessons/01/slide.html#sintassi-di-c-3",
    "href": "lessons/01/slide.html#sintassi-di-c-3",
    "title": "Basi di C",
    "section": "Sintassi di C",
    "text": "Sintassi di C\n#include &lt;stdio.h&gt;\n/* Il mio primo programma in C! */\nint main(void)\n{\n    int anno = 2024;\n    printf(\"Hello Dati e Algoritmi %d\", anno);\n}\n\n\nDirettiva\nCommento\nFunzione\nDichiarazione e assegnazione di variabile"
  },
  {
    "objectID": "lessons/01/slide.html#sintassi-di-c-4",
    "href": "lessons/01/slide.html#sintassi-di-c-4",
    "title": "Basi di C",
    "section": "Sintassi di C",
    "text": "Sintassi di C\n#include &lt;stdio.h&gt;\n/* Il mio primo programma in C! */\nint main(void)\n{\n    int anno = 2024;\n    printf(\"Hello Dati e Algoritmi %d\", anno);\n}\n\n\nDirettiva\nCommento\nFunzione\nDichiarazione e assegnazione di variabile\nChiamata di funzione"
  },
  {
    "objectID": "lessons/01/slide.html#commenti",
    "href": "lessons/01/slide.html#commenti",
    "title": "Basi di C",
    "section": "Commenti",
    "text": "Commenti\nI commenti classici di C si fanno con la sintassi\n/* testo del commento\nint i = 0; &lt;--- questo viene ignorato\nanche su più righe */\n\nDal C99, si può usare anche il commento monoriga\n// commento su una riga\nint i = 0; // questo viene eseguito\n// altro commento"
  },
  {
    "objectID": "lessons/01/slide.html#dichiarazioni-e-inizializzazioni",
    "href": "lessons/01/slide.html#dichiarazioni-e-inizializzazioni",
    "title": "Basi di C",
    "section": "Dichiarazioni e inizializzazioni",
    "text": "Dichiarazioni e inizializzazioni\nTutte le variabili devono essere dichiarate prima di essere usate:\nint altezza;\nfloat temperatura, peso;\nNon c’è inizializzazione di default! Occorre assegnare valori:\nint altezza;\naltezza = 175;\nfloat temperatura = 36.4f; // anche subito"
  },
  {
    "objectID": "lessons/01/slide.html#keyword-riservate",
    "href": "lessons/01/slide.html#keyword-riservate",
    "title": "Basi di C",
    "section": "Keyword riservate",
    "text": "Keyword riservate\nNon si possono usare le seguenti parole per nomi di variabili o altro:\nauto     break   case    char      const      continue   default   do\ndouble   else    enum    extern    float      for        goto      if\ninline*  int     long    register  restrict*  return     short     signed\nsizeof   static  struct  switch    typedef    union      unsigned  void\nvolatile while   _Bool*  _Complex* _Imaginary*\n*solo da C99\n\n\n\n\n\n\nIl C è case sensitive\n\n\nNomi di variabili valide sono:\nint a, A; float Auto;\nN.B. solo perché si può non vuol dire che sia una buona idea…"
  },
  {
    "objectID": "lessons/01/slide.html#inputoutput",
    "href": "lessons/01/slide.html#inputoutput",
    "title": "Basi di C",
    "section": "Input/Output",
    "text": "Input/Output\n\nAbbiamo già usato nei nostri esempi l’inclusione di stdio.h\nCi ha permesso di usare la funzione printf, con la quale possiamo stampare dei risultati a terminale\nL’altra importante funzione che ci permette di usare è scanf, che legge i dati forniti dall’utente a terminale\nEntrambe usano testo formattato, tramite uso di simboli speciali"
  },
  {
    "objectID": "lessons/01/slide.html#output-con-printf",
    "href": "lessons/01/slide.html#output-con-printf",
    "title": "Basi di C",
    "section": "Output con printf",
    "text": "Output con printf\n$ man 3 printf\n\nPRINTF(3)              Linux Programmer's Manual              PRINTF(3)\n\nNAME\n       printf,  fprintf, dprintf, sprintf, snprintf, vprintf, vfprintf,\n       vdprintf, vsprintf, vsnprintf - formatted output conversion\n\nSYNOPSIS\n       #include &lt;stdio.h&gt;\n\n       int printf(const char *format, ...);\n       int fprintf(FILE *stream, const char *format, ...);\n       int dprintf(int fd, const char *format, ...);\n       int sprintf(char *str, const char *format, ...);\n       int snprintf(char *str, size_t size, const char *format, ...);\n\n...\n\nDESCRIPTION\n       The functions in the printf() family produce output according to\n       a  format  as  described  below.   The  functions  printf()  and\n       vprintf()  write  output  to stdout, the standard output stream;\n       fprintf() and  vfprintf()  write  output  to  the  given  output\n       stream; sprintf(), snprintf(), vsprintf(), and vsnprintf() write\n       to the character string str."
  },
  {
    "objectID": "lessons/01/slide.html#il-manuale",
    "href": "lessons/01/slide.html#il-manuale",
    "title": "Basi di C",
    "section": "Il manuale",
    "text": "Il manuale\nIl comando man permette di visualizzare il manuale di un comando o di una funzione. È diviso in sezioni:\n\nProgrammi eseguibili e comandi della shell\nChiamate al sistema (funzioni fornite dal kernel)\nChiamate alle librerie (funzioni all’interno delle librerie di sistema)\nFile speciali (di solito trovabili in /dev)\nFormati dei file e convenzioni p.es. /etc/passwd\nGiochi\nPacchetti di macro e convenzioni p.es. man(7), groff(7).\nComandi per l’amministrazione del sistema (solitamente solo per root)\nRoutine del kernel [Non standard]"
  },
  {
    "objectID": "lessons/01/slide.html#output-con-printf-2",
    "href": "lessons/01/slide.html#output-con-printf-2",
    "title": "Basi di C",
    "section": "Output con printf",
    "text": "Output con printf\nGli specificatori iniziano con %, e per ciascuno deve esserci un parametro dopo la stringa di formattazione\nprintf(\"Misura %d metri e %d cm \\n\", met, cm);\nOutput: Misura 2 e 15 cm\nI caratteri speciali sii scrivono con \\ (backslash) il carattere di escaping\nprintf(\"Si va a capo con \\\\n\\n\");\nOutput: Si va a capo con \\n"
  },
  {
    "objectID": "lessons/01/slide.html#section",
    "href": "lessons/01/slide.html#section",
    "title": "Basi di C",
    "section": "",
    "text": "Tabella 1: Formattazione stringhe\n\n\n\n\n\nFormat specifier\nValue\nOutput\n\n\n\n\n%c\n'm'\nm\n\n\n%d\n255\n255\n\n\n%ld\n99\n99\n\n\n%x\n255\nff\n\n\n%f\n25.8\n25.799999\n\n\n%g\n25.8\n25.8\n\n\n%s\n\"hello\"\nhello\n\n\n%8.3f\n25.8\n˽˽25.800\n\n\n%6d\n255\n˽˽˽255\n\n\n%06d\n255\n000255\n\n\n%-6d\n255\n255˽˽˽\n\n\n\n\n\n\n\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    char c_val = 'm';\n    int i_val = 255;\n    long int l_val = 99;\n    float f_val = 25.8;\n\n    printf(\"%c\\n\", c_val);\n    printf(\"%d\\n\", i_val);\n    printf(\"%ld\\n\", l_val);\n    printf(\"%x\\n\", i_val);\n    printf(\"%f\\n\", f_val);\n    printf(\"%g\\n\", f_val);\n    printf(\"%s\\n\", \"hello\");\n    printf(\"%8.3f\\n\", f_val);\n    printf(\"%6d\\n\", i_val);\n    printf(\"%06d\\n\", i_val);\n    printf(\"%-6d\\n\", i_val);\n}"
  },
  {
    "objectID": "lessons/01/slide.html#output-con-printf-3",
    "href": "lessons/01/slide.html#output-con-printf-3",
    "title": "Basi di C",
    "section": "Output con printf",
    "text": "Output con printf\n\n%d per interi, es. \\(10\\)\n%f per float, es. \\(3.14\\)\n%e per float in notazione scientifica, es. \\(5.2\\times 10^4\\)\n%lf per double, es. \\(3.14\\)\n%s per stringhe, es. \"ciao\"\n%c per caratteri, es. 'a'\n%p per puntatori, es. 0x7fffbf7f3b4c\n%x per interi in esadecimale, es. ff\n%o per interi in ottale, es. 77\n%Nf per avere \\(N\\) “spazi” per la stampa, es. %5d per 112 con due spazi vuoti prima\n%.Nf per float con \\(N\\) cifre decimali, es. %.2f per \\(3.14\\)"
  },
  {
    "objectID": "lessons/01/slide.html#string-format",
    "href": "lessons/01/slide.html#string-format",
    "title": "Basi di C",
    "section": "String format",
    "text": "String format\nSi è già visto \\n per andare a capo, ma ce ne sono altri:\n\n\\n per andare a capo\n\\t per tabulare\n\\b per backspace\n\\\\ per stampare il backslash\n\\\" per stampare le virgolette\n\\0 per terminare una stringa"
  },
  {
    "objectID": "lessons/01/slide.html#input-con-scanf",
    "href": "lessons/01/slide.html#input-con-scanf",
    "title": "Basi di C",
    "section": "Input con scanf",
    "text": "Input con scanf\nscanf esegue pattern matching sull’input per popolare delle variabili\nint base, altezza;\nscanf(\n    \"%d%d\", // pattern\n    &base, &altezza // variabili da popolare\n);\nPer esempio se l’utente scrive 3 4 e preme invio, base sarà 3 e altezza sarà 4."
  },
  {
    "objectID": "lessons/01/slide.html#input-con-scanf-2",
    "href": "lessons/01/slide.html#input-con-scanf-2",
    "title": "Basi di C",
    "section": "Input con scanf",
    "text": "Input con scanf\nscanf scorre l’input ignorando ogni carattere bianco (spazi, tabulazioni, a capo).\nSe trova caratteri compatibili (+/-, 0-9, .) li legge e li converte nel tipo di variabile corrispondente.\nPopola le variabili fino a trovare un carattere bianco o un carattere non compatibile."
  },
  {
    "objectID": "lessons/01/slide.html#input-con-scanf-3",
    "href": "lessons/01/slide.html#input-con-scanf-3",
    "title": "Basi di C",
    "section": "Input con scanf",
    "text": "Input con scanf\n&base?\n\nÈ un puntatore! Per poter salvare in memoria il valore letto da scanf è necessario passare l’indirizzo di memoria della variabile, non la variabile stessa.\n\n\n\n\n\n\nAvviso\n\n\nDimenticarsi il simbolo & in questo caso darà un errore a runtime"
  },
  {
    "objectID": "lessons/01/slide.html#input-con-scanf-4",
    "href": "lessons/01/slide.html#input-con-scanf-4",
    "title": "Basi di C",
    "section": "Input con scanf",
    "text": "Input con scanf\nUn puntatore è un indirizzo di memoria. Quando si passa un puntatore a una funzione, si passa l’indirizzo di memoria della variabile, non la variabile stessa. Questo permette alla funzione di scrivere direttamente nella variabile, senza doverne fare una copia."
  },
  {
    "objectID": "lessons/01/slide.html#input-con-scanf-5",
    "href": "lessons/01/slide.html#input-con-scanf-5",
    "title": "Basi di C",
    "section": "Input con scanf",
    "text": "Input con scanf\n\nAttenzione a non confonder printf e scanf, per quanto simili siano.\nscanf accetta gli stessi format specifier di printf, ma alcuni hanno meno varietà. Usate per il momento solo %d e %f.\nprintf accetta valori, scanf accetta puntatori. Bisogna ricordarsi di non scrivere & davanti alle variabili in printf e di scriverlo in scanf (quando serve).\nSi possono mettere caratteri oltre ai format specifier in una scanf, ma può creare problemi."
  },
  {
    "objectID": "lessons/01/slide.html#esercizi",
    "href": "lessons/01/slide.html#esercizi",
    "title": "Basi di C",
    "section": "Esercizi",
    "text": "Esercizi\n\nScrivere un programma che legga due numeri e stampi la somma.\n\n\n\nScrivere un programma che legga due frazioni in formato \"n/m\" e stampi la loro somma (non semplificata).\n\n\n\n\n\n\n\n\n\nConsiglio\n\n\nIn questo caso possiamo richiedere all’utente che il formato includa lo slash, e quindi includerlo nel pattern di scanf.\n\n\n\n\n\n\n\n\nDati e Algoritmi\n\n\n\n\nAltri esercizi sono disponibili a questo link."
  },
  {
    "objectID": "extra/formatting.html",
    "href": "extra/formatting.html",
    "title": "Guida per formattare il codice",
    "section": "",
    "text": "Clang-Format è uno strumento di formattazione del codice sorgente basato su Clang, il front-end del compilatore LLVM. La sua principale funzione è quella di formattare il codice sorgente in base a regole di stile specifiche, garantendo coerenza e leggibilità del codice. Questo strumento è particolarmente utile in contesti di sviluppo collaborativo, dove diversi programmatori possono avere differenti preferenze di formattazione. Utilizzare clang-format permette di mantenere uno stile uniforme nel codice sorgente, facilitando la comprensione, la manutenzione e la revisione del codice.\nNel caso di questo corso invece permette di assicurarsi che il codice sorgente segua lo stile esplicitato nella guida di stile e garantisce che sia leggibile prima di condividere il codice con qualcun altro.\nIn generale si consiglia di utilizzare clang-format specificando lo stile microsoft nella seguente maniera:",
    "crumbs": [
      "Risorse",
      "Come scrivere codice",
      "Formatting"
    ]
  },
  {
    "objectID": "extra/formatting.html#installazione-e-uso-su-linux",
    "href": "extra/formatting.html#installazione-e-uso-su-linux",
    "title": "Guida per formattare il codice",
    "section": "Installazione e uso su Linux",
    "text": "Installazione e uso su Linux\nSu Linux, l’installazione di clang-format può essere effettuata tramite il gestore dei pacchetti della distribuzione utilizzata. Ad esempio, su Ubuntu e derivate, si può installare con il seguente comando:\nsudo apt-get install clang-format\nUna volta installato, è possibile utilizzare clang-format direttamente da riga di comando specificando il file sorgente da formattare. Ad esempio:\nclang-format -i file.c\nQuesto comando formatta il file “file.c” utilizzando le impostazioni predefinite di clang-format.",
    "crumbs": [
      "Risorse",
      "Come scrivere codice",
      "Formatting"
    ]
  },
  {
    "objectID": "extra/formatting.html#installazione-e-uso-su-macos",
    "href": "extra/formatting.html#installazione-e-uso-su-macos",
    "title": "Guida per formattare il codice",
    "section": "Installazione e uso su macOS",
    "text": "Installazione e uso su macOS\nSu macOS, clang-format può essere installato utilizzando Homebrew, un gestore di pacchetti per macOS. Per installare clang-format con Homebrew, eseguire i seguenti comandi:\nbrew update\nbrew install clang-format\nDopo l’installazione, è possibile utilizzare clang-format come descritto in precedenza per Linux.",
    "crumbs": [
      "Risorse",
      "Come scrivere codice",
      "Formatting"
    ]
  },
  {
    "objectID": "extra/formatting.html#installazione-e-uso-su-windows",
    "href": "extra/formatting.html#installazione-e-uso-su-windows",
    "title": "Guida per formattare il codice",
    "section": "Installazione e uso su Windows",
    "text": "Installazione e uso su Windows\nSu Windows, clang-format può essere installato come parte del pacchetto LLVM. Per installare LLVM e quindi clang-format, seguire questi passaggi:\n\nScaricare il pacchetto di installazione di LLVM dal sito ufficiale (https://llvm.org/).\nEseguire il programma di installazione e seguire le istruzioni guidate.\nAssicurarsi di selezionare l’opzione per installare clang-format durante il processo di installazione.\n\nDopo l’installazione, è possibile utilizzare clang-format da riga di comando come descritto in precedenza per Linux e macOS.",
    "crumbs": [
      "Risorse",
      "Come scrivere codice",
      "Formatting"
    ]
  },
  {
    "objectID": "extra/formatting.html#utilizzo-avanzato",
    "href": "extra/formatting.html#utilizzo-avanzato",
    "title": "Guida per formattare il codice",
    "section": "Utilizzo avanzato",
    "text": "Utilizzo avanzato\nClang-Format offre numerose opzioni per personalizzare la formattazione del codice sorgente. È possibile specificare un file di configurazione .clang-format per definire regole di formattazione personalizzate. Inoltre, clang-format supporta diversi stili di formattazione predefiniti, come Google, LLVM, Mozilla e altri.\nPer ulteriori informazioni sulle opzioni di configurazione e sugli stili di formattazione supportati, consultare la documentazione ufficiale di Clang-Format.",
    "crumbs": [
      "Risorse",
      "Come scrivere codice",
      "Formatting"
    ]
  },
  {
    "objectID": "extra/style_guide.html",
    "href": "extra/style_guide.html",
    "title": "Guida allo stile per il linguaggio C",
    "section": "",
    "text": "Nota\n\n\n\nLa presente guida è un riadattamento dalla style guide del CS50 di Harvard per il corso di Dati e Algoritmi dell’Università di Padova.\nNon esiste un modo “giusto” unico per scrivere codice. Ma ci sono sicuramente molti modi sbagliati (o, almeno, cattivi). Ad ogni modo, essendo questo un corso di introduzione a C, è una buona occasione per mettere in pratica alcune regole di stile per scrivere fin da subito codice leggibile e mantenibile.",
    "crumbs": [
      "Risorse",
      "Come scrivere codice",
      "Style Guide"
    ]
  },
  {
    "objectID": "extra/style_guide.html#lunghezza-della-linea",
    "href": "extra/style_guide.html#lunghezza-della-linea",
    "title": "Guida allo stile per il linguaggio C",
    "section": "Lunghezza della linea",
    "text": "Lunghezza della linea\nPer convenzione, la lunghezza massima di una riga di codice è di 80 caratteri in C, questa è una scelta di ragioni storiche, infatti negli anni ’80 i monitor di dimensioni standard potevano visualizzare 24 linee verticali e 80 caratteri orizzontali. Anche se la tecnologia moderna ha reso obsoleta la necessità di mantenere le linee limitate a 80 caratteri, è comunque una linea guida che dovrebbe essere considerata come un “limite flessibile”. Oggi, solitamente, si cerca di non superare i 100 caratteri in una singola linea. Se hai bisogno di più di 100 caratteri, potrebbe essere il momento di ripensare sia ai nomi delle variabili che al design complessivo del programma!",
    "crumbs": [
      "Risorse",
      "Come scrivere codice",
      "Style Guide"
    ]
  },
  {
    "objectID": "extra/style_guide.html#commenti",
    "href": "extra/style_guide.html#commenti",
    "title": "Guida allo stile per il linguaggio C",
    "section": "Commenti",
    "text": "Commenti\nI commenti rendono il codice più leggibile, non solo per gli altri, ma anche per te, specialmente quando passano ore, giorni, settimane, mesi o anni tra la scrittura e la lettura del tuo stesso codice. Commentare troppo poco è sbagliato. Commentare troppo è sbagliato. Dove sta il punto giusto? Commentare ogni poche righe di codice (cioè, blocchi interessanti) è una buona linea guida. Cerca di scrivere commenti che rispondano a una o entrambe queste domande:\n\nCosa fa questo blocco?\nPerché ho implementato questo blocco in questo modo?\n\nAll’interno delle funzioni, utilizza “commenti in linea” e mantienili brevi (ad esempio, una riga), altrimenti diventa difficile distinguere i commenti dal codice. Posiziona il commento sopra la riga (o le righe) a cui si applica. Non è necessario scrivere frasi complete, ma metti in maiuscolo la prima parola del commento (a meno che non sia il nome di una funzione, variabile o simile), e lascia uno spazio tra // e il primo carattere del tuo commento, come in:\n// Converti Fahrenheit in Celsius\nfloat c = 5.0 / 9.0 * (f - 32.0);\nIn altre parole, non fare questo:\n// converti Fahrenheit in Celsius\nfloat c = 5.0 / 9.0 * (f - 32.0);\nO questo:\nfloat c = 5.0 / 9.0 * (f - 32.0); // Converti Fahrenheit in Celsius\nNelle prime righe dei file .c e .h dovrebbe esserci un commento che riassuma ciò che fa il tuo programma (o quel particolare file).\nSopra ciascuna delle tue funzioni (eccetto, forse, main), dovrebbe invece esserci un commento che riassuma cosa fa la tua funzione, come in:\n// Restituisce il quadrato di n\nint quadrato(int n)\n{\n    return n * n;\n}",
    "crumbs": [
      "Risorse",
      "Come scrivere codice",
      "Style Guide"
    ]
  },
  {
    "objectID": "extra/style_guide.html#intestazioni-delle-librerie",
    "href": "extra/style_guide.html#intestazioni-delle-librerie",
    "title": "Guida allo stile per il linguaggio C",
    "section": "Intestazioni delle librerie",
    "text": "Intestazioni delle librerie\nTutte le intestazioni delle librerie che includi dovrebbero essere elencate in ordine alfabetico, come in:\n#include &lt;math.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\nQuesto rende più facile vedere in un colpo d’occhio, specialmente in un elenco lungo, se hai incluso un’intestazione.",
    "crumbs": [
      "Risorse",
      "Come scrivere codice",
      "Style Guide"
    ]
  },
  {
    "objectID": "extra/style_guide.html#condizioni",
    "href": "extra/style_guide.html#condizioni",
    "title": "Guida allo stile per il linguaggio C",
    "section": "Condizioni",
    "text": "Condizioni\nLe condizioni dovrebbero essere stilizzate come segue:\nif (x &gt; 0)\n{\n    printf(\"x è positivo\\n\");\n}\nelse if (x &lt; 0)\n{\n    printf(\"x è negativo\\n\");\n}\nelse\n{\n    printf(\"x è zero\\n\");\n}\nNota come:\n\nle parentesi graffe si allineano bene, ognuna sulla propria linea, rendendo perfettamente chiaro cosa c’è dentro il ramo;\nc’è uno spazio singolo dopo ogni if;\nogni chiamata a printf è indentata con 4 spazi;\nci sono spazi singoli intorno a &gt; e intorno a &lt;; e\nnon c’è alcuno spazio immediatamente dopo ogni ( o immediatamente prima di ogni ).\n\nPer risparmiare spazio, alcuni programmatori preferiscono mantenere la prima parentesi graffa sulla stessa riga della condizione stessa, ma non lo consigliamo, poiché è più difficile da leggere, quindi non fare questo:\nif (x &lt; 0) {\n    printf(\"x è negativo\\n\");\n} else if (x &lt; 0) {\n    printf(\"x è negativo\\n\");\n}\nE sicuramente non fare questo:\nif (x &lt; 0)\n    {\n    printf(\"x è negativo\\n\");\n    }\nelse\n    {\n    printf(\"x è negativo\\n\");\n    }",
    "crumbs": [
      "Risorse",
      "Come scrivere codice",
      "Style Guide"
    ]
  },
  {
    "objectID": "extra/style_guide.html#switch",
    "href": "extra/style_guide.html#switch",
    "title": "Guida allo stile per il linguaggio C",
    "section": "Switch",
    "text": "Switch\nDichiara uno switch come segue:\nswitch (n)\n{\n    case -1:\n        printf(\"n è -1\\n\");\n        break;\n\n    case 1:\n        printf(\"n è 1\\n\");\n        break;\n\n    default:\n        printf(\"n non è né -1 né 1\\n\");\n        break;\n}\nNota come:\n\nogni parentesi graffa sia su una propria riga;\nc’è uno spazio singolo dopo switch;\nnon c’è spazio immediatamente dopo ogni ( o prima di ogni );\ni casi dello switch sono indentati con 4 spazi;\ni corpi dei casi sono indentati ulteriormente con 4 spazi; e\nogni case (incluso default) termina con un break.",
    "crumbs": [
      "Risorse",
      "Come scrivere codice",
      "Style Guide"
    ]
  },
  {
    "objectID": "extra/style_guide.html#funzioni",
    "href": "extra/style_guide.html#funzioni",
    "title": "Guida allo stile per il linguaggio C",
    "section": "Funzioni",
    "text": "Funzioni\nIn conformità con C99, assicurati di dichiarare main con:\nint main(void)\n{\n\n}\no con:\nint main(int argc, char *argv[])\n{\n\n}\no anche con:\nint main(int argc, char **argv)\n{\n\n}\nNon dichiarare main con:\nint main()\n{\n\n}\no con:\nvoid main()\n{\n\n}\no con:\nmain()\n{\n\n}\nPer le tue stesse funzioni, assicurati di definirle similmente, con ogni parentesi graffa su una propria riga e con il tipo di ritorno sulla stessa riga del nome della funzione, proprio come abbiamo fatto con main.",
    "crumbs": [
      "Risorse",
      "Come scrivere codice",
      "Style Guide"
    ]
  },
  {
    "objectID": "extra/style_guide.html#indentazione",
    "href": "extra/style_guide.html#indentazione",
    "title": "Guida allo stile per il linguaggio C",
    "section": "Indentazione",
    "text": "Indentazione\nIndenta il tuo codice con quattro spazi alla volta per chiarire quali blocchi di codice sono contenuti all’interno di altri. Se usi il tasto Tab sulla tastiera per farlo, assicurati che l’editor di testo sia configurato per convertire le tabulazioni (\\t) in quattro spazi, altrimenti il tuo codice potrebbe non essere stampato o visualizzato correttamente sul computer di qualcun altro, poiché \\t si renderizza in modo diverso in editor diversi.\nEcco del codice ben indentato:\n// Stampare gli argomenti della riga di comando uno per riga\nprintf(\"\\n\");\nfor (int i = 0; i &lt; argc; i++)\n{\n    for (int j = 0, n = strlen(argv[i]); j &lt; n; j++)\n    {\n        printf(\"%c\\n\", argv[i][j]);\n    }\n    printf(\"\\n\");\n}",
    "crumbs": [
      "Risorse",
      "Come scrivere codice",
      "Style Guide"
    ]
  },
  {
    "objectID": "extra/style_guide.html#cicli",
    "href": "extra/style_guide.html#cicli",
    "title": "Guida allo stile per il linguaggio C",
    "section": "Cicli",
    "text": "Cicli\n\nfor\nOgni volta che hai bisogno di variabili temporanee per l’iterazione, usa i, poi j, poi k, a meno che nomi più specifici non rendano il tuo codice più leggibile:\nfor (int i = 0; i &lt; LIMITE; i++)\n{\n    for (int j = 0; j &lt; LIMITE; j++)\n    {\n        for (int k = 0; k &lt; LIMITE; k++)\n        {\n            // Fai qualcosa\n        }\n    }\n}\nSe hai bisogno di più di tre variabili per l’iterazione, potrebbe essere il momento di ripensare il tuo design!\n\n\nwhile\nDichiara i cicli while come segue:\nwhile (condizione)\n{\n    // Fai qualcosa\n}\nNota come:\n\nogni parentesi graffa sia su una propria riga;\nc’è uno spazio singolo dopo while;\nnon c’è spazio immediatamente dopo il ( o prima del ); e\nil corpo del ciclo (un commento in questo caso) è indentato con 4 spazi.\n\n\n\ndo … while\nDichiara i cicli do ... while come segue:\ndo\n{\n    // Fai qualcosa\n}\nwhile (condizione);\nNota come:\n\nogni parentesi graffa sia su una propria riga;\nc’è uno spazio singolo dopo while;\nnon c’è spazio immediatamente dopo il ( o prima del ); e\nil corpo del ciclo (un commento in questo caso) è indentato con 4 spazi.",
    "crumbs": [
      "Risorse",
      "Come scrivere codice",
      "Style Guide"
    ]
  },
  {
    "objectID": "extra/style_guide.html#puntatori",
    "href": "extra/style_guide.html#puntatori",
    "title": "Guida allo stile per il linguaggio C",
    "section": "Puntatori",
    "text": "Puntatori\nQuando dichiari un puntatore, scrivi * accanto alla variabile, come in:\nint *p;\nNon scriverlo accanto al tipo, come in:\nint* p;",
    "crumbs": [
      "Risorse",
      "Come scrivere codice",
      "Style Guide"
    ]
  },
  {
    "objectID": "extra/style_guide.html#variabili",
    "href": "extra/style_guide.html#variabili",
    "title": "Guida allo stile per il linguaggio C",
    "section": "Variabili",
    "text": "Variabili\nPoiché in questo corso si utilizza C99, non definire tutte le tue variabili all’inizio delle tue funzioni ma, piuttosto, quando e dove ne hai effettivamente bisogno. Inoltre, limita il più possibile lo scope delle tue variabili. Ad esempio, se i è necessario solo per il ciclo, dichiara i all’interno del ciclo stesso:\nfor (int i = 0; i &lt; LIMITE; i++)\n{\n    printf(\"%i\\n\", i);\n}\nAnche se è accettabile utilizzare variabili come i, j e k per l’iterazione, la maggior parte delle tue variabili dovrebbe avere nomi più specifici. Se stai sommando alcuni valori, ad esempio, chiamare la tua variabile somma. Se il nome della tua variabile giustifica due parole (ad esempio, ha_mangiato), metti un trattino basso (underscore) tra di esse, questo modo di chiamare le variabili è detto snake_case (altri modi di dare il nome alle variabili sono il CamelCase o il meno comune kebab-case).\n\n\n\n\n\n\nAttenzione\n\n\n\nPerché il kebab case è un formato più insolito degli altri? Se provi a dare un nome di variabile in kebab-case in un programma C cosa succede?\n\n\nSe dichiari più variabili dello stesso tipo contemporaneamente, è accettabile dichiararle insieme, come in:\nint quartieri, dimes, nickels, pennies;\nBasta non inizializzare alcune ma non altre, come in:\nint quartieri, dimes = 0, nickels = 0 , pennies;\nPrenditi cura anche di dichiarare i puntatori separatamente dai non puntatori, come in:\nint *p;\nint n;\nNon dichiarare puntatori sulla stessa riga dei non puntatori, come in:\nint *p, n;",
    "crumbs": [
      "Risorse",
      "Come scrivere codice",
      "Style Guide"
    ]
  },
  {
    "objectID": "extra/style_guide.html#strutture",
    "href": "extra/style_guide.html#strutture",
    "title": "Guida allo stile per il linguaggio C",
    "section": "Strutture",
    "text": "Strutture\nDichiara una struct come tipo come segue, con ogni parentesi graffa su una propria riga e i membri indentati al suo interno, con il nome del tipo anche sulla sua riga:\ntypedef struct\n{\n    char *nome;\n    int matricola;\n} studente_t;\nQuando definisci un tipo con typedef è buona prassi usare un nome che finisce con _t, questo per poterlo facilmente distinguere dai nomi di variabile, dalle funzioni o dalle macro.",
    "crumbs": [
      "Risorse",
      "Come scrivere codice",
      "Style Guide"
    ]
  },
  {
    "objectID": "lessons.html",
    "href": "lessons.html",
    "title": "Lezioni",
    "section": "",
    "text": "Le lezioni sono organizzate in maniera da illustrare di volta in volta un argomento specifico, prima da un punto di vista teorico e poi da un punto di vista pratico. Gli eserci sono propedeutici e servono a fissare i concetti appresi, ma anche a stimolare la creatività e la capacità di problem solving, pertanto è importante svolgerli con attenzione e dedizione seppure non siano obbligatori."
  },
  {
    "objectID": "lessons.html#calendario",
    "href": "lessons.html#calendario",
    "title": "Lezioni",
    "section": "Calendario",
    "text": "Calendario\n\n\n\n\n\n\n\n\nData\nArgomento\nCapitoli del libro di testo\n\n\n\n\n12/03/2024\nIntroduzione al corso e fondamenti di C\n1-3\n\n\n19/03/2024\nStrutture di controllo, tipi di base, funzioni e array\n4-9\n\n\n26/03/2024\nAncora array, puntatori e stringhe\n9-13\n\n\n09/04/2024\nOperatori bitwise\n20\n\n\n10/04/2024\nStruct e puntatori\n15-17\n\n\n23/04/2024\nPreparazione per l’esame\nNULL"
  },
  {
    "objectID": "faq.html",
    "href": "faq.html",
    "title": "FAQ",
    "section": "",
    "text": "Io conosco Python, Ruby, Haskell, Kotlin, Perl e ieri ho implementato un compilatore per il mio unico e innovativo linguaggio di programmazione. Perché dovrei imparare C?\n\nAffermazioni del tipo “Il nostro linguaggio è veloce quasi quanto il C, ma è più facile da scrivere” sono così comuni da diventare quasi cliché. Bene, C è sicuramente veloce quanto C, e lo scopo del corso è facilitare la comprensione di un linguaggio spesso conosciuto come ostico. La comprensione di un linguaggio che non astrae molti concetti e lascia molta responsabilità al programmatore è importante per avere delle solide basi su concetti che pervadono tutti i linguaggi di programmazione.\n\nIl mio telefono ha 6 GB di RAM, quindi perché i libri di testo dedicano così tante pagine a tecniche per risparmiare kilobytes di peso ai file eseguibili?\nIl mio vecchissimo computer riesce ad eseguire 3,200,000,000 istruzioni al secondo, perché dovrei interessarmi se un’operazione confronta 8 o 16 bit?\n\nDovremmo scrivere codice che possiamo scrivere velocemente e che sia leggibile dai nostri simili. Stiamo ancora scrivendo in C, quindi il nostro codice leggibile ma non perfettamente ottimizzato verrà comunque eseguito un ordine di grandezza più velocemente che se avessimo scritto codice comparabile in un numero qualsiasi di linguaggi alternativi.",
    "crumbs": [
      "Risorse",
      "FAQ"
    ]
  },
  {
    "objectID": "faq.html#come-si-svolge-lesame",
    "href": "faq.html#come-si-svolge-lesame",
    "title": "FAQ",
    "section": "Come si svolge l’esame?",
    "text": "Come si svolge l’esame?\nL’esame del corso di Dati e Algoritmi è scritto, in presenza e si svolge in 3 parti:\n\ndomande: verifica della conoscenza teorica in programma, semplici dimostrazioni;\nesercizi: capacità di risolvere problemi di progetto e analisi di algoritmi (simili a quelli affrontati durante il corso);\ncodice: scrittura in linguaggio C di algoritmi che utilizzano strutture dati;\n\nogni parte dell’esame dura 45 minuti, per un totale di 2 ore e 15 minuti.",
    "crumbs": [
      "Risorse",
      "FAQ"
    ]
  },
  {
    "objectID": "faq.html#come-si-calcola-il-voto-finale",
    "href": "faq.html#come-si-calcola-il-voto-finale",
    "title": "FAQ",
    "section": "Come si calcola il voto finale?",
    "text": "Come si calcola il voto finale?\nOgnuna delle tre parti dell’esame è valutata al massimo 11 punti, il voto è la somma delle tre parti.\n\n\n\n\n\n\nImportante\n\n\n\nSe in una delle tre parti si ottiene una valutazione inferiore a 4, l’esame è da considerarsi non superato nella sua interezza.\n\n\nCon 33 punti si ottiene la lode.\nDi seguito è riportato l’algoritmo di calcolo del voto finale:\n// algoritmo per calcolare il voto dell'esame\nint voto_finale(int domande, int esercizi, int codice)\n{\n    int voto = domande + esercizi + codice;\n\n    // se una delle tre parti è inferiore a 4,\n    // l'esame è da considerarsi non superato\n    if (domande &lt; 4 || esercizi &lt; 4 || codice &lt; 4)\n    {\n        voto = 0;\n    }\n\n    switch (voto)\n    {\n        case 31:\n        case 32:\n            voto = 30;\n            break;\n\n        case 33:\n            voto = 31; // 31 equivale a 30 e lode\n            break;\n\n        case default:\n            break;\n    }\n\n  return voto;\n}",
    "crumbs": [
      "Risorse",
      "FAQ"
    ]
  },
  {
    "objectID": "faq.html#posso-usare-il-mio-computer-per-scrivere-codice",
    "href": "faq.html#posso-usare-il-mio-computer-per-scrivere-codice",
    "title": "FAQ",
    "section": "Posso usare il mio computer per scrivere codice?",
    "text": "Posso usare il mio computer per scrivere codice?\nNo, la parte di scrittura di codice si svolge tramite i computer del laboratorio.",
    "crumbs": [
      "Risorse",
      "FAQ"
    ]
  },
  {
    "objectID": "faq.html#non-ho-un-computer-posso-svolgere-lesame",
    "href": "faq.html#non-ho-un-computer-posso-svolgere-lesame",
    "title": "FAQ",
    "section": "Non ho un computer, posso svolgere l’esame?",
    "text": "Non ho un computer, posso svolgere l’esame?\nSì, tuttavia per poter svolgere gli esercizi di programmazione è necessario avere una buona dimestichezza con l’uso di un computer ed è fortemente consigliato fare pratica a casa.",
    "crumbs": [
      "Risorse",
      "FAQ"
    ]
  },
  {
    "objectID": "CODE_OF_CONDUCT.html",
    "href": "CODE_OF_CONDUCT.html",
    "title": "Contributor Covenant Code of Conduct",
    "section": "",
    "text": "We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.\nWe pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.\n\n\n\nExamples of behavior that contributes to a positive environment for our community include:\n\nDemonstrating empathy and kindness toward other people\nBeing respectful of differing opinions, viewpoints, and experiences\nGiving and gracefully accepting constructive feedback\nAccepting responsibility and apologizing to those affected by our mistakes, and learning from the experience\nFocusing on what is best not just for us as individuals, but for the overall community\n\nExamples of unacceptable behavior include:\n\nThe use of sexualized language or imagery, and sexual attention or advances of any kind\nTrolling, insulting or derogatory comments, and personal or political attacks\nPublic or private harassment\nPublishing others’ private information, such as a physical or email address, without their explicit permission\nOther conduct which could reasonably be considered inappropriate in a professional setting\n\n\n\n\nCommunity leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.\nCommunity leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.\n\n\n\nThis Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.\n\n\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at spanio@dei.unipd.it. All complaints will be reviewed and investigated promptly and fairly.\nAll community leaders are obligated to respect the privacy and security of the reporter of any incident.\n\n\n\nCommunity leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:\n\n\nCommunity Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.\nConsequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.\n\n\n\nCommunity Impact: A violation through a single incident or series of actions.\nConsequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.\n\n\n\nCommunity Impact: A serious violation of community standards, including sustained inappropriate behavior.\nConsequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.\n\n\n\nCommunity Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.\nConsequence: A permanent ban from any sort of public interaction within the community.\n\n\n\n\nThis Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.\nCommunity Impact Guidelines were inspired by Mozilla’s code of conduct enforcement ladder.\nFor answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations."
  },
  {
    "objectID": "CODE_OF_CONDUCT.html#our-pledge",
    "href": "CODE_OF_CONDUCT.html#our-pledge",
    "title": "Contributor Covenant Code of Conduct",
    "section": "",
    "text": "We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.\nWe pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community."
  },
  {
    "objectID": "CODE_OF_CONDUCT.html#our-standards",
    "href": "CODE_OF_CONDUCT.html#our-standards",
    "title": "Contributor Covenant Code of Conduct",
    "section": "",
    "text": "Examples of behavior that contributes to a positive environment for our community include:\n\nDemonstrating empathy and kindness toward other people\nBeing respectful of differing opinions, viewpoints, and experiences\nGiving and gracefully accepting constructive feedback\nAccepting responsibility and apologizing to those affected by our mistakes, and learning from the experience\nFocusing on what is best not just for us as individuals, but for the overall community\n\nExamples of unacceptable behavior include:\n\nThe use of sexualized language or imagery, and sexual attention or advances of any kind\nTrolling, insulting or derogatory comments, and personal or political attacks\nPublic or private harassment\nPublishing others’ private information, such as a physical or email address, without their explicit permission\nOther conduct which could reasonably be considered inappropriate in a professional setting"
  },
  {
    "objectID": "CODE_OF_CONDUCT.html#enforcement-responsibilities",
    "href": "CODE_OF_CONDUCT.html#enforcement-responsibilities",
    "title": "Contributor Covenant Code of Conduct",
    "section": "",
    "text": "Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.\nCommunity leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate."
  },
  {
    "objectID": "CODE_OF_CONDUCT.html#scope",
    "href": "CODE_OF_CONDUCT.html#scope",
    "title": "Contributor Covenant Code of Conduct",
    "section": "",
    "text": "This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event."
  },
  {
    "objectID": "CODE_OF_CONDUCT.html#enforcement",
    "href": "CODE_OF_CONDUCT.html#enforcement",
    "title": "Contributor Covenant Code of Conduct",
    "section": "",
    "text": "Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at spanio@dei.unipd.it. All complaints will be reviewed and investigated promptly and fairly.\nAll community leaders are obligated to respect the privacy and security of the reporter of any incident."
  },
  {
    "objectID": "CODE_OF_CONDUCT.html#enforcement-guidelines",
    "href": "CODE_OF_CONDUCT.html#enforcement-guidelines",
    "title": "Contributor Covenant Code of Conduct",
    "section": "",
    "text": "Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:\n\n\nCommunity Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.\nConsequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.\n\n\n\nCommunity Impact: A violation through a single incident or series of actions.\nConsequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.\n\n\n\nCommunity Impact: A serious violation of community standards, including sustained inappropriate behavior.\nConsequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.\n\n\n\nCommunity Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.\nConsequence: A permanent ban from any sort of public interaction within the community."
  },
  {
    "objectID": "CODE_OF_CONDUCT.html#attribution",
    "href": "CODE_OF_CONDUCT.html#attribution",
    "title": "Contributor Covenant Code of Conduct",
    "section": "",
    "text": "This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.\nCommunity Impact Guidelines were inspired by Mozilla’s code of conduct enforcement ladder.\nFor answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations."
  },
  {
    "objectID": "extra/docker.html",
    "href": "extra/docker.html",
    "title": "Ambiente di sviluppo",
    "section": "",
    "text": "Per chi non ha una istallazione Linux (nativa o VM) è possibile riprodurre un ambiente identico a quello utilizzato nelle lezioni tramite una immagine docker. Ecco come fare:",
    "crumbs": [
      "Risorse",
      "Ambiente di sviluppo"
    ]
  },
  {
    "objectID": "extra/docker.html#metodi-alternativi",
    "href": "extra/docker.html#metodi-alternativi",
    "title": "Ambiente di sviluppo",
    "section": "Metodi alternativi",
    "text": "Metodi alternativi\n\nPer chi ha un sistema operativo MacOS o Linux basta installare gcc.\nIn Windows è possibile utilizzare WSL 2, un sistema simile a docker per integrare direttamente Ubuntu in Windows.",
    "crumbs": [
      "Risorse",
      "Ambiente di sviluppo"
    ]
  },
  {
    "objectID": "extra/license.html",
    "href": "extra/license.html",
    "title": "Open Source License",
    "section": "",
    "text": "I materiali presenti sul sito sono messi a disposizione sotto licenza Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. Il testo completo della licenza è disponibile qui.\nIl codice sorgente di questo sito è disponibile a https://github.com/matteospanio/corso-c.\nInoltre il sito fa uso di diversi altri progetti open-source, la distribuzione dei quali è soggetta alle rispettive licenze. I principali componenti e le loro licenze sono:\n\n\n\nProgetto\nLicenza\n\n\n\n\nPandoc\nGNU GPL v2\n\n\nBootstrap 5.1\nMIT\n\n\nBootswatch 5.1\nMIT\n\n\nDeno\nMIT\n\n\nesbuild\nMIT\n\n\nDart Sass\nMIT\n\n\nObservable Runtime\nISC\n\n\nQuarto 1.4\nMIT"
  },
  {
    "objectID": "extra/books.html",
    "href": "extra/books.html",
    "title": "Libri di testo",
    "section": "",
    "text": "Il libro del corso è Programmazione in C di Kim N. King, in particolare nell’edizione italiana edita da Apogeo.\n\nLetture consigliate\n\n\n\n\n\n\nNota\n\n\n\nQuesta è una lista di letture suggerite per approfondire concetti visti durante il corso, i contenuti di questi libri però non sono richiesti in sede d’esame.\n\n\n\n21st Century C di Ben Klemens\nExpert C Programming: Deep C secrets di Peter Van Der Linden\nHead First C di David e Dawn Griffiths\nAn introduction to C&GUI programming di Simon Long\nModern C di Jens Gustedt",
    "crumbs": [
      "Risorse",
      "Libri di testo"
    ]
  },
  {
    "objectID": "lessons/05/index.html",
    "href": "lessons/05/index.html",
    "title": "Struct e puntatori",
    "section": "",
    "text": "TODO\n\n\n\nRiutilizzareCC BY 4.0",
    "crumbs": [
      "Lezioni",
      "Struct e puntatori"
    ]
  },
  {
    "objectID": "lessons/03/index.html",
    "href": "lessons/03/index.html",
    "title": "Array, puntatori e stringhe",
    "section": "",
    "text": "TODO\n\n\n\nRiutilizzareCC BY 4.0",
    "crumbs": [
      "Lezioni",
      "Array, puntatori e stringhe"
    ]
  },
  {
    "objectID": "lessons/02/slide.html#tipi-di-dato",
    "href": "lessons/02/slide.html#tipi-di-dato",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Tipi di dato",
    "text": "Tipi di dato\nLe varibili possono contenere diversi tipi di dati, i tipi di dati base in C sono:\n\ninteri: int, short, long int, unsigned short/int/long int\nvirgola mobile: float, double, long double\nchar: caratteri\n\nInoltre esiste il tipo speciale void che indica l’assenza di informazione."
  },
  {
    "objectID": "lessons/02/slide.html#tipi-numerici",
    "href": "lessons/02/slide.html#tipi-numerici",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Tipi numerici",
    "text": "Tipi numerici\nI vari tipi di interi e tipi di virgola mobile si distinguono per il numero di byte usati per la loro rappresentazione in memoria e, conseguentemente, per il range di valori che possono rappresentare.\n\n\n\n\n\n\nNota\n\n\nIl numero di byte usati per rappresentare un tipo di dato dipende dal compilatore e dall’architettura del computer. Per sapere quanti byte vengono usati per rappresentare un tipo di dato si può usare l’operatore sizeof.\nPer conoscere il range di valori che può rappresentare un tipo di dato si può usare la libreria limits.h per i tipi interi e float.h per i tipi di virgola mobile."
  },
  {
    "objectID": "lessons/02/slide.html#tipi-numerici-1",
    "href": "lessons/02/slide.html#tipi-numerici-1",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Tipi numerici",
    "text": "Tipi numerici\n#include &lt;limits.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    printf(\"size of short: %lu\\n\", sizeof(short));\n    printf(\"size of int: %lu\\n\", sizeof(int));\n    printf(\"size of double: %lu\\n\", sizeof(double));\n    printf(\"INT_MAX = %d\\n\", INT_MAX);\n    printf(\"INT_MIN = %d\\n\", INT_MIN);\n    printf(\"UINT_MAX = %u\\n\", UINT_MAX);\n    printf(\"LONG_MAX = %ld\\n\", LONG_MAX);\n    printf(\"LONG_MIN = %ld\\n\", LONG_MIN);\n    printf(\"ULONG_MAX = %lu\\n\", ULONG_MAX);\n    printf(\"SHRT_MAX = %d\\n\", SHRT_MAX);\n    printf(\"SHRT_MIN = %d\\n\", SHRT_MIN);\n    printf(\"USHRT_MAX = %u\\n\", USHRT_MAX);\n}\n\n\n\nQuando si ha a che fare con questi valori è bene stare attenti agli overflow."
  },
  {
    "objectID": "lessons/02/slide.html#tipi-char",
    "href": "lessons/02/slide.html#tipi-char",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Tipi char",
    "text": "Tipi char\nIl tipo char è usato per rappresentare un singolo carattere. In C i caratteri sono rappresentati come interi senza segno di 8 bit.\nI char vanno sempre scritti tra apici singoli, scrivendo un solo carattere. Il C lin interpreterà come un intero."
  },
  {
    "objectID": "lessons/02/slide.html#conversioni-tra-tipi",
    "href": "lessons/02/slide.html#conversioni-tra-tipi",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Conversioni tra tipi",
    "text": "Conversioni tra tipi\nIn generale, per effettuare operazioni aritmetiche tra due numeri, questi devono essere dello stesso tipo.\nIn C è possibile mescolare tipi diversi nella stessa espressione, e il compilatore effettuerà automaticamente le conversioni necessarie per eseguire l’operazione richiesta."
  },
  {
    "objectID": "lessons/02/slide.html#conversioni-implicite",
    "href": "lessons/02/slide.html#conversioni-implicite",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Conversioni implicite",
    "text": "Conversioni implicite\nint a = 5;\nfloat b = 1.618;\n\na + b; // 6.618\nIn questo esempio, il valore intero a viene convertito implicitamente in virgola mobile prima di eseguire l’operazione di somma. Questo tipo di conversione è chiamato “promotion”."
  },
  {
    "objectID": "lessons/02/slide.html#conversioni-implicite-1",
    "href": "lessons/02/slide.html#conversioni-implicite-1",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Conversioni implicite",
    "text": "Conversioni implicite\nSe assegno un valore a una variabile di tipo diverso, il compilatore effettuerà una conversione implicita.\nint i = 1;\nfloat f;\nf = i; // 1.0\nf = 2; // 2.0\nÈ vero quindi anche il contrario:\nfloat f = 1.618;\nint i;\ni = f; // 1"
  },
  {
    "objectID": "lessons/02/slide.html#cast-espliciti",
    "href": "lessons/02/slide.html#cast-espliciti",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Cast espliciti",
    "text": "Cast espliciti\nÈ possibile convertire esplicitamente il tipo di un’ espressione con l’operazione di casting:\n(nome_tipo) espressione\nIl risultato dell’espressione viene convertito al tipo specificato.\nUn caso frequente è quando si esegue una divisione tra due interi:\nfloat quotient;\nint dividend, divisor;\nquotient = (float) dividend / divisor;"
  },
  {
    "objectID": "lessons/02/slide.html#operatori-1",
    "href": "lessons/02/slide.html#operatori-1",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Operatori",
    "text": "Operatori\nEsistono molteplici operatori, ognuno ha varie caratteristiche:\n\narietà: numero di argomenti (unario, binario, ternario)\nprecedenza: ordine in cui vengono analizzati gli operatori\nassociatività: se ci sono più operatori uguali (o di uguale precedenza)\nside-effects, se presenti (cioè le variabili coinvolte vengono cambiate o no)"
  },
  {
    "objectID": "lessons/02/slide.html#operatori-2",
    "href": "lessons/02/slide.html#operatori-2",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Operatori",
    "text": "Operatori\nGli operatori più in alto hanno priorità più alta:"
  },
  {
    "objectID": "lessons/02/slide.html#quiz",
    "href": "lessons/02/slide.html#quiz",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Quiz!",
    "text": "Quiz!\nIndovina l’output del seguente codice:\ni = 1;\nprintf(\"i is %d\\n\", i++);\nprintf(\"i is %d\\n\", i);\nprintf(\"i is %d\\n\", ++i);\nprintf(\"i is %d\\n\", i);"
  },
  {
    "objectID": "lessons/02/slide.html#operatori-3",
    "href": "lessons/02/slide.html#operatori-3",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Operatori",
    "text": "Operatori\ni++ è il post-incremento, ++i è il pre-incremento\ni = 1;\nprintf(\"i is %d\\n\", i++); /* i is 1 */\nprintf(\"i is %d\\n\", i);   /* i is 2 */\nprintf(\"i is %d\\n\", ++i); /* i is 3 */\nprintf(\"i is %d\\n\", i);   /* i is 3 */\n\n\n\n\n\n\nDa grandi poteri derivano grandi bugs…\n\n\nGli operatori di post/pre-incremento sono molto utili e vengono usati spesso, vanno però usati con attenzione. Nella maggior parte delle situazioni è bene usare queste operazioni atomicamente (da sole in una riga)."
  },
  {
    "objectID": "lessons/02/slide.html#espressioni-istruzione",
    "href": "lessons/02/slide.html#espressioni-istruzione",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Espressioni istruzione",
    "text": "Espressioni istruzione\nTutte le espressioni possono essere anche statement: in una linea posso avere anche solo una operazione singola seguita da ;\ni = 1;      // utile\ni++;        // utile\ni * j + 2   // inutile, potrebbe dare warning\n            // \"statement with no effect\"\nNella seconda riga dell’esempio il risultato viene scartato, ma la modifica avviene lo stesso."
  },
  {
    "objectID": "lessons/02/slide.html#espressioni-logiche-1",
    "href": "lessons/02/slide.html#espressioni-logiche-1",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Espressioni logiche",
    "text": "Espressioni logiche\nAlcuni operatori ci dicono se una certa espressione è “vera” o “falsa”, ad esempio:\ni &lt; j && j &lt; k ci dice se \\(i\\) è minore sia di \\(j\\) che di \\(k\\)\n\n\n\n\n\n\nNota\n\n\n\\(i &lt; j &lt; k\\) si può scrivere ma non fa quello che sembra, in realtà: (i &lt; j) &lt; k è vero con int i=3, j=2, k=1."
  },
  {
    "objectID": "lessons/02/slide.html#bool",
    "href": "lessons/02/slide.html#bool",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "bool",
    "text": "bool\nIl tipo di ritorno di queste espressioni in C è un intero, il tipo booleano non esiste in C (in C99 si è provato a sistemare).\n\n\\(0 \\rightarrow\\) falso\n\\(1 \\rightarrow\\) vero (e tutti gli interi diversi da \\(0\\))\n\n\n\n\n\n\n\nNota\n\n\nDa C99 in poi, bool è un tipo definito in stdbool.h che può assumere solo i valori true e false.\n#include &lt;stdbool.h&gt;\nbool b = true;"
  },
  {
    "objectID": "lessons/02/slide.html#espressioni-logiche-2",
    "href": "lessons/02/slide.html#espressioni-logiche-2",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Espressioni logiche",
    "text": "Espressioni logiche\nGli operatori booleani producono tutti 0 oppure 1 come risultato, ma bisogna ricordare che qualunque valore diverso da 0 è considerato vero.\nL’espressione (5 && 1) viene valutata come vera in quanto entrambi i valori sono diversi da 0"
  },
  {
    "objectID": "lessons/02/slide.html#espressioni-logiche-3",
    "href": "lessons/02/slide.html#espressioni-logiche-3",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Espressioni logiche",
    "text": "Espressioni logiche\n\n!expr restituisce 1 se expr è 0\nexpr1 && expr2 restituisce 1 se entrambe le espressioni sono non-zero\nexpr1 || expr2 restituisce 1 se almeno una delle due espressioni è non-zero\n\n\n\n\n\n\n\nNota\n\n\nSia && che || sono operatori a corto circuito, cioè se il risultato è già noto dopo aver valutato la prima espressione, la seconda non viene valutata."
  },
  {
    "objectID": "lessons/02/slide.html#quiz-1",
    "href": "lessons/02/slide.html#quiz-1",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Quiz!",
    "text": "Quiz!\nQual è il valore di verità delle seguenti espressioni?\n\n!0\n1 && 2\n1 || 0\n1 &gt; 0\n'a' &gt; 'b'\n'Z' &gt; 'a'\n':' &lt; ';'"
  },
  {
    "objectID": "lessons/02/slide.html#control-flow-1",
    "href": "lessons/02/slide.html#control-flow-1",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Control flow",
    "text": "Control flow\nEssendo C un linguaggio strutturato, possiede un insieme di istruzioni di controllo del flusso di esecuzione del programma. Le principali istruzioni di controllo del flusso sono:\n\n\n\nif-else\nswitch\nfor\n\n\n\nwhile\ndo-while\nbreak\ncontinue"
  },
  {
    "objectID": "lessons/02/slide.html#if-else",
    "href": "lessons/02/slide.html#if-else",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "if-else",
    "text": "if-else\nL’istruzione if-else permette di eseguire un blocco di codice solo se una condizione è vera. La sintassi è la seguente:\nif (espressione) {\n    // statements\n} else {\n    // statements\n}"
  },
  {
    "objectID": "lessons/02/slide.html#if-else-annidati",
    "href": "lessons/02/slide.html#if-else-annidati",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "if-else annidati",
    "text": "if-else annidati\nOppure si può usare l’istruzione else if per evitare annidamenti.\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    int x = 10;\n    if (x &gt; 7)\n    {\n        printf(\"x è maggiore di 7\\n\");\n    }\n    else if (x &gt; 5)\n    {\n        printf(\"x è maggiore di 5\\n\");\n    }\n    else\n    {\n        printf(\"x è minore o uguale a 5\\n\");\n    }\n}\n\n\n\n\n\n\n\nAttenzione\n\n\nUn errore comune è confondere l’operatore di assegnamento = con l’operatore di confronto ==. Ad esempio, l’espressione x = 10 assegna il valore 10 alla variabile x, mentre l’espressione x == 10 confronta il valore della variabile x con 10. Se si scrive if (x = 10), l’espressione è sempre vera, perché assegna 10 alla variabile x e restituisce 10, che è considerato true. Per confrontare il valore della variabile x con 10, si deve invece scrivere if (x == 10)."
  },
  {
    "objectID": "lessons/02/slide.html#if-ternario",
    "href": "lessons/02/slide.html#if-ternario",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "If ternario",
    "text": "If ternario\nL’if ternario è una forma compatta dell’istruzione if-else. La sintassi è la seguente:\nespressione ? valore_se_vera : valore_se_falsa\nSe l’espressione è vera, viene restituito valore_se_vera, altrimenti viene restituito valore_se_falsa."
  },
  {
    "objectID": "lessons/02/slide.html#if-ternario-1",
    "href": "lessons/02/slide.html#if-ternario-1",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "If ternario",
    "text": "If ternario\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    int x = 10;\n    int y = (x &gt; 5) ? 1 : 0;\n\n    printf(\"y = %d\\n\", y);\n}\n\nQuesto modo di scrivere l’istruzione if-else è utile quando si vuole assegnare un valore a una variabile in base a una condizione con una sola riga di codice. Se l’espressione è complessa, l’uso dell’if ternario può rendere il codice meno leggibile."
  },
  {
    "objectID": "lessons/02/slide.html#switch",
    "href": "lessons/02/slide.html#switch",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "switch",
    "text": "switch\nTanti if in cascata potrebbero essere sostituiti da uno switch. La sintassi è la seguente:\nswitch (espressione) {\n    case constant-expression:\n        // statements\n        break;\n    case constant-expression:\n        // statements\n        break;\n    // ...\n    default:\n        // statements\n}\nLo switch può essere utilizzato solo con espressioni di tipo intero (int, char, short, long, ecc.) e con espressioni di tipo enum (che verrà trattato in seguito)."
  },
  {
    "objectID": "lessons/02/slide.html#cicli",
    "href": "lessons/02/slide.html#cicli",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Cicli",
    "text": "Cicli\nCaratteristica fondamentale di un linguaggio di programmazione sono i cicli. C implementa i classici for, while, ma anche do…while\n\nwhile (expression) { statements }\ndo { statements } while (expression)\nfor (initialization; condition; increment) { statements }"
  },
  {
    "objectID": "lessons/02/slide.html#cicli-1",
    "href": "lessons/02/slide.html#cicli-1",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Cicli",
    "text": "Cicli\nwhile e for sono equivalenti: tutto ciò che si può fare con un ciclo for si può fare con un ciclo while e viceversa. La scelta di quale istruzione utilizzare dipende dal contesto e dalla preferenza personale.\nL’istruzione do-while è simile a while, ma la condizione viene valutata alla fine del blocco di codice. Questo significa che il blocco di codice viene eseguito almeno una volta, anche se la condizione è falsa."
  },
  {
    "objectID": "lessons/02/slide.html#cicli-2",
    "href": "lessons/02/slide.html#cicli-2",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Cicli",
    "text": "Cicli\nDal C99 è possibile dichiarare variabili all’interno del ciclo for. Queste variabili sono visibili solo all’interno del ciclo. In C89 e nelle versioni precedenti, le variabili devono essere dichiarate all’inizio del blocco di codice.\nfor (int i = 0; i &lt; 10; i++) {\n    // ...\n}"
  },
  {
    "objectID": "lessons/02/slide.html#cicli-infiniti",
    "href": "lessons/02/slide.html#cicli-infiniti",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Cicli infiniti",
    "text": "Cicli infiniti\nUn ciclo infinito è un ciclo che non termina mai. Può essere creato utilizzando un’istruzione while con una condizione sempre vera o for senza condizione, ad esempio while (1) oppure for (;;).\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    int i = 0;\n    while (1)\n    {\n        printf(\"%d\\n\", i);\n        i++;\n        if (i == 10)\n            break;\n    }\n}"
  },
  {
    "objectID": "lessons/02/slide.html#break-e-continue",
    "href": "lessons/02/slide.html#break-e-continue",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "break e continue",
    "text": "break e continue\n\nL’istruzione break termina immediatamente il ciclo in cui si trova.\nL’istruzione continue termina l’iterazione corrente del ciclo e passa alla successiva.\n\n\n\n\n\n\n\nAvviso\n\n\nÈ bene non abusare di break e continue, perché possono rendere il codice meno leggibile. In generale, è meglio evitare di utilizzare break e `continue all’interno di cicli annidati."
  },
  {
    "objectID": "lessons/02/slide.html#esercizio-fizzbuzz",
    "href": "lessons/02/slide.html#esercizio-fizzbuzz",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Esercizio: FizzBuzz",
    "text": "Esercizio: FizzBuzz\nScrivere un programma che stampi i numeri da 1 a 100, ma per i multipli di 3 stampi “Fizz” e per i multipli di 5 stampi “Buzz”. Per i numeri che sono sia multipli di 3 che di 5 stampi “FizzBuzz”.\n\n\n\n\n\n\nSuggerimento\n\n\nL’operatore modulo % restituisce il resto della divisione tra due numeri. Ad esempio, 5 % 3 restituisce 2, perché 5 diviso 3 dà 1 con un resto di 2."
  },
  {
    "objectID": "lessons/02/slide.html#array-1",
    "href": "lessons/02/slide.html#array-1",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Array",
    "text": "Array\nGeneralmente una variabile può contenere un solo valore, spesso però si vuole eseguire operazioni su una sequenza di variabili, una soluzione è l’utilizzo di un array (o vettore). Un array è una collezione di elementi omogenei (tutti dello stesso tipo)."
  },
  {
    "objectID": "lessons/02/slide.html#array-2",
    "href": "lessons/02/slide.html#array-2",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Array",
    "text": "Array\nLa dichiarazione di un array avviene specificando il tipo e il numero degli elementi:\nint a[10]\nLa dimensione dell’array è una costante intera, spesso definita tramite una macro o una costante:\n#define N 10\nint a[N];\noppure:\nconst int N = 10;\nint a[N];"
  },
  {
    "objectID": "lessons/02/slide.html#array-3",
    "href": "lessons/02/slide.html#array-3",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Array",
    "text": "Array\nSi accede a un elemento dell’array tramite subscripting:\nint a[2];\na[0] = 1;\na[1] = 2;\nGli indici degli array in C partono da 0, come in Java.\n\n\n\n\n\n\nNota\n\n\nL’espressione a[i] (o simili) è un lvalue (left-value), ossia può essere usata come variabile, può quindi trovarsi a sinistra di un’assegnazione."
  },
  {
    "objectID": "lessons/02/slide.html#array-e-indici",
    "href": "lessons/02/slide.html#array-e-indici",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Array e indici",
    "text": "Array e indici\nIl compilatore C non controlla i limiti degli array, quindi è possibile accedere a elementi fuori dal range definito, questo può causare errori difficili da individuare.\nint a[10], i;\nfor (i = 0; i &lt;= 10; i++) {\n    a[i] = 0;\n}\nIn certi compilatori il codice sopra riportato causa un loop infinito (più spesso però genera un errore a runtime e ferma l’esecuzione)."
  },
  {
    "objectID": "lessons/02/slide.html#array-e-indici-1",
    "href": "lessons/02/slide.html#array-e-indici-1",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Array e indici",
    "text": "Array e indici\nSi intuisce che C sia molto permissivo con il subscripting, il seguente codice quindi è perfettamente legittimo:\nint a[50];\nint i = 0, j = 3;\na[i+j*10] = 0;\n\ni = 0;\nwhile (i &lt; j)\n    a[i++] = 0;"
  },
  {
    "objectID": "lessons/02/slide.html#array-inizializzazione",
    "href": "lessons/02/slide.html#array-inizializzazione",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Array: inizializzazione",
    "text": "Array: inizializzazione\nUn array può essere inizializzato al momento della dichiarazione:\nint a[5] = {1, 2, 3, 4, 5};\nSe si mettono meno numeri, i restanti elementi vengono inizializzati a 0 (ma questo non succede se non ne specifico nessuno!):\nint a[5] = {1, 2, 3}; // a = {1, 2, 3, 0, 0}\nint b[4] = {0}; // b = {0, 0, 0, 0}"
  },
  {
    "objectID": "lessons/02/slide.html#array-inizializzazione-1",
    "href": "lessons/02/slide.html#array-inizializzazione-1",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Array: inizializzazione",
    "text": "Array: inizializzazione\nSe metto più elementi di quelli dichiarati il compilatore segnala un errore. Se invece si omette la dimensione dell’array, il compilatore la calcola automaticamente dalla lista di initializzazione:\nint a[] = {1, 2, 3}; // a ha dimensione 3"
  },
  {
    "objectID": "lessons/02/slide.html#dimensione-di-un-array",
    "href": "lessons/02/slide.html#dimensione-di-un-array",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Dimensione di un array",
    "text": "Dimensione di un array\nIn C non esiste un sistema per ottenere senza sforzo la dimensione di un array, per questo, spesso, si utilizza una variabile per memorizzare la dimensione dell’array.\nTuttavia si può usare sizeof per ottenere la dimensione di un array:\nint a[10];\nsizeof(a); /* restituisce 40 su una macchina a 32 bit */\nsizeof(a[0]); /* 4 */\nsizeof(a)/sizeof(a[0]); /* 10, la dimensione dell'array */"
  },
  {
    "objectID": "lessons/02/slide.html#array-multidimensionali",
    "href": "lessons/02/slide.html#array-multidimensionali",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Array multidimensionali",
    "text": "Array multidimensionali\nUn array può contenere elementi di qualsiasi tipo, anche altri array! Per dichiarare un array multidimensionale si specifica il numero di elementi per ogni dimensione:\nint matrix[5][9];\nPer accedere a un elemento di un array multidimensionale si usano più indici:\nmatrix[1][5] = 42; e NON matrix[1,5] = 42;"
  },
  {
    "objectID": "lessons/02/slide.html#array-multidimensionali-1",
    "href": "lessons/02/slide.html#array-multidimensionali-1",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Array multidimensionali",
    "text": "Array multidimensionali\nint matrix[5][9];"
  },
  {
    "objectID": "lessons/02/slide.html#array-esercizi-1",
    "href": "lessons/02/slide.html#array-esercizi-1",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Array: esercizi (1)",
    "text": "Array: esercizi (1)\nScrivere un programma che distribuisca una mano di carte per il gioco della briscola (3 carte) e le stampi a video."
  },
  {
    "objectID": "lessons/02/slide.html#array-esercizi-2",
    "href": "lessons/02/slide.html#array-esercizi-2",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Array: esercizi (2)",
    "text": "Array: esercizi (2)\nScrivere un programma che calcoli la lunghezza media delle parole di un messaggio scritto in input. Per semplicità si consideri la punteggiatura come parte di una parola.\nEsempio:\nScrivi una frase: Era solo un abbaglio.\nLunghezza media: 4.5\n\n\n\n\n\n\nConsiglio\n\n\nLa funzione getchar legge un carattere alla volta da standard input."
  },
  {
    "objectID": "lessons/02/slide.html#array-esercizi-3",
    "href": "lessons/02/slide.html#array-esercizi-3",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Array: esercizi (3)",
    "text": "Array: esercizi (3)\nScrivere un programma che legga un vettore di \\(5 \\times 5\\) interi e poi stampi la somma delle righe e delle colonne.\nEsempio:\nRiga 1: 8 3 9 0 10\nRiga 2: 3 5 17 1 1\nRiga 3: 2 8 6 23 1\nRiga 4: 15 7 3 2 9\nRiga 5: 6 14 2 6 0\nSomma righe: 30 27 40 36 28\nSomma colonne: 34 37 37 32 21"
  },
  {
    "objectID": "lessons/02/slide.html#funzioni-1",
    "href": "lessons/02/slide.html#funzioni-1",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Funzioni",
    "text": "Funzioni\nUna funzione è una associazione tra due insiemi: il dominio e il codominio: \\(f: A \\rightarrow B\\)\nIn programmazione il concetto di funzione è simile: una funzione è un blocco di codice che accetta un certo numero di argomenti e, spesso, restituisce un valore. Oltre al valore, però, una funzione può anche avere side effects, cioè modificare lo stato del programma."
  },
  {
    "objectID": "lessons/02/slide.html#funzioni-in-c",
    "href": "lessons/02/slide.html#funzioni-in-c",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Funzioni in C",
    "text": "Funzioni in C\nIn C si può pensare a una qualsiasi funzione come una scatola nera con un certo numero di ingressi e un solo output.\n\nPraticamente una funzione è un sottoprogramma, un insieme di istruzioni che esegue un compito specifico."
  },
  {
    "objectID": "lessons/02/slide.html#funzioni-sintassi",
    "href": "lessons/02/slide.html#funzioni-sintassi",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Funzioni: sintassi",
    "text": "Funzioni: sintassi\nreturn_type function_name( parameters )\n{\n    declarations\n    statements\n}\nEsempio:\ndouble average(int a, int b)\n{\n    double average;\n    average = (a + b) / 2.0;\n    return average;\n}"
  },
  {
    "objectID": "lessons/02/slide.html#funzioni-senza-valore-di-ritorno",
    "href": "lessons/02/slide.html#funzioni-senza-valore-di-ritorno",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Funzioni senza valore di ritorno",
    "text": "Funzioni senza valore di ritorno\nIl tipo di ritorno può essere void, in tal caso la funzione non restituisce alcun valore:\nvoid print_int(int a)\n{\n    printf(\"%d\\n\", a);\n    return;\n}\n\n\n\n\n\n\nNota\n\n\nL’istruzione return può essere omessa in una funzione void."
  },
  {
    "objectID": "lessons/02/slide.html#funzioni-2",
    "href": "lessons/02/slide.html#funzioni-2",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Funzioni",
    "text": "Funzioni\nAnche i parametri possono essere void oppure si possono omettere:\nvoid print_hello(void)\n{\n    printf(\"Hello, world!\\n\");\n    return;\n}"
  },
  {
    "objectID": "lessons/02/slide.html#chiamata-di-funzione",
    "href": "lessons/02/slide.html#chiamata-di-funzione",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Chiamata di funzione",
    "text": "Chiamata di funzione\nLe funzioni dichiarate precedentemente nel programma possono essere eseguite in blocchi di codice successivi.\nOgni chiamata di funzione è una espressione, e viene valutata con il suo valore di ritorno."
  },
  {
    "objectID": "lessons/02/slide.html#dichiarazione-e-definizione",
    "href": "lessons/02/slide.html#dichiarazione-e-definizione",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Dichiarazione e definizione",
    "text": "Dichiarazione e definizione\nLe funzioni possono essere dichiarate e definite in due momenti diversi del programma.\nLa dichiarazione di una funzione è una promessa che il programmatore fa al compilatore: “presto ti dirò cosa fa questa funzione”.\nLa chiamata di funzione può avvenire prima della definizione, ma solo dopo la dichiarazione.\nLa sintassi della dichiarazione è la stessa della definizione, ma senza il corpo della funzione:\nreturn_type function_name( parameters );"
  },
  {
    "objectID": "lessons/02/slide.html#dichiarazione-e-definizione-1",
    "href": "lessons/02/slide.html#dichiarazione-e-definizione-1",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Dichiarazione e definizione",
    "text": "Dichiarazione e definizione\nEsempio:\n#include &lt;stdio.h&gt;\n\nint sum(int a, int b); // dichiarazione\n\nint main(void)\n{\n    int x = 3, y = 4;\n    int z = sum(x, y);\n    printf(\"La somma di %d e %d è %d\\n\", x, y, z);\n    return 0;\n}\n\nint sum(int a, int b) // definizione\n{\n    return a + b;\n}"
  },
  {
    "objectID": "lessons/02/slide.html#argomenti-di-funzione",
    "href": "lessons/02/slide.html#argomenti-di-funzione",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Argomenti di funzione",
    "text": "Argomenti di funzione\nLe funzioni possono accettare un numero arbitrario di argomenti, ma è meglio limitare il numero di argomenti per mantenere la leggibilità del codice.\nGli argomenti possono anche essere degli array, mentre il tipo di ritorno no.\nSe si passa un array come argomento, si può omettere la sua dimensione, ma in tal caso non sarà possibile conoscere la dimensione dell’array all’interno della funzione, per questo spesso si passa anche la dimensione dell’array come argomento."
  },
  {
    "objectID": "lessons/02/slide.html#argomenti-di-funzione-1",
    "href": "lessons/02/slide.html#argomenti-di-funzione-1",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Argomenti di funzione",
    "text": "Argomenti di funzione\nIl passaggio degli argomenti può avvenire in due modi:\n\nper valore (by value): il valore dell’argomento viene copiato nella funzione\nper riferimento (by reference): viene passato l’indirizzo di memoria dell’argomento\n\nint increment(int a) { // passaggio per valore\n    a++;\n    return a; // a è una copia dell'argomento\n}\n\n// il vettore a è passato per riferimento\nvoid square(int a[], int dim) {\n    for (int i = 0; i &lt; dim; i++) {\n        a[i] *= a[i];\n    }\n    return;\n}"
  },
  {
    "objectID": "lessons/02/slide.html#ricorsione",
    "href": "lessons/02/slide.html#ricorsione",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Ricorsione",
    "text": "Ricorsione\nUna funzione che invoca se stessa è detta ricorsiva.\nint factorial(int n) {\n    if (n == 0)\n        return 1;\n    return n * factorial(n - 1);\n}"
  },
  {
    "objectID": "lessons/02/slide.html#esercizi",
    "href": "lessons/02/slide.html#esercizi",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Esercizi",
    "text": "Esercizi\n\nScrivere una funzione che trovi il valore minimo in un array di numeri interi la firma della funzione è int array_min(int arr[], int size).\nScrivere una funzione ricorsiva per sommare gli elementi di un array di double, la firma della funzione è double array_sum(double arr[], int size).\nScrivere una funzione ricorsiva che, dato un array di caratteri, ne stampi il contenuto su standard output. La firma della funzione è void print_string(char arr[], int size).\nModificare la soluzione dell’esercizio precedente per stampare l’array in ordine inverso. Implementare poi una soluzione non ricorsiva allo stesso problema.\nScrivere una funzione ricorsiva all che, dato un array di interi, restituisca true se tutti gli elementi dell’array sono diversi da 0, false altrimenti."
  },
  {
    "objectID": "lessons/02/slide.html#riassunto",
    "href": "lessons/02/slide.html#riassunto",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Riassunto",
    "text": "Riassunto\nIn questa lezione sono state introdotti molti elementi, di seguito un elenco che ripercorre i concetti affrontati:\n\ntipi di dato (int, float, char, double);\nespressioni booleane:\n\ntrue e false sono in realtà 1 e 0;\noperatori logici;\n\noperatori;\ncontrol flow (if, switch, while, do-while, for);\narray:\n\ninizializzazione degli array;\narray multidimensionali;\n\nfunzioni: sintassi e ricorsione;\n\n\n\n\n\nDati e Algoritmi"
  },
  {
    "objectID": "lessons/02/index.html",
    "href": "lessons/02/index.html",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "",
    "text": "Tenendo a mente l’architettura di Von Neumann per i calcolatori, si può riassumere che i computer hanno bisogno di 2 principali elementi: dati e istruzioni per manipolare i dati. I linguaggi di programmazione forniscono in maniera trasparente queste componenti attraverso l’uso di variabili ed espressioni.\nLe espressioni sono un insieme di:",
    "crumbs": [
      "Lezioni",
      "Strutture di controllo, tipi di base, funzioni e array"
    ]
  },
  {
    "objectID": "lessons/02/index.html#tipi-numerici-2",
    "href": "lessons/02/index.html#tipi-numerici-2",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Tipi numerici",
    "text": "Tipi numerici\nI vari tipi di interi e tipi di virgola mobile si distinguono per il numero di byte usati per la loro rappresentazione in memoria e, conseguentemente, per il range di valori che possono rappresentare.\nLa dimensione di un tipo di dato, espressa in byte, e il suo range di valori dipendono dal compilatore e dall’architettura del computer. Per determinare la dimensione di un tipo di dato si può utilizzare l’operatore sizeof, mentre per conoscere il range di valori utilizzabili si possono sfruttare le librerie limits.h (per i tipi interi) e float.h (per i tipi di virgola mobile).\n#include &lt;limits.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    printf(\"size of short: %lu\\n\", sizeof(short));\n    printf(\"size of int: %lu\\n\", sizeof(int));\n    printf(\"size of double: %lu\\n\", sizeof(double));\n    printf(\"INT_MAX = %d\\n\", INT_MAX);\n    printf(\"INT_MIN = %d\\n\", INT_MIN);\n    printf(\"UINT_MAX = %u\\n\", UINT_MAX);\n    printf(\"LONG_MAX = %ld\\n\", LONG_MAX);\n    printf(\"LONG_MIN = %ld\\n\", LONG_MIN);\n    printf(\"ULONG_MAX = %lu\\n\", ULONG_MAX);\n    printf(\"SHRT_MAX = %d\\n\", SHRT_MAX);\n    printf(\"SHRT_MIN = %d\\n\", SHRT_MIN);\n    printf(\"USHRT_MAX = %u\\n\", USHRT_MAX);\n}\n\nL’esempio precedente illustra come ottenere informazioni su dimensione e range di alcuni tipi numerici in C. È importante notare come la gestione attenta di questi aspetti possa prevenire errori di overflow e underflow.",
    "crumbs": [
      "Lezioni",
      "Strutture di controllo, tipi di base, funzioni e array"
    ]
  },
  {
    "objectID": "lessons/02/index.html#tipi-char-1",
    "href": "lessons/02/index.html#tipi-char-1",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Tipi char",
    "text": "Tipi char\nIl tipo char è usato per rappresentare singoli caratteri. In C, i caratteri sono trattati come piccoli interi, consentendo di eseguire operazioni aritmetiche su di loro grazie alla codifica ASCII.\nEsempio di dichiarazione:\nchar lettera = 'A';\nè essenziale usare gli apici singoli (’ ’) per denotare i valori di tipo char, distinguendoli dalle stringhe, che sono rappresentate tra virgolette doppie (” “).\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    char lettera_minuscola = 'a';\n    char lettera_maiuscola = lettera_minuscola - 32;\n    printf(\"La lettera maiuscola corrispondente è: %c\\n\", lettera_maiuscola);\n    return 0;\n}\nQuesto frammento di codice dimostra la conversione di una lettera minuscola in maiuscola sfruttando la differenza costante nei valori ASCII.\n\n\n\n\n\n\nTabella ASCII\n\n\n\nNella tabella ASCII, i valori dei caratteri alfabetici maiuscoli sono minori di quelli dei corrispondenti caratteri minuscoli, per trovare la distanza tra i due valori basta effettuare l’operazione 'A' - 'a'. Questo valore è costante e può essere usato per convertire una lettera minuscola in maiuscola e viceversa. Per maggiori dettagli si veda la tabella ASCII alla pagina del manuale linux man ascii.",
    "crumbs": [
      "Lezioni",
      "Strutture di controllo, tipi di base, funzioni e array"
    ]
  },
  {
    "objectID": "lessons/02/index.html#conversioni-tra-tipi-1",
    "href": "lessons/02/index.html#conversioni-tra-tipi-1",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Conversioni tra tipi",
    "text": "Conversioni tra tipi\nIn generale, per effettuare operazioni aritmetiche tra due numeri, questi devono essere dello stesso tipo.\nIn C è possibile mescolare tipi diversi nella stessa espressione, e il compilatore effettuerà automaticamente le conversioni necessarie per eseguire l’operazione richiesta.\n\nConversioni implicite\nint a = 5;\nfloat b = 1.618;\n\na + b; // 6.618\nIn questo esempio, il valore intero a viene convertito implicitamente in virgola mobile prima di eseguire l’operazione di somma. Questo tipo di conversione è chiamato “promotion”.\nSe assegno un valore a una variabile di tipo diverso, il compilatore effettuerà una conversione implicita.\nint i = 1;\nfloat f;\nf = i; // 1.0\nf = 2; // 2.0\nÈ vero quindi anche il contrario:\nfloat f = 1.618;\nint i;\ni = f; // 3\nIn questo caso, il valore in virgola mobile viene troncato al valore intero più vicino, si noti che non viene effettuato alcun arrotondamento.\n\n\nCast espliciti\nÈ possibile convertire esplicitamente il tipo di un’ espressione con l’operazione di casting:\n(nome_tipo) espressione\nIl risultato dell’espressione viene convertito al tipo specificato.\nUn caso frequente è quando si esegue una divisione tra due interi:\nfloat quotient;\nint dividend, divisor;\nquotient = (float) dividend / divisor;\n\n\n\n\n\n\nNota\n\n\n\nIn questo caso, dividend viene convertito in float prima di eseguire la divisione, ciò comporta che divisor venga convertito implicitamente in float, infatti, come vedremo nel paragrafo successivo, l’operatore di casting ha la precedenza su quello di divisione.",
    "crumbs": [
      "Lezioni",
      "Strutture di controllo, tipi di base, funzioni e array"
    ]
  },
  {
    "objectID": "lessons/02/index.html#tipi-di-operatori",
    "href": "lessons/02/index.html#tipi-di-operatori",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Tipi di Operatori",
    "text": "Tipi di Operatori\nGli operatori in C possono essere suddivisi in diverse categorie in base al tipo di operazioni che eseguono. Ogni operatore ha una priorità che determina l’ordine in cui viene valutato all’interno di un’espressione. Gli operatori con una priorità più alta vengono valutati prima degli operatori con una priorità più bassa. Nel caso di operatori della stessa priorità, l’associatività determina l’ordine di valutazione.\nEcco una tabella riassuntiva degli operatori C, ordinati da quelli con più alta priorità a quelli con minore priorità:\n\n\n\n\n\n\n\n\nCategoria\nOperatori\nAssociatività\n\n\n\n\nPostfissi\n++ -- -&gt; . () []\nSinistra-Destra\n\n\nUnari / Prefissi\n+ - ! ~ ++ -- (type) * & sizeof\nDestra-Sinistra\n\n\nMoltiplicativi\n* / %\nSinistra-Destra\n\n\nAdditivi\n+ -\nSinistra-Destra\n\n\nShift\n&lt;&lt; &gt;&gt;\nSinistra-Destra\n\n\nRelazionali\n&lt; &gt; &lt;= &gt;=\nSinistra-Destra\n\n\nUguaglianza\n== !=\nSinistra-Destra\n\n\nBitwise AND\n&\nSinistra-Destra\n\n\nBitwise XOR\n^\nSinistra-Destra\n\n\nBitwise OR\n|\nSinistra-Destra\n\n\nLogico AND\n&&\nSinistra-Destra\n\n\nLogico OR\n||\nSinistra-Destra\n\n\nCondizionale\n?:\nDestra-Sinistra\n\n\nAssegnamento\n= += -= *= /= %= &lt;&lt;= &gt;&gt;= &= ^= |=\nDestra-Sinistra\n\n\nVirgola\n,\nSinistra-Destra\n\n\n\nAlcuni operatori sono comuni a molti linguaggi di programmazione (additivi, moltiplicativi, relazionali, uguaglianza, …), altri però acquisiscono un significato specifico in C, come ad esempio l’operatore di dereferenziazione * o l’operatore di indirizzamento &. Nel corso di questa lezione ne approfondiremo alcuni, mentre altri verranno trattati successivamente.",
    "crumbs": [
      "Lezioni",
      "Strutture di controllo, tipi di base, funzioni e array"
    ]
  },
  {
    "objectID": "lessons/02/index.html#side-effects",
    "href": "lessons/02/index.html#side-effects",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Side-Effects",
    "text": "Side-Effects\nGli operatori di incremento e decremento (++ e --) sono potenti ma vanno usati con cautela. Possono essere utilizzati sia come operazioni prefisse che postfix. La differenza principale tra queste due forme sta nel momento in cui viene effettuata l’operazione di incremento o decremento.\nNel caso dell’operatore di post-incremento i++, l’incremento avviene dopo che il valore di i viene utilizzato nell’espressione corrente. Nel caso dell’operatore di pre-incremento ++i, l’incremento avviene prima che il valore di i venga utilizzato nell’espressione.\nQuesto può portare a comportamenti diversi, soprattutto quando si utilizzano questi operatori all’interno della stessa espressione o dello stesso statement. Ad esempio:\nint i = 1;\nprintf(\"i is %d\\n\", i++);  // Stampa: i is 1\nprintf(\"i is %d\\n\", i);    // Stampa: i is 2\nprintf(\"i is %d\\n\", ++i);  // Stampa: i is 3\nprintf(\"i is %d\\n\", i);    // Stampa: i is 3\nNel primo printf, l’operatore post-incremento viene utilizzato, quindi il valore di i (1) viene stampato e poi incrementato a 2. Nel secondo printf, il valore incrementato di i (2) viene stampato. Nel terzo printf, l’operatore pre-incremento viene utilizzato, quindi i viene incrementato a 3 e poi stampato. Infine, nel quarto printf, viene stampato di nuovo il valore corrente di i, che è 3.\nÈ importante prestare attenzione a questi comportamenti per evitare risultati inaspettati nel proprio codice.\n\n\n\n\n\n\nNota\n\n\n\nGli altri operatori di uso frequente che comportano un side effect sono quelli di assegnamento =, +=, -= e così via. Questi operatori modificano il valore della variabile a sinistra dell’operatore.",
    "crumbs": [
      "Lezioni",
      "Strutture di controllo, tipi di base, funzioni e array"
    ]
  },
  {
    "objectID": "lessons/02/index.html#espressioni-istruzione-1",
    "href": "lessons/02/index.html#espressioni-istruzione-1",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Espressioni istruzione",
    "text": "Espressioni istruzione\nTutte le espressioni possono essere anche statement: in una linea posso avere anche solo una operazione singola seguita da ;\ni = 1;      // utile\ni++;        // utile\ni * j + 2   // inutile, potrebbe dare warning\n            // \"statement with no effect\"\nNella seconda riga dell’esempio il risultato viene scartato, ma la modifica avviene lo stesso.",
    "crumbs": [
      "Lezioni",
      "Strutture di controllo, tipi di base, funzioni e array"
    ]
  },
  {
    "objectID": "lessons/02/index.html#operatori-booleani",
    "href": "lessons/02/index.html#operatori-booleani",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Operatori Booleani",
    "text": "Operatori Booleani\nEcco gli operatori booleani disponibili in C:\n\n&& (AND logico)\n|| (OR logico)\n! (NOT logico)\n== (uguaglianza)\n!= (diverso)\n&gt; (maggiore)\n&lt; (minore)\n&gt;= (maggiore o uguale)\n&lt;= (minore o uguale)\n\nQuesti operatori producono tutti 0 o 1 come risultato, ma in C qualsiasi valore diverso da 0 è considerato vero.\n\n\n\n\n\n\nAvviso\n\n\n\nÈ importante ricordarsi che gli operatori bitwise (&, |, ^, ~) non sono operatori booleani, ma operatori di manipolazione dei bit. Non vanno confusi con gli operatori booleani, pertanto non vanno utilizzati per valutare espressioni booleane.\n\n\n\nAND Logico (&&)\nL’operatore && restituisce 1 se entrambe le espressioni booleane sono non-zero, altrimenti restituisce 0. È un operatore a corto circuito, quindi se il risultato è già noto dopo aver valutato la prima espressione, la seconda non viene valutata.\n\n\nOR Logico (||)\nL’operatore || restituisce 1 se almeno una delle due espressioni booleane è non-zero, altrimenti restituisce 0. Anche questo è un operatore a corto circuito.\n\n\nNOT Logico (!)\nL’operatore ! inverte il valore di verità di un’espressione. Restituisce 1 se l’espressione è zero e 0 se l’espressione è non-zero.\n\n\nOperatori di Confronto\nGli operatori di confronto (==, !=, &gt;, &lt;, &gt;=, &lt;=) confrontano due valori e restituiscono un valore intero in base alla relazione tra di essi.\n\n\n\n\n\n\nNota\n\n\n\nMentre il risultato di questi operatori è intuitivo su degli interi o float, bisogna notare che dalla parte sinistra e destra possono esserci anche char (che in C sono rappresentati come interi da un byte), che valore restituisce l’espressione 'Z' &lt; 'a'? E ':' &lt; ';'? Suggerimento: per rispondere senza scrivere codice si provi a consultare la pagina del manuale di ascii (man ascii).",
    "crumbs": [
      "Lezioni",
      "Strutture di controllo, tipi di base, funzioni e array"
    ]
  },
  {
    "objectID": "lessons/02/index.html#valutazione-delle-espressioni-booleane",
    "href": "lessons/02/index.html#valutazione-delle-espressioni-booleane",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Valutazione delle Espressioni Booleane",
    "text": "Valutazione delle Espressioni Booleane\nLe espressioni booleane vengono valutate in base alle regole della logica booleana. Il risultato di un’espressione booleana è un valore intero, dove 0 rappresenta “falso” e 1 rappresenta “vero”. Ad esempio:\nint i = 3, j = 2, k = 1;\nint result = (i &lt; j && j &lt; k); // result sarà 0 perché entrambe le espressioni sono false\nIn questo caso, l’espressione i &lt; j && j &lt; k sarà valutata come 0 && 0, il che restituirà 0 perché entrambe le espressioni sono false.",
    "crumbs": [
      "Lezioni",
      "Strutture di controllo, tipi di base, funzioni e array"
    ]
  },
  {
    "objectID": "lessons/02/index.html#il-tipo-bool",
    "href": "lessons/02/index.html#il-tipo-bool",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Il tipo bool",
    "text": "Il tipo bool\nCome già detto, il tipo di ritorno delle espressioni logiche in C è un intero, il tipo booleano non esiste nativamente in C. Quindi, per rappresentare valori booleani, si utilizzano valori interi, dove:\n\n\\(0 \\rightarrow\\) falso\n\\(1 \\rightarrow\\) vero (e tutti gli interi diversi da \\(0\\))\n\n\n\n\n\n\n\nNota\n\n\n\nDa C99 in poi, bool è un tipo definito in stdbool.h che può assumere solo i valori true e false.\n#include &lt;stdbool.h&gt;\nbool b = true;\nSi tratta di un tipo di dato intero, ma è considerato un tipo booleano. Ciò è possibile grazie all’uso di macro definite in stdbool.h:\n// nel file stdbool.h\n#define true 1\n#define false 0\n#define bool _Bool // _Bool è un tipo di dato intero introdotto in C99",
    "crumbs": [
      "Lezioni",
      "Strutture di controllo, tipi di base, funzioni e array"
    ]
  },
  {
    "objectID": "lessons/02/index.html#if-else-1",
    "href": "lessons/02/index.html#if-else-1",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "if-else",
    "text": "if-else\nL’istruzione if-else permette di eseguire un blocco di codice solo se una condizione è vera. La sintassi è la seguente:\nif (espressione) {\n    // statements\n} else {\n    // statements\n}\nSe la condizione è vera, viene eseguito il blocco di codice immediatamente successivo all’istruzione if. Altrimenti, viene eseguito il blocco di codice immediatamente successivo all’istruzione else.\n#include &lt;stdio.h&gt;\n\nint main() {\n    int x = 10;\n\n    if (x &gt; 5) {\n        printf(\"x è maggiore di 5\\n\");\n    } else {\n        printf(\"x è minore o uguale a 5\\n\");\n    }\n\n    return 0;\n}\nIl codice stampa:\nx è maggiore di 5\n\nif-else annidati\nÈ possibile annidare più istruzioni if-else all’interno di un blocco di codice.\n#include &lt;stdio.h&gt;\n\nint main() {\n    int x = 10;\n\n    if (x &gt; 5) {\n        if (x &gt; 7) {\n            printf(\"x è maggiore di 7\\n\");\n        } else {\n            printf(\"x è minore o uguale a 7\\n\");\n        }\n    } else {\n        printf(\"x è minore o uguale a 5\\n\");\n    }\n\n    return 0;\n}\nIl codice stampa:\nx è maggiore di 7\nOppure si può usare l’istruzione else if per evitare l’annidamento.\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    int x = 10;\n    if (x &gt; 7)\n    {\n        printf(\"x è maggiore di 7\\n\");\n    }\n    else if (x &gt; 5)\n    {\n        printf(\"x è maggiore di 5\\n\");\n    }\n    else\n    {\n        printf(\"x è minore o uguale a 5\\n\");\n    }\n}\n\nQuesta versione stampa lo stesso risultato della precedente, in questo caso però, il secondo if è allineato con il primo else, rendendo il codice più leggibile.\n\n\n\n\n\n\nAttenzione\n\n\n\nUn errore comune è confondere l’operatore di assegnamento = con l’operatore di confronto ==. Ad esempio, l’espressione x = 10 assegna il valore 10 alla variabile x, mentre l’espressione x == 10 confronta il valore della variabile x con 10. Se si scrive if (x = 10), l’espressione è sempre vera, perché assegna 10 alla variabile x e restituisce 10, che è considerato true. Per confrontare il valore della variabile x con 10, si deve invece scrivere if (x == 10).",
    "crumbs": [
      "Lezioni",
      "Strutture di controllo, tipi di base, funzioni e array"
    ]
  },
  {
    "objectID": "lessons/02/index.html#if-ternario-2",
    "href": "lessons/02/index.html#if-ternario-2",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "If ternario",
    "text": "If ternario\nL’if ternario è una forma compatta dell’istruzione if-else. La sintassi è la seguente:\nespressione ? valore_se_vera : valore_se_falsa\nSe l’espressione è vera, viene restituito valore_se_vera, altrimenti viene restituito valore_se_falsa.\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    int x = 10;\n    int y = (x &gt; 5) ? 1 : 0;\n\n    printf(\"y = %d\\n\", y);\n}\n\nQuesto modo di scrivere l’istruzione if-else è utile quando si vuole assegnare un valore a una variabile in base a una condizione con una sola riga di codice. Tuttavia, se l’espressione è complessa, l’uso dell’if ternario può rendere il codice meno leggibile. In questi casi si sconsiglia di utilizzarlo e si preferisce l’istruzione if-else standard.",
    "crumbs": [
      "Lezioni",
      "Strutture di controllo, tipi di base, funzioni e array"
    ]
  },
  {
    "objectID": "lessons/02/index.html#switch-1",
    "href": "lessons/02/index.html#switch-1",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "switch",
    "text": "switch\nTanti if in cascata potrebbero essere sostituiti da uno switch. La sintassi è la seguente:\nswitch (espressione) {\n    case constant-expression:\n        // statements\n        break;\n    case constant-expression:\n        // statements\n        break;\n    // ...\n    default:\n        // statements\n}\nL’espressione a fianco dell’istruzione case è senza variabili o chiamate a funzioni. L’istruzione break è necessaria per terminare il blocco di codice. Se non è presente, il controllo del flusso di esecuzione continua con il blocco di codice successivo. L’istruzione default è opzionale e viene eseguita se nessuna delle costanti corrisponde all’espressione.\nUn esempio di utilizzo dello switch è il seguente:\n#include &lt;stdio.h&gt;\n\nint main() {\n    int x = 2;\n\n    switch (x) {\n        case 1:\n            printf(\"x è 1\\n\");\n            break;\n        case 2:\n            printf(\"x è 2\\n\");\n            break;\n        default:\n            printf(\"x non è nè 1 nè 2\\n\");\n    }\n\n    return 0;\n}\n\n\n\n\n\n\nImportante\n\n\n\nLo switch può essere utilizzato solo con espressioni di tipo intero (int, char, short, long, ecc.) e con espressioni di tipo enum (che verrà trattato in seguito).",
    "crumbs": [
      "Lezioni",
      "Strutture di controllo, tipi di base, funzioni e array"
    ]
  },
  {
    "objectID": "lessons/02/index.html#cicli-3",
    "href": "lessons/02/index.html#cicli-3",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Cicli",
    "text": "Cicli\nCaratteristica fondamentale di un linguaggio di programmazione sono i cicli. C implementa i classici for, while, ma anche do…while\n\nwhile (expression) { statements }\ndo { statements } while (expression)\nfor (initialization; condition; increment) { statements }\n\nQueste while e for sono equivalenti: tutto ciò che si può fare con un ciclo for si può fare con un ciclo while e viceversa. La scelta di quale istruzione utilizzare dipende dal contesto e dalla preferenza personale.\nL’istruzione do-while è simile a while, ma la condizione viene valutata alla fine del blocco di codice. Questo significa che il blocco di codice viene eseguito almeno una volta, anche se la condizione è falsa.\n\n\n\n\n\n\nNota\n\n\n\nDal C99 è possibile dichiarare variabili all’interno del ciclo for. Queste variabili sono visibili solo all’interno del ciclo. In C89 e nelle versioni precedenti, le variabili devono essere dichiarate all’inizio del blocco di codice.\nfor (int i = 0; i &lt; 10; i++) {\n    // ...\n}\n\n\n\nCicli infiniti\nUn ciclo infinito è un ciclo che non termina mai. Un ciclo infinito può essere creato utilizzando un’istruzione while con una condizione sempre vera, ad esempio while (1), oppure utilizzando un’istruzione for senza condizione, ad esempio for (;;). Un ciclo infinito può essere interrotto con un’istruzione break.\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    int i = 0;\n    while (1)\n    {\n        printf(\"%d\\n\", i);\n        i++;\n        if (i == 10)\n            break;\n    }\n}\n\n\n\nbreak e continue\nL’istruzione break termina immediatamente il ciclo in cui si trova. L’istruzione continue termina l’iterazione corrente del ciclo e passa alla successiva. Entrambe le istruzioni possono essere utilizzate all’interno di cicli for, while e do-while. L’istruzione break può essere utilizzata anche all’interno di un blocco switch per terminare immediatamente l’esecuzione del blocco.\n\n\n\n\n\n\nAvviso\n\n\n\nÈ bene non abusare di break e continue, perché possono rendere il codice meno leggibile. In generale, è meglio evitare di utilizzare break e `continue all’interno di cicli annidati.",
    "crumbs": [
      "Lezioni",
      "Strutture di controllo, tipi di base, funzioni e array"
    ]
  },
  {
    "objectID": "lessons/02/index.html#inizializzazione",
    "href": "lessons/02/index.html#inizializzazione",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Inizializzazione",
    "text": "Inizializzazione\nUn array può essere inizializzato al momento della dichiarazione:\nint a[5] = {1, 2, 3, 4, 5};\nSe si mettono meno numeri, i restanti elementi vengono inizializzati a 0 (ma questo non succede se non ne specifico nessuno!):\nint a[5] = {1, 2, 3}; // a = {1, 2, 3, 0, 0}\nint b[4] = {0}; // b = {0, 0, 0, 0}\nSe metto più elementi di quelli dichiarati il compilatore segnala un errore. Se invece si omette la dimensione dell’array, il compilatore la calcola automaticamente dalla lista di initializzazione:\nint a[] = {1, 2, 3}; // a ha dimensione 3",
    "crumbs": [
      "Lezioni",
      "Strutture di controllo, tipi di base, funzioni e array"
    ]
  },
  {
    "objectID": "lessons/02/index.html#dimensione-di-un-array-1",
    "href": "lessons/02/index.html#dimensione-di-un-array-1",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Dimensione di un array",
    "text": "Dimensione di un array\nIn C non esiste un sistema per ottenere senza sforzo la dimensione di un array, per questo, spesso, si utilizza una variabile per memorizzare la dimensione dell’array.\nTuttavia si può usare sizeof per ottenere la dimensione di un array:\nint a[10];\nsizeof(a); /* restituisce 40 su una macchina a 32 bit */\nsizeof(a[0]); /* 4 */\nsizeof(a)/sizeof(a[0]); /* 10, la dimensione dell'array */",
    "crumbs": [
      "Lezioni",
      "Strutture di controllo, tipi di base, funzioni e array"
    ]
  },
  {
    "objectID": "lessons/02/index.html#array-multidimensionali-2",
    "href": "lessons/02/index.html#array-multidimensionali-2",
    "title": "Strutture di controllo, tipi di base, funzioni e array",
    "section": "Array multidimensionali",
    "text": "Array multidimensionali\nUn array può contenere elementi di qualsiasi tipo, anche altri array! Per dichiarare un array multidimensionale si specifica il numero di elementi per ogni dimensione:\nint matrix[5][9];\nPer accedere a un elemento di un array multidimensionale si usano più indici:\nmatrix[1][5] = 42; e NON matrix[1,5] = 42;",
    "crumbs": [
      "Lezioni",
      "Strutture di controllo, tipi di base, funzioni e array"
    ]
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Risorse",
    "section": "",
    "text": "Questa sezione è dedicata a risorse che possono essere utili da consultare per avere dei riferimenti ma non è necessario studiarle.\nIn particolare ci sono:\n\nuna sezione dedicata ai libri di testo in cui si può consultare una lista di letture suggerite oltre ad avere informazioni sul libro di testo ufficiale del corso;\nuna guida alla scrittura di codice chiaro in C, non è un requisito del corso scrivere seguendo questi criteri, è comunque consigliato applicare delle regole di formattazione per scrivere codice chiaro e coerente;\nuna sezione dedicata a domande e risposte frequenti in cui, in particolare, vengono descritte le modalità d’esame.",
    "crumbs": [
      "Lezioni",
      "Risorse"
    ]
  },
  {
    "objectID": "exercises/01/somma_interi.html",
    "href": "exercises/01/somma_interi.html",
    "title": "Esercizio: somma di interi",
    "section": "",
    "text": "Si vuole scrivere un programma che accetti in input due numeri interi e ne calcoli la somma. Il programma deve chiedere all’utente di inserire i due numeri, effettuare il calcolo e visualizzare il risultato a video.\nAd esempio:\nInserisci il primo numero: 5\nInserisci il secondo numero: 7\nLa somma dei due numeri è 12\nUna volta compilato il programma eseguilo con gdb e controlla il valore delle variabili prima e dopo l’assegnamento. Cosa noti?\n\n\n\n\n\n\nGNU Debugger\n\n\n\nPer eseguire un programma con gdb è sufficiente digitare il comando gdb nome_programma da terminale. Una volta avviato il debugger è possibile aggiungere breakpoints con il comando break nome_funzione o break numero_riga. A questo punto è possibile eseguire il programma con il comando run e controllare il valore delle variabili con il comando print nome_variabile. Per andare avanti di un passo è possibile usare il comando next o step. Per uscire dal debugger è sufficiente digitare quit.",
    "crumbs": [
      "Lezioni",
      "Basi di C",
      "Somma di interi"
    ]
  },
  {
    "objectID": "exercises/01/libretto.html",
    "href": "exercises/01/libretto.html",
    "title": "Esercizio: il libretto degli esami",
    "section": "",
    "text": "Si vuole scrivere un programma che, dati in input i voti di più esami e i relativi crediti, calcoli la media ponderata dei voti e la visualizzi a video.\n\n\n\n\n\n\nSi assume che gli esami siano 3: algebra lineare, analisi matematica e introduzione alla programmazione (java).\n\n\n\nQuando il programma viene eseguito deve chiedere all’utente di inserire il voto di un certo esame e il relativo numero di crediti associato. Una volta inseriti tutti i voti e i crediti, il programma deve calcolare la media ponderata e visualizzarla a video.\nOpzionale:\n\nProvare a visualizzare anche la media aritmetica dei voti;\nVisualizzare anche l’elenco dei voti e dei crediti inseriti.\nProva a stampare il voto con 2 cifre decimali, ad esempio 27.11 (per fare questo bisogna cambiare il tipo di dato usato per memorizzare la media e usare il type casting durante la divisione).\n\n\n\n\n\n\n\nSuggerimento\n\n\n\nLa media ponderata si calcola come la somma dei prodotti tra ciascun voto e i relativi crediti, diviso la somma dei crediti. Formalmente:\n\\[\n\\text{media} = \\frac{\\sum_{i=1}^{n} voto_i \\cdot crediti_i}{\\sum_{i=1}^{n} crediti_i}\n\\] dove \\(voto_i\\) è il voto dell’esame \\(i\\)-esimo e \\(crediti_i\\) è il numero di crediti dell’esame \\(i\\)-esimo.\nAd esempio, se si hanno tre esami con voti 30, 28 e 25 e i rispettivi crediti sono 6, 9 e 12, la media ponderata è: \\[\n\\frac{30 \\cdot 6 + 28 \\cdot 9 + 25 \\cdot 12}{6 + 9 + 12} = \\frac{180 + 252 + 300}{27} = \\frac{732}{27} \\approx 27.11\n\\]\n\n\nEsempio di main:\n\n\n Scarica il file \n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    int voto_analisi1, voto_algebra_lineare, voto_java;\n    int crediti_analisi1, crediti_algebra_lineare, crediti_java;\n    int media_ponderata;\n\n    // TODO: Chiedere all'utente i voti e i crediti dei tre esami\n\n    // TODO: Calcolare la media ponderata\n\n    printf(\"La media ponderata è: %d\\n\", media_ponderata);\n}",
    "crumbs": [
      "Lezioni",
      "Basi di C",
      "Libretto universitario"
    ]
  },
  {
    "objectID": "exercises/02/word_average.html",
    "href": "exercises/02/word_average.html",
    "title": "Esercizio: lunghezza media delle parole",
    "section": "",
    "text": "Si vuole scrivere un programma che calcoli la lunghezza media delle parole di un messaggio scritto in input.\n\nIl programma deve leggere una sequenza di caratteri da tastiera e calcolare la lunghezza media delle parole presenti nel messaggio. Si considera una parola una sequenza di caratteri separata da spazi, tabulazioni o a capo.\nUn’esecuzione del programma potrebbe essere la seguente:\n$ ./lunghezza_media\nScrivi una frase: Era solo un abbaglio.\nLunghezza media: 4.5\n\n\n\n\n\n\nSuggerimento\n\n\n\nLa funzione getchar legge un carattere alla volta da standard input. Ad esempio:\nchar c = getchar(); // legge un carattere da stdin\n// oppure\nwhile ((c = getchar()) != '\\n') {\n    // legge caratteri fino a quando\n    // non viene premuto il tasto enter\n}",
    "crumbs": [
      "Lezioni",
      "Array e funzioni",
      "Lunghezza media delle parole"
    ]
  },
  {
    "objectID": "exercises/02/fizzbuzz.html",
    "href": "exercises/02/fizzbuzz.html",
    "title": "Esercizio: FizzBuzz",
    "section": "",
    "text": "Si vuole scrivere un programma che stampi i numeri da 1 a 100, ma per i multipli di 3 stampi “Fizz” e per i multipli di 5 stampi “Buzz”. Per i numeri che sono sia multipli di 3 che di 5 stampi “FizzBuzz”.\n\nUn’esecuzione del programma potrebbe essere la seguente:\n$ ./fizzbuzz\n1\n2\nFizz\n4\nBuzz\nFizz\n7\n8\nFizz\nBuzz\n11\nFizz\n13\n14\nFizzBuzz\n...\n\n\n\n\n\n\nSuggerimento\n\n\n\nL’operatore modulo % restituisce il resto della divisione tra due numeri. Ad esempio, 5 % 3 restituisce 2, perché 5 diviso 3 dà 1 con un resto di 2.",
    "crumbs": [
      "Lezioni",
      "Espressioni e strutture di controllo",
      "FizzBuzz"
    ]
  },
  {
    "objectID": "exercises/02/lista_della_spesa.html",
    "href": "exercises/02/lista_della_spesa.html",
    "title": "Esercizio: la lista della spesa",
    "section": "",
    "text": "Si vuole scrivere un programma per calcolare il prezzo del carrello di una spesa. Data una lista della merce acquistabile, il cui prezzo al chilo è noto, scrivere un programma che chiede all’utente quale e quanta merce voglia comprare. Se l’utente inserisce il codice -1, il programma stampa il costo totale del carrello e termina.\n\nAll’avvio il programma stampa una lista della merce disponibile e l’id:\n1) Pomodoro\n2) Pasta\n3) Biscotti\n4) Banane\n5) Pane\nAll’utente viene chiesto di inserire l’id della merce che vuole comprare e il peso in chilogrammi. L’interazione continua fino a che l’utente non inserisce il valore -1 per l’id. A quel punto il programma stampa il costo totale della merce nel carrello e termina come nell’esempio:\nSelezionare prodotto: -1\nSpecificare quantità (in kg): 0  // in questo caso non importa il numero inserito\nTotale: 12.00\nOpzionale:\n\nstampare ad ogni iterazione il costo attuale del carrello;\nverificare che la quantità inserita non sia negativa o pari a zero e gestire i casi;\n\n\n\n\n\n\n\nSuggerimento\n\n\n\nSolitamente, quando si tratta di ripetere un’azione fino al verificarsi di un determinato evento senza sapere il momento in cui questo avverrà, si usa l’istruzione while. Se si manipolano delle variabili a ogni ciclo bisogna stare molto attenti a quando queste vengono lette e inizializzate.\n\n\nEsempio di main:\n\n\n Scarica il file \n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    // prezzo al kg dei prodotti disponibili\n    float prezzo_pomodoro = 2.5f;\n    float prezzo_pasta = 1.5f;\n    float prezzo_biscotti = 3.0f;\n    float prezzo_banane = 1.0f;\n    float prezzo_pane = 2.0f;\n\n    // TODO:\n    //     1) chiedere in input quale prodotto si vuole comprare e la quantità in chilogrammi\n    //     2) quando si seleziona il prodotto -1 stampa il costo totale e termina\n    //     3) altrimenti aggiungi il costo della merce acquistata al totale\n}",
    "crumbs": [
      "Lezioni",
      "Espressioni e strutture di controllo",
      "Lista della spesa"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hello C 2024",
    "section": "",
    "text": "Materiali in continuo aggiornamento\n\n\n\nIl contenuto del sito non è ancora definitivo, potrebbe cambiare di frequente. Per piacere siate pazienti.\n\n\nDispense per l’introdottozione al linguaggio di programmazione C. Questa è la pagina web della parte di programmazione in C del corso di dati e algoritmi per la laurea triennale in ingegneria elettronica presso l’Università di Padova.\n\nQuesto sito\nIl sito è organizzato per 3 macro aree:\n\nlezioni\nesercizi\nrisorse\n\nLa sezione lezioni raccoglie tutti i contenuti presentati a lezione, ogni lezione è riportata in formato html e pdf, inoltre è possibile consultare anche le diapositive viste a lezione in formato RevealJS. Oltre ai contenuti visti in classe sono presenti, saltuariamente, brevi guide sull’utilizzo/installazione di software o approfondimenti.\nLa sezione esercizi raccoglie molti esercizi per ripassare gli argomenti visti in classe e prepararsi all’esame, in generale vi sono esercizi di varia difficoltà.\nLa sezione risorse contiene materiali vari: una lista di letture consigliate sul linguaggio C oltre al libro di testo del corso, un elenco di materiali didattici reperibili online, domande e risposte comuni sull’esame, una guida sull’installazione dell’ambiente di sviluppo per scrivere programmi C."
  }
]