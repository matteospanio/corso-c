[
  {
    "objectID": "exercises/02/power.html",
    "href": "exercises/02/power.html",
    "title": "Esercizio: elevamento a potenza",
    "section": "",
    "text": "Si vuole scrivere un programma che accetti in input due numeri interi \\(x\\) e \\(y\\) e stampi il risultato dell’operazione \\(x^y\\).\n\nQuando il programma viene eseguito deve chiedere all’utente di inserire due numeri interi \\(x\\) e \\(y\\) e stampare il risultato dell’operazione \\(x^y\\) in un loop infinito. L’esecuzione termina quando l’utente inserisce due zeri.\nAd esempio:\nInserisci due numeri interi: 2 3\n2^3 = 8\nInserisci due numeri interi: 3 2\n3^2 = 9\nInserisci due numeri interi: 4 5\n4^5 = 1024\n...\nInserisci due numeri interi: 0 0\nBye!\nPer semplicità si può assumere che \\(x, y \\in \\mathbb{N}\\) (siano sempre maggiori o uguali a zero).\nOpzionale:\n\nampliare il dominio dell’input a \\(x, y \\in \\mathbb{Z}\\) (l’input può contenere anche numeri negativi);\n\n\n\n\n\n\n\nSuggerimento\n\n\n\n\n\nIn C non esiste un operatore per l’elevamento a potenza. Tuttavia, possiamo calcolare \\(x^y\\) come \\(x \\cdot x \\cdot \\ldots \\cdot x\\) (con \\(y\\) fattori) utilizzando un ciclo for.\n\n\n\n\n\n\n\n\n\nSoluzione\n\n\n\n\n\nse \\(x, y \\in \\mathbb{N}\\)\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    int base, exp, result;\n\n    do\n    {\n        // inizializza result a 1\n        result = 1;\n\n        // ricevi l'input dall'utente\n        printf(\"Inserisci due numeri interi: \");\n        scanf(\"%d %d\", &base, &exp);\n\n        // se l'input non è 0 0\n        if (base != 0 || exp != 0)\n        {\n            // calcola base^exp = base * base * ...\n            for (int i = 0; i &lt; exp; i++)\n            {\n                result *= base;\n            }\n            printf(\"%d^%d = %d\\n\", base, exp, result);\n        }\n    } while (base != 0 || exp != 0);\n}\nse \\(x, y \\in \\mathbb{Z}\\)\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    int base, exp;\n    float result;\n\n    do\n    {\n        result = 1.0;\n\n        printf(\"Inserisci due numeri interi: \");\n        scanf(\"%d %d\", &base, &exp);\n\n        if (base != 0 || exp != 0)\n        {\n            if (exp &lt; 0)\n            {\n                for (int i = 0; i &gt; exp; i--)\n                {\n                    result /= base;\n                }\n            }\n            else\n            {\n                for (int i = 0; i &lt; exp; i++)\n                {\n                    result *= base;\n                }\n            }\n            printf(\"%d^%d = %.3f\\n\", base, exp, result);\n        }\n    } while (base != 0 || exp != 0);\n}",
    "crumbs": [
      "Lezioni",
      "Espressioni e strutture di controllo",
      "Elevamento a potenza"
    ]
  },
  {
    "objectID": "exercises/02/lista_della_spesa.html",
    "href": "exercises/02/lista_della_spesa.html",
    "title": "Esercizio: la lista della spesa",
    "section": "",
    "text": "Si vuole scrivere un programma per calcolare il prezzo del carrello di una spesa. Data una lista della merce acquistabile, il cui prezzo al chilo è noto, scrivere un programma che chiede all’utente quale e quanta merce voglia comprare. Se l’utente inserisce il codice -1, il programma stampa il costo totale del carrello e termina.\n\nAll’avvio il programma stampa una lista della merce disponibile e l’id:\n1) Pomodoro\n2) Pasta\n3) Biscotti\n4) Banane\n5) Pane\nAll’utente viene chiesto di inserire l’id della merce che vuole comprare e il peso in chilogrammi. L’interazione continua fino a che l’utente non inserisce il valore -1 per l’id. A quel punto il programma stampa il costo totale della merce nel carrello e termina come nell’esempio:\nSelezionare prodotto: -1\nSpecificare quantità (in kg): 0  // in questo caso non importa il numero inserito\nTotale: 12.00\nOpzionale:\n\nstampare ad ogni iterazione il costo attuale del carrello;\nverificare che la quantità inserita non sia negativa o pari a zero e gestire i casi;\n\n\n\n\n\n\n\nSuggerimento\n\n\n\nSolitamente, quando si tratta di ripetere un’azione fino al verificarsi di un determinato evento senza sapere il momento in cui questo avverrà, si usa l’istruzione while. Se si manipolano delle variabili a ogni ciclo bisogna stare molto attenti a quando queste vengono lette e inizializzate.\n\n\nEsempio di main:\n\n\n Scarica il file \n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    // prezzo al kg dei prodotti disponibili\n    float prezzo_pomodoro = 2.5f;\n    float prezzo_pasta = 1.5f;\n    float prezzo_biscotti = 3.0f;\n    float prezzo_banane = 1.0f;\n    float prezzo_pane = 2.0f;\n\n    // TODO:\n    //     1) chiedere in input quale prodotto si vuole comprare e la quantità in chilogrammi\n    //     2) quando si seleziona il prodotto -1 stampa il costo totale e termina\n    //     3) altrimenti aggiungi il costo della merce acquistata al totale\n}\n\n\n\n\n\n\nSoluzione\n\n\n\n\n\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    // prezzo al kg dei prodotti disponibili\n    float prezzo_pomodoro = 2.5f;\n    float prezzo_pasta = 1.5f;\n    float prezzo_biscotti = 3.0f;\n    float prezzo_banane = 1.0f;\n    float prezzo_pane = 2.0f;\n\n    int prodotto = 0;     // creo la variabile per selezionare il prodotto\n    float totale = 0;     // creo la variabile che contiene il costo totale\n    float peso, parziale; // creo la variabile per la quantità e una variabile temp\n\n    /*\n    Osservazioni:\n    1. Prodotto va inizializzato perché si fa subito un controllo, nel caso si fosse\n    usato un do while non sarebbe stato necessario.\n    2. peso e parziale non serve che vengano inizializzati perché gli viene assegnato\n    un valore prima di qualsiasi lettura.\n    */\n\n    while (-1 != prodotto)\n    {\n        printf(\"Inserisci il prodotto (-1 per terminare):\\n\");\n        printf(\"1) Pomodoro\\n\");\n        printf(\"2) Pasta\\n\");\n        printf(\"3) Biscotti\\n\");\n        printf(\"4) Banane\\n\");\n        printf(\"5) Pane\\n\\n\");\n        printf(\"Selezionare id prodotto: \");\n        scanf(\"%d\", &prodotto);\n        printf(\"Specificare quantità (in kg): \");\n        scanf(\"%f\", &peso);\n\n        // se il peso è 0 o negativo seleziono il prodotto nullo\n        if (0 &gt;= peso)\n            prodotto = 0;\n\n        switch (prodotto)\n        {\n        case 1:\n            parziale = prezzo_pomodoro;\n            break;\n        case 2:\n            parziale = prezzo_pasta;\n            break;\n        case 3:\n            parziale = prezzo_biscotti;\n            break;\n        case 4:\n            parziale = prezzo_banane;\n            break;\n        case 5:\n            parziale = prezzo_pane;\n            break;\n        default:\n            // il prodotto nullo ha id 0, così, se è stato impostato un peso valido,\n            // il costo aggiunto nell'operazione successiva è comunque 0.\n            parziale = 0;\n            break;\n        }\n        totale += (parziale * peso);\n    }\n    printf(\"Totale: %.2f\\n\", totale);\n}",
    "crumbs": [
      "Lezioni",
      "Espressioni e strutture di controllo",
      "Lista della spesa"
    ]
  },
  {
    "objectID": "exercises/02/fizzbuzz.html",
    "href": "exercises/02/fizzbuzz.html",
    "title": "Esercizio: FizzBuzz",
    "section": "",
    "text": "Si vuole scrivere un programma che stampi i numeri da 1 a 100, ma per i multipli di 3 stampi “Fizz” e per i multipli di 5 stampi “Buzz”. Per i numeri che sono sia multipli di 3 che di 5 stampi “FizzBuzz”.\n\nUn’esecuzione del programma potrebbe essere la seguente:\n$ ./fizzbuzz\n1\n2\nFizz\n4\nBuzz\nFizz\n7\n8\nFizz\nBuzz\n11\nFizz\n13\n14\nFizzBuzz\n...\n\n\n\n\n\n\nSuggerimento\n\n\n\nL’operatore modulo % restituisce il resto della divisione tra due numeri. Ad esempio, 5 % 3 restituisce 2, perché 5 diviso 3 dà 1 con un resto di 2.",
    "crumbs": [
      "Lezioni",
      "Espressioni e strutture di controllo",
      "FizzBuzz"
    ]
  },
  {
    "objectID": "exercises/extra/torneo.html",
    "href": "exercises/extra/torneo.html",
    "title": "Classifica del torneo",
    "section": "",
    "text": "I risultati di un torneo di pallavolo a eliminazione diretta vengono rappresentati nel sistema informatico della federazione sportiva come un albero binario di partite. Ogni nodo dell’albero rappresenta una partita e contiene le seguenti informazioni:\n\nteamId: l’identificativo della squadra che ha vinto la partita (di tipo intero)\nsetWon: il numero di set vinti durante la partita dalla squadra vincitrice (di tipo intero)\nsetLost: il numero di set persi durante la partita dalla squadra vincitrice (di tipo intero)\n\nLa classifica del torneo viene calcolata assegnando un punteggio a ciascuna squadra in base ai risultati ottenuti. Di seguito viene riportato lo pseudocodice che descrive come vengono calcolati i punteggi delle squadre:\n\n\n\\begin{algorithm} \\caption{getScores($root, scores, m$)} \\begin{algorithmic} \\State \\textbf{Input:} $root$ la radice di un albero binario, $scores$ un array di numeri a virgola mobile di lunghezza $n$ tale che $s_i = 0$ e $i = 0,\\dots n$ dove $s_i$ è l'elemento $i$-esimo dell'array $scores$, $m$ un numero intero. \\State \\textbf{Output:} Nessuno. \\textbf{Side effect}: $scores$ contiene il punteggio di ogni squadra. \\If{$root = \\text{nil}$} \\Return \\EndIf \\State $scores[root.\\text{teamId}] \\leftarrow scores[root.\\text{teamId}] + (root.\\text{setWon} - root.\\text{setLost}) \\times m$ \\State getScores($root.left$, $scores$, $m \\over 2$) \\State getScores($root.right$, $scores$, $m \\over 2$) \\end{algorithmic} \\end{algorithm}\n\n\nPrecondizioni: si assuma che tutti gli elementi di scores siano inizializzati a 0 ed \\(m \\in \\mathbb{N} \\setminus \\{0\\}\\).\nUna volta ottenuto l’array con i punteggi delle squadre si può facilmente trovare la squadra vincitrice con un algoritmo che abbia complessità \\(O(n)\\), dove \\(n\\) è la lunghezza dell’array scores.\nSi consideri come esempio un torneo con 4 squadre, identificate dai numeri da 0 a 3. Le foglie dell’albero rappresentano solamente i nomi delle squadre (i valori setWon e setLost sono inizializzati a 0). I nodi genitori contengono nel campo teamId l’identificativo della squadra vincente e nei campi setWon e setLost il numero di set vinti e persi rispettivamente. L’albero binario di partite è il seguente:\n\n\n\n\n\nflowchart TB\na[0, 3 - 2]\nb[2, 3 - 1]\nc[0, 3 - 0]\nd[1]\ne[0]\nf[2]\ng[3]\n\na --&gt; b\na --&gt; c\nc --&gt; d\nc --&gt; e\nb --&gt; f\nb --&gt; g\n\n\n\n\n\n\nUna rappresentazione testuale dell’albero, più adatta ad essere stampata nel terminale, è la seguente:\n0, 3 - 2\n├── 0, 3 - 0\n│   ├── 0\n│   └── 1\n└── 2, 3 - 1\n    ├── 2\n    └── 3\nSi chiede di implementare in linguaggio C le funzioni:\n\nvoid getScores(Node *root, double *scores, double m)\nint getWinner(double *scores, int n)\n\nla funzione getScores deve calcolare i punteggi delle squadre partendo dalla radice dell’albero binario di partite, mentre la funzione getWinner deve restituire l’id della squadra vincente.\nSe necessario, si possono aggiungere funzioni di supporto, ma è necessario che le funzioni richieste siano implementate esattamente con i prototipi forniti.\n\nLo pseudocodice non è codice completo in C: non considera i tipi dei vari oggetti, l’uso di puntatori/riferimenti, e dunque dell’operatore “-&gt;” anziché l’operatore “.”: `e lasciato allo studente il compito di determinare questi dettagli come adeguato.\n\n\n\n\n\n\n\nNota\n\n\n\nL’implementazione dell’albero in C è una semplice variante di quella utilizzata durante le lezioni del corso e viene fornita già implementata nei file dell’esercizio come segue:\ntypedef struct node\n{\n    int teamId;\n    int setWon;\n    int setLost;\n    struct node *left;\n    struct node *right;\n} Node;\n\n\n Scarica i file per svolgere l'esercizio",
    "crumbs": [
      "Lezioni",
      "Preparazione esame",
      "Torneo di pallavolo"
    ]
  },
  {
    "objectID": "exercises/extra/lista_di_stringhe.html",
    "href": "exercises/extra/lista_di_stringhe.html",
    "title": "word counter",
    "section": "",
    "text": "Nei sistemi operativi Unix-like, il comando wc consente di contare il numero di righe, parole, caratteri e byte di ciascun file o input standard e stampare il risultato.\nAd esempio il comando:\necho \"ciao mondo\\n\" | wc\nstamperà:\n1 2 11\nIl primo numero rappresenta il numero di righe, il secondo il numero di parole e il terzo il numero di caratteri.\n\n\n\n\n\n\nConsiglio\n\n\n\nPer avere una panoramica completa delle opzioni del comando wc si può consultare la pagina del manuale digitando man wc nel terminale.\n\n\n\nSi vuole implementare in C una funzione wc che, data una stringa, restituisca il numero di righe, parole e caratteri totali.\nIl prototipo della funzione è il seguente:\nvoid wc(const char *string, Stats *counter);\ndove:\n\nstring è una stringa;\ncounter è un puntatore ad una struttura Stats definita come segue:\n\ntypedef struct {\n    int lines;\n    int words;\n    int chars;\n} Stats;\nLa funzione deve calcolare il numero di righe, parole e caratteri della stringa string e memorizzarli nella struttura Stats puntata da counter.\nSi assuma che:\n\nuna riga è una sequenza di caratteri terminata da un carattere di nuova riga (\\n);\nuna parola è una sequenza di caratteri separata da spazi o da caratteri di nuova riga; \"a b\" sono due parole, \"a\\nb\" sono due parole parola, \"a,b\" è una parola;\n\nSe necessario, si possono aggiungere funzioni di supporto, ma è necessario che le funzioni richieste siano implementate esattamente con i prototipi forniti.\n Scarica i file per svolgere l'esercizio \n\n\n\n\n\n\nSoluzione (fare click per visualizzare)\n\n\n\n\n\nEsistono diversi modi in C per implementare il codice richiesto, la soluzione proposta utilizza un ciclo while per iterare su tutti i caratteri della stringa e contare il numero di righe, parole e caratteri, utilizzando una variabile prev per tenere traccia del carattere precedente. La soluzione ha complessità \\(O(n)\\), dove \\(n\\) è la lunghezza della stringa.\nLa soluzione proposta è la seguente:\nvoid wc(const char *str, Stats *counter)\n{\n    // se la stringa è vuota non c'è nulla da contare\n    if (*str == '\\0')\n    {\n        // dal momento che il contador è inizializzato a 0 non è necessario fare nulla\n        return;\n    }\n\n    char prev = ' ';\n\n    // se la stringa non è vuota, ci sarà almeno una riga\n    counter-&gt;lines++;\n\n    // iteriamo su tutti i caratteri della stringa\n    while (*str != '\\0')\n    {\n        // a ogni carattere incrementiamo il contatore dei caratteri\n        counter-&gt;chars++;\n        if (*str == '\\n')\n        {\n            // se il carattere è un carattere di nuova riga incrementiamo\n            // il contatore delle righe\n            counter-&gt;lines++;\n        }\n        if (is_empty(*str) && !is_empty(prev))\n        {\n            // se il carattere corrente è uno spazio e il carattere precedente\n            // non era uno spazio, incrementiamo il contatore delle parole\n            counter-&gt;words++;\n        }\n        // salviamo il carattere corrente per il prossimo ciclo\n        prev = *str;\n        str++;\n    }\n\n    // se l'ultimo carattere della stringa non è uno spazio\n    // non è stato incrementato il contatore delle parole\n    // quindi è necessario effettuare un controllo aggiuntivo\n    // per incrementare il contatore delle parole\n    if (!is_empty(prev))\n    {\n        counter-&gt;words++;\n    }\n}",
    "crumbs": [
      "Lezioni",
      "Preparazione esame",
      "word count"
    ]
  },
  {
    "objectID": "exercises/01/somma_razionale.html",
    "href": "exercises/01/somma_razionale.html",
    "title": "Esercizio: somma di numeri razionali",
    "section": "",
    "text": "Si vuole scrivere un programma che accetti in input due razionali nella forma n/m e ne stampi la somma (non semplificata).\nAd esempio:\nInserisci il primo numero: 3/4\nInserisci il secondo numero: 1/2\nLa somma dei due numeri è 5/4\nOpzionale:\n\nUna volta compilato il programma eseguilo con gdb controllando ad ogni step i valori delle variabili locali.\n\n\n\n\n\n\n\nSuggerimento\n\n\n\nIn questo caso possiamo richiedere all’utente che il formato includa lo slash, e quindi includerlo nel pattern di scanf.\n\n\n\n\n\n\n\n\nSoluzione\n\n\n\n\n\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    // creo le variabili per salvare l'input\n    int n1, m1, n2, m2;\n    int num, den;\n\n    // leggo da stdin\n    scanf(\"%d/%d\", &n1, &m1);\n    scanf(\"%d/%d\", &n2, &m2);\n\n    // sommo le due frazioni\n    num = n1 * m2 + n2 * m1;\n    den = m1 * m2;\n\n    // stampo a monitor il risultato\n    printf(\"Risultato: %d/%d\\n\", num, den);\n}",
    "crumbs": [
      "Lezioni",
      "Basi di C",
      "Somma razionale"
    ]
  },
  {
    "objectID": "exercises/01/cambio_valuta.html",
    "href": "exercises/01/cambio_valuta.html",
    "title": "Esercizio: cambio valuta",
    "section": "",
    "text": "L’Italia ha cambiato la sua valuta dalla lira italiana (ITL) all’euro (EUR) il 1º gennaio 2002. Questo è stato un evento storico noto come la “fase di transizione all’euro” o l’“introduzione dell’euro”. Durante questo periodo, le banconote e le monete denominate in euro sono state introdotte gradualmente in circolazione e la lira italiana è stata gradualmente ritirata. Il processo di transizione all’euro ha coinvolto un periodo di preparazione e pianificazione da parte delle istituzioni finanziarie e del governo italiano.\nGli italiani, al momento del cambio, si sono trovati a dover far fronte a un nuovo sistema di valuta. Per aiutare le persone a comprendere meglio il valore delle nuove banconote e monete, i giornali e i media hanno pubblicato tabelle di conversione tra le due valute ma il metodo più comune che venne adottato fin da subito fu la conversione esatta da lire in euro al tasso di cambio stabilito dai governi. Il valore di un euro è stato fissato a 1936,27 lire italiane.\n\nSi vuole scrivere un programma che, dato un importo in lire, lo converta in euro. Il programma deve chiedere all’utente di inserire un importo in lire e visualizzare a video l’importo corrispondente in euro.\n\nQuando il programma viene eseguito deve chiedere all’utente di inserire la quantità di lire italiane da cambiare, effettuare il calcolo e visualizzare il risultato a video a video.\nAd esempio:\nInserire l'importo in lire: 10000\n10000 lire italiane corrispondono a 5.16 euro\n\n\n\n\n\n\nSuggerimento\n\n\n\nPer convertire un importo da lire a euro, si può utilizzare la seguente formula: \\[\n\\text{euro} = \\frac{\\text{lire}}{1936.27}\n\\]\nIn C è molto comune definire le costanti in due maniere:\n\ncon la direttiva #define:\n#define TASSO_CAMBIO 1936.27\ncon la dichiarazione di una variabile const:\nconst float TASSO_CAMBIO = 1936.27;\n\n\n\nEsempio di main:\n\n\n Scarica il file \n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    // TODO: ricevere in input un importo in lire da cambiare\n\n    // TODO: stampare a monitor l'importo in euro corrispondente\n}\n\n\n\n\n\n\nSoluzione\n\n\n\n\n\n#include &lt;stdio.h&gt;\n\nconst float TASSO_CAMBIO = 1936.27f;\n\nint main(void)\n{\n    float euro, lit;\n\n    printf(\"Inserisci l'importo in lire da cambiare: \");\n    scanf(\"%f\", &lit);\n\n    euro = lit / TASSO_CAMBIO;\n\n    printf(\"%.2f lire corrispondono a %.2f euro\\n\", lit, euro);\n}",
    "crumbs": [
      "Lezioni",
      "Basi di C",
      "Cambio valuta"
    ]
  },
  {
    "objectID": "CODE_OF_CONDUCT.html",
    "href": "CODE_OF_CONDUCT.html",
    "title": "Contributor Covenant Code of Conduct",
    "section": "",
    "text": "We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.\nWe pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.\n\n\n\nExamples of behavior that contributes to a positive environment for our community include:\n\nDemonstrating empathy and kindness toward other people\nBeing respectful of differing opinions, viewpoints, and experiences\nGiving and gracefully accepting constructive feedback\nAccepting responsibility and apologizing to those affected by our mistakes, and learning from the experience\nFocusing on what is best not just for us as individuals, but for the overall community\n\nExamples of unacceptable behavior include:\n\nThe use of sexualized language or imagery, and sexual attention or advances of any kind\nTrolling, insulting or derogatory comments, and personal or political attacks\nPublic or private harassment\nPublishing others’ private information, such as a physical or email address, without their explicit permission\nOther conduct which could reasonably be considered inappropriate in a professional setting\n\n\n\n\nCommunity leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.\nCommunity leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.\n\n\n\nThis Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.\n\n\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at spanio@dei.unipd.it. All complaints will be reviewed and investigated promptly and fairly.\nAll community leaders are obligated to respect the privacy and security of the reporter of any incident.\n\n\n\nCommunity leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:\n\n\nCommunity Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.\nConsequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.\n\n\n\nCommunity Impact: A violation through a single incident or series of actions.\nConsequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.\n\n\n\nCommunity Impact: A serious violation of community standards, including sustained inappropriate behavior.\nConsequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.\n\n\n\nCommunity Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.\nConsequence: A permanent ban from any sort of public interaction within the community.\n\n\n\n\nThis Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.\nCommunity Impact Guidelines were inspired by Mozilla’s code of conduct enforcement ladder.\nFor answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations."
  },
  {
    "objectID": "CODE_OF_CONDUCT.html#our-pledge",
    "href": "CODE_OF_CONDUCT.html#our-pledge",
    "title": "Contributor Covenant Code of Conduct",
    "section": "",
    "text": "We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.\nWe pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community."
  },
  {
    "objectID": "CODE_OF_CONDUCT.html#our-standards",
    "href": "CODE_OF_CONDUCT.html#our-standards",
    "title": "Contributor Covenant Code of Conduct",
    "section": "",
    "text": "Examples of behavior that contributes to a positive environment for our community include:\n\nDemonstrating empathy and kindness toward other people\nBeing respectful of differing opinions, viewpoints, and experiences\nGiving and gracefully accepting constructive feedback\nAccepting responsibility and apologizing to those affected by our mistakes, and learning from the experience\nFocusing on what is best not just for us as individuals, but for the overall community\n\nExamples of unacceptable behavior include:\n\nThe use of sexualized language or imagery, and sexual attention or advances of any kind\nTrolling, insulting or derogatory comments, and personal or political attacks\nPublic or private harassment\nPublishing others’ private information, such as a physical or email address, without their explicit permission\nOther conduct which could reasonably be considered inappropriate in a professional setting"
  },
  {
    "objectID": "CODE_OF_CONDUCT.html#enforcement-responsibilities",
    "href": "CODE_OF_CONDUCT.html#enforcement-responsibilities",
    "title": "Contributor Covenant Code of Conduct",
    "section": "",
    "text": "Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.\nCommunity leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate."
  },
  {
    "objectID": "CODE_OF_CONDUCT.html#scope",
    "href": "CODE_OF_CONDUCT.html#scope",
    "title": "Contributor Covenant Code of Conduct",
    "section": "",
    "text": "This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event."
  },
  {
    "objectID": "CODE_OF_CONDUCT.html#enforcement",
    "href": "CODE_OF_CONDUCT.html#enforcement",
    "title": "Contributor Covenant Code of Conduct",
    "section": "",
    "text": "Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at spanio@dei.unipd.it. All complaints will be reviewed and investigated promptly and fairly.\nAll community leaders are obligated to respect the privacy and security of the reporter of any incident."
  },
  {
    "objectID": "CODE_OF_CONDUCT.html#enforcement-guidelines",
    "href": "CODE_OF_CONDUCT.html#enforcement-guidelines",
    "title": "Contributor Covenant Code of Conduct",
    "section": "",
    "text": "Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:\n\n\nCommunity Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.\nConsequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.\n\n\n\nCommunity Impact: A violation through a single incident or series of actions.\nConsequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.\n\n\n\nCommunity Impact: A serious violation of community standards, including sustained inappropriate behavior.\nConsequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.\n\n\n\nCommunity Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.\nConsequence: A permanent ban from any sort of public interaction within the community."
  },
  {
    "objectID": "CODE_OF_CONDUCT.html#attribution",
    "href": "CODE_OF_CONDUCT.html#attribution",
    "title": "Contributor Covenant Code of Conduct",
    "section": "",
    "text": "This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.\nCommunity Impact Guidelines were inspired by Mozilla’s code of conduct enforcement ladder.\nFor answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations."
  },
  {
    "objectID": "extra/license.html",
    "href": "extra/license.html",
    "title": "Open Source License",
    "section": "",
    "text": "I materiali presenti sul sito sono messi a disposizione sotto licenza Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. Il testo completo della licenza è disponibile qui.\nIl codice sorgente di questo sito è disponibile a https://github.com/matteospanio/corso-c.\nInoltre il sito fa uso di diversi altri progetti open-source, la distribuzione dei quali è soggetta alle rispettive licenze. I principali componenti e le loro licenze sono:\n\n\n\nProgetto\nLicenza\n\n\n\n\nPandoc\nGNU GPL v2\n\n\nBootstrap 5.1\nMIT\n\n\nBootswatch 5.1\nMIT\n\n\nDeno\nMIT\n\n\nesbuild\nMIT\n\n\nDart Sass\nMIT\n\n\nObservable Runtime\nISC\n\n\nQuarto 1.4\nMIT"
  },
  {
    "objectID": "extra/style_guide.html",
    "href": "extra/style_guide.html",
    "title": "Guida allo stile per il linguaggio C",
    "section": "",
    "text": "Nota\n\n\n\nLa presente guida è un riadattamento dalla style guide del CS50 di Harvard per il corso di Dati e Algoritmi dell’Università di Padova.\nNon esiste un modo “giusto” unico per scrivere codice. Ma ci sono sicuramente molti modi sbagliati (o, almeno, cattivi). Ad ogni modo, essendo questo un corso di introduzione a C, è una buona occasione per mettere in pratica alcune regole di stile per scrivere fin da subito codice leggibile e mantenibile.",
    "crumbs": [
      "Risorse",
      "Come scrivere codice",
      "Style Guide"
    ]
  },
  {
    "objectID": "extra/style_guide.html#lunghezza-della-linea",
    "href": "extra/style_guide.html#lunghezza-della-linea",
    "title": "Guida allo stile per il linguaggio C",
    "section": "Lunghezza della linea",
    "text": "Lunghezza della linea\nPer convenzione, la lunghezza massima di una riga di codice è di 80 caratteri in C, questa è una scelta di ragioni storiche, infatti negli anni ’80 i monitor di dimensioni standard potevano visualizzare 24 linee verticali e 80 caratteri orizzontali. Anche se la tecnologia moderna ha reso obsoleta la necessità di mantenere le linee limitate a 80 caratteri, è comunque una linea guida che dovrebbe essere considerata come un “limite flessibile”. Oggi, solitamente, si cerca di non superare i 100 caratteri in una singola linea. Se hai bisogno di più di 100 caratteri, potrebbe essere il momento di ripensare sia ai nomi delle variabili che al design complessivo del programma!",
    "crumbs": [
      "Risorse",
      "Come scrivere codice",
      "Style Guide"
    ]
  },
  {
    "objectID": "extra/style_guide.html#commenti",
    "href": "extra/style_guide.html#commenti",
    "title": "Guida allo stile per il linguaggio C",
    "section": "Commenti",
    "text": "Commenti\nI commenti rendono il codice più leggibile, non solo per gli altri, ma anche per te, specialmente quando passano ore, giorni, settimane, mesi o anni tra la scrittura e la lettura del tuo stesso codice. Commentare troppo poco è sbagliato. Commentare troppo è sbagliato. Dove sta il punto giusto? Commentare ogni poche righe di codice (cioè, blocchi interessanti) è una buona linea guida. Cerca di scrivere commenti che rispondano a una o entrambe queste domande:\n\nCosa fa questo blocco?\nPerché ho implementato questo blocco in questo modo?\n\nAll’interno delle funzioni, utilizza “commenti in linea” e mantienili brevi (ad esempio, una riga), altrimenti diventa difficile distinguere i commenti dal codice. Posiziona il commento sopra la riga (o le righe) a cui si applica. Non è necessario scrivere frasi complete, ma metti in maiuscolo la prima parola del commento (a meno che non sia il nome di una funzione, variabile o simile), e lascia uno spazio tra // e il primo carattere del tuo commento, come in:\n// Converti Fahrenheit in Celsius\nfloat c = 5.0 / 9.0 * (f - 32.0);\nIn altre parole, non fare questo:\n// converti Fahrenheit in Celsius\nfloat c = 5.0 / 9.0 * (f - 32.0);\nO questo:\nfloat c = 5.0 / 9.0 * (f - 32.0); // Converti Fahrenheit in Celsius\nNelle prime righe dei file .c e .h dovrebbe esserci un commento che riassuma ciò che fa il tuo programma (o quel particolare file).\nSopra ciascuna delle tue funzioni (eccetto, forse, main), dovrebbe invece esserci un commento che riassuma cosa fa la tua funzione, come in:\n// Restituisce il quadrato di n\nint quadrato(int n)\n{\n    return n * n;\n}",
    "crumbs": [
      "Risorse",
      "Come scrivere codice",
      "Style Guide"
    ]
  },
  {
    "objectID": "extra/style_guide.html#intestazioni-delle-librerie",
    "href": "extra/style_guide.html#intestazioni-delle-librerie",
    "title": "Guida allo stile per il linguaggio C",
    "section": "Intestazioni delle librerie",
    "text": "Intestazioni delle librerie\nTutte le intestazioni delle librerie che includi dovrebbero essere elencate in ordine alfabetico, come in:\n#include &lt;math.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\nQuesto rende più facile vedere in un colpo d’occhio, specialmente in un elenco lungo, se hai incluso un’intestazione.",
    "crumbs": [
      "Risorse",
      "Come scrivere codice",
      "Style Guide"
    ]
  },
  {
    "objectID": "extra/style_guide.html#condizioni",
    "href": "extra/style_guide.html#condizioni",
    "title": "Guida allo stile per il linguaggio C",
    "section": "Condizioni",
    "text": "Condizioni\nLe condizioni dovrebbero essere stilizzate come segue:\nif (x &gt; 0)\n{\n    printf(\"x è positivo\\n\");\n}\nelse if (x &lt; 0)\n{\n    printf(\"x è negativo\\n\");\n}\nelse\n{\n    printf(\"x è zero\\n\");\n}\nNota come:\n\nle parentesi graffe si allineano bene, ognuna sulla propria linea, rendendo perfettamente chiaro cosa c’è dentro il ramo;\nc’è uno spazio singolo dopo ogni if;\nogni chiamata a printf è indentata con 4 spazi;\nci sono spazi singoli intorno a &gt; e intorno a &lt;; e\nnon c’è alcuno spazio immediatamente dopo ogni ( o immediatamente prima di ogni ).\n\nPer risparmiare spazio, alcuni programmatori preferiscono mantenere la prima parentesi graffa sulla stessa riga della condizione stessa, ma non lo consigliamo, poiché è più difficile da leggere, quindi non fare questo:\nif (x &lt; 0) {\n    printf(\"x è negativo\\n\");\n} else if (x &lt; 0) {\n    printf(\"x è negativo\\n\");\n}\nE sicuramente non fare questo:\nif (x &lt; 0)\n    {\n    printf(\"x è negativo\\n\");\n    }\nelse\n    {\n    printf(\"x è negativo\\n\");\n    }",
    "crumbs": [
      "Risorse",
      "Come scrivere codice",
      "Style Guide"
    ]
  },
  {
    "objectID": "extra/style_guide.html#switch",
    "href": "extra/style_guide.html#switch",
    "title": "Guida allo stile per il linguaggio C",
    "section": "Switch",
    "text": "Switch\nDichiara uno switch come segue:\nswitch (n)\n{\n    case -1:\n        printf(\"n è -1\\n\");\n        break;\n\n    case 1:\n        printf(\"n è 1\\n\");\n        break;\n\n    default:\n        printf(\"n non è né -1 né 1\\n\");\n        break;\n}\nNota come:\n\nogni parentesi graffa sia su una propria riga;\nc’è uno spazio singolo dopo switch;\nnon c’è spazio immediatamente dopo ogni ( o prima di ogni );\ni casi dello switch sono indentati con 4 spazi;\ni corpi dei casi sono indentati ulteriormente con 4 spazi; e\nogni case (incluso default) termina con un break.",
    "crumbs": [
      "Risorse",
      "Come scrivere codice",
      "Style Guide"
    ]
  },
  {
    "objectID": "extra/style_guide.html#funzioni",
    "href": "extra/style_guide.html#funzioni",
    "title": "Guida allo stile per il linguaggio C",
    "section": "Funzioni",
    "text": "Funzioni\nIn conformità con C99, assicurati di dichiarare main con:\nint main(void)\n{\n\n}\no con:\nint main(int argc, char *argv[])\n{\n\n}\no anche con:\nint main(int argc, char **argv)\n{\n\n}\nNon dichiarare main con:\nint main()\n{\n\n}\no con:\nvoid main()\n{\n\n}\no con:\nmain()\n{\n\n}\nPer le tue stesse funzioni, assicurati di definirle similmente, con ogni parentesi graffa su una propria riga e con il tipo di ritorno sulla stessa riga del nome della funzione, proprio come abbiamo fatto con main.",
    "crumbs": [
      "Risorse",
      "Come scrivere codice",
      "Style Guide"
    ]
  },
  {
    "objectID": "extra/style_guide.html#indentazione",
    "href": "extra/style_guide.html#indentazione",
    "title": "Guida allo stile per il linguaggio C",
    "section": "Indentazione",
    "text": "Indentazione\nIndenta il tuo codice con quattro spazi alla volta per chiarire quali blocchi di codice sono contenuti all’interno di altri. Se usi il tasto Tab sulla tastiera per farlo, assicurati che l’editor di testo sia configurato per convertire le tabulazioni (\\t) in quattro spazi, altrimenti il tuo codice potrebbe non essere stampato o visualizzato correttamente sul computer di qualcun altro, poiché \\t si renderizza in modo diverso in editor diversi.\nEcco del codice ben indentato:\n// Stampare gli argomenti della riga di comando uno per riga\nprintf(\"\\n\");\nfor (int i = 0; i &lt; argc; i++)\n{\n    for (int j = 0, n = strlen(argv[i]); j &lt; n; j++)\n    {\n        printf(\"%c\\n\", argv[i][j]);\n    }\n    printf(\"\\n\");\n}",
    "crumbs": [
      "Risorse",
      "Come scrivere codice",
      "Style Guide"
    ]
  },
  {
    "objectID": "extra/style_guide.html#cicli",
    "href": "extra/style_guide.html#cicli",
    "title": "Guida allo stile per il linguaggio C",
    "section": "Cicli",
    "text": "Cicli\n\nfor\nOgni volta che hai bisogno di variabili temporanee per l’iterazione, usa i, poi j, poi k, a meno che nomi più specifici non rendano il tuo codice più leggibile:\nfor (int i = 0; i &lt; LIMITE; i++)\n{\n    for (int j = 0; j &lt; LIMITE; j++)\n    {\n        for (int k = 0; k &lt; LIMITE; k++)\n        {\n            // Fai qualcosa\n        }\n    }\n}\nSe hai bisogno di più di tre variabili per l’iterazione, potrebbe essere il momento di ripensare il tuo design!\n\n\nwhile\nDichiara i cicli while come segue:\nwhile (condizione)\n{\n    // Fai qualcosa\n}\nNota come:\n\nogni parentesi graffa sia su una propria riga;\nc’è uno spazio singolo dopo while;\nnon c’è spazio immediatamente dopo il ( o prima del ); e\nil corpo del ciclo (un commento in questo caso) è indentato con 4 spazi.\n\n\n\ndo … while\nDichiara i cicli do ... while come segue:\ndo\n{\n    // Fai qualcosa\n}\nwhile (condizione);\nNota come:\n\nogni parentesi graffa sia su una propria riga;\nc’è uno spazio singolo dopo while;\nnon c’è spazio immediatamente dopo il ( o prima del ); e\nil corpo del ciclo (un commento in questo caso) è indentato con 4 spazi.",
    "crumbs": [
      "Risorse",
      "Come scrivere codice",
      "Style Guide"
    ]
  },
  {
    "objectID": "extra/style_guide.html#puntatori",
    "href": "extra/style_guide.html#puntatori",
    "title": "Guida allo stile per il linguaggio C",
    "section": "Puntatori",
    "text": "Puntatori\nQuando dichiari un puntatore, scrivi * accanto alla variabile, come in:\nint *p;\nNon scriverlo accanto al tipo, come in:\nint* p;",
    "crumbs": [
      "Risorse",
      "Come scrivere codice",
      "Style Guide"
    ]
  },
  {
    "objectID": "extra/style_guide.html#variabili",
    "href": "extra/style_guide.html#variabili",
    "title": "Guida allo stile per il linguaggio C",
    "section": "Variabili",
    "text": "Variabili\nPoiché in questo corso si utilizza C99, non definire tutte le tue variabili all’inizio delle tue funzioni ma, piuttosto, quando e dove ne hai effettivamente bisogno. Inoltre, limita il più possibile lo scope delle tue variabili. Ad esempio, se i è necessario solo per il ciclo, dichiara i all’interno del ciclo stesso:\nfor (int i = 0; i &lt; LIMITE; i++)\n{\n    printf(\"%i\\n\", i);\n}\nAnche se è accettabile utilizzare variabili come i, j e k per l’iterazione, la maggior parte delle tue variabili dovrebbe avere nomi più specifici. Se stai sommando alcuni valori, ad esempio, chiamare la tua variabile somma. Se il nome della tua variabile giustifica due parole (ad esempio, ha_mangiato), metti un trattino basso (underscore) tra di esse, questo modo di chiamare le variabili è detto snake_case (altri modi di dare il nome alle variabili sono il CamelCase o il meno comune kebab-case).\n\n\n\n\n\n\nAttenzione\n\n\n\nPerché il kebab case è un formato più insolito degli altri? Se provi a dare un nome di variabile in kebab-case in un programma C cosa succede?\n\n\nSe dichiari più variabili dello stesso tipo contemporaneamente, è accettabile dichiararle insieme, come in:\nint quartieri, dimes, nickels, pennies;\nBasta non inizializzare alcune ma non altre, come in:\nint quartieri, dimes = 0, nickels = 0 , pennies;\nPrenditi cura anche di dichiarare i puntatori separatamente dai non puntatori, come in:\nint *p;\nint n;\nNon dichiarare puntatori sulla stessa riga dei non puntatori, come in:\nint *p, n;",
    "crumbs": [
      "Risorse",
      "Come scrivere codice",
      "Style Guide"
    ]
  },
  {
    "objectID": "extra/style_guide.html#strutture",
    "href": "extra/style_guide.html#strutture",
    "title": "Guida allo stile per il linguaggio C",
    "section": "Strutture",
    "text": "Strutture\nDichiara una struct come tipo come segue, con ogni parentesi graffa su una propria riga e i membri indentati al suo interno, con il nome del tipo anche sulla sua riga:\ntypedef struct\n{\n    char *nome;\n    int matricola;\n} studente_t;\nQuando definisci un tipo con typedef è buona prassi usare un nome che finisce con _t, questo per poterlo facilmente distinguere dai nomi di variabile, dalle funzioni o dalle macro.",
    "crumbs": [
      "Risorse",
      "Come scrivere codice",
      "Style Guide"
    ]
  },
  {
    "objectID": "extra/docker.html",
    "href": "extra/docker.html",
    "title": "Ambiente di sviluppo",
    "section": "",
    "text": "Per chi non ha una istallazione Linux (nativa o VM) è possibile riprodurre un ambiente identico a quello utilizzato nelle lezioni tramite una immagine docker. Ecco come fare:",
    "crumbs": [
      "Risorse",
      "Ambiente di sviluppo"
    ]
  },
  {
    "objectID": "extra/docker.html#strumenti-installati-nellimmagine-docker",
    "href": "extra/docker.html#strumenti-installati-nellimmagine-docker",
    "title": "Ambiente di sviluppo",
    "section": "Strumenti installati nell’immagine docker",
    "text": "Strumenti installati nell’immagine docker\nTra i principali programmi installati nell’immagine docker ci sono:\n\ngcc e g++ per compilare i programmi in C e C++\nmake per automatizzare la compilazione\ngit per gestire i sorgenti\nvim, un editor di testo minimale\nvalgrind per analizzare i programmi\ngdb per il debug\npython3 per eseguire script python\nman, il manuale di riferimento per i comandi linux",
    "crumbs": [
      "Risorse",
      "Ambiente di sviluppo"
    ]
  },
  {
    "objectID": "extra/docker.html#condividere-una-cartella-tra-il-sistema-host-e-limmagine-docker",
    "href": "extra/docker.html#condividere-una-cartella-tra-il-sistema-host-e-limmagine-docker",
    "title": "Ambiente di sviluppo",
    "section": "Condividere una cartella tra il sistema host e l’immagine docker",
    "text": "Condividere una cartella tra il sistema host e l’immagine docker\nPer condividere una cartella tra il sistema host e l’immagine docker è possibile utilizzare l’opzione -v di docker. Ad esempio:\ndocker run -it --rm -v /path/to/my/folder:/mnt ghcr.io/matteospanio/cdev:latest bash\nQuesto comando permette di montare la cartella /path/to/my/folder all’interno dell’immagine docker nella cartella /mnt. In questo modo è possibile condividere i file tra il sistema host e l’immagine docker. Dall’interno dell’ambiente docker è possibile andare alla cartella /mnt con il comando cd /mnt, in questa directory saranno presenti i file della cartella /path/to/my/folder del sistema host. Ciò comporta che le modifiche ai file condivisi saranno visibili sia dal sistema host che dall’immagine docker e permanenti.\n\n\n\n\n\n\nNota\n\n\n\nI file creati nell’ambiente docker e le modifiche fatte al sistema operativo dell’immagine docker, di default, non sono permanenti.\n\n\nL’applicazione cdev-cli semplifica il processo di avvio dell’immagine docker e la condivisione di una cartella tra il sistema host e l’immagine docker, in particolare permette di avviare l’immagine docker con un comando e di condividere la cartella corrente del sistema host con l’immagine docker. Eseguendo il comando cdev-cli da una determinata cartella nel sistema host si avvia l’immagine docker e si condivide la cartella corrente con l’immagine docker alla posizione /mnt.",
    "crumbs": [
      "Risorse",
      "Ambiente di sviluppo"
    ]
  },
  {
    "objectID": "extra/gdb.html",
    "href": "extra/gdb.html",
    "title": "GDB - Usare il debugger GNU",
    "section": "",
    "text": "GDB (GNU Debugger) rappresenta un’indispensabile risorsa per chiunque si addentri nel mondo della programmazione in C e C++ offrendo un insieme di strumenti per il debugging di codice estremamente versatile e potente. Questa pagina mira a fornire una panoramica introduttiva dell’utilizzo di GDB, accompagnata da esempi pratici per facilitarne la comprensione.",
    "crumbs": [
      "Risorse",
      "Strumenti di sviluppo",
      "Usare il debugger GDB"
    ]
  },
  {
    "objectID": "extra/gdb.html#installazione",
    "href": "extra/gdb.html#installazione",
    "title": "GDB - Usare il debugger GNU",
    "section": "Installazione",
    "text": "Installazione\nPer verificare se GDB è già installato sul proprio sistema è possibile eseguire il seguente comando:\ngdb --version\nNel caso in cui uscisse un numero di versione, GDB è già installato. In caso contrario, è possibile procedere con l’installazione. L’installazione di GDB su sistemi operativi basati su Debian/Ubuntu può essere eseguita mediante l’utilizzo del gestore di pacchetti, con il seguente comando:\nsudo apt-get install gdb",
    "crumbs": [
      "Risorse",
      "Strumenti di sviluppo",
      "Usare il debugger GDB"
    ]
  },
  {
    "objectID": "extra/gdb.html#utilizzo-di-base",
    "href": "extra/gdb.html#utilizzo-di-base",
    "title": "GDB - Usare il debugger GNU",
    "section": "Utilizzo di Base",
    "text": "Utilizzo di Base\nConsideriamo un semplice programma in linguaggio C denominato esempio.c, il cui codice è il seguente:\n#include &lt;stdio.h&gt;\n#define N 5\n\nint main(void)\n{\n    // crea un array di N interi\n    int arr[N];\n\n    // inizializza l'array con valori incrementali\n    for (int i = 0; i &lt; N; i++)\n    {\n        arr[i] = i + 1;\n    }\n\n    // stampa gli elementi dell'array\n    for(int i = 0; i &lt; N; i++)\n    {\n        printf(\"%d\\n\", arr[i]);\n    }\n}\nNormalmente il compilatore C ignora i nomi delle variabili e delle funzioni, pertanto queste informazioni, di solito, non sono disponibili durante l’esecuzione del programma. Per mantenere queste informazioni nel file compilato, è necessario includere le informazioni di debug durante la compilazione del programma. Il compilatore gcc offre l’opzione -g per includere queste informazioni, pertanto, quando si vuole utilizzare GDB per il debugging di un programma, è necessario compilare il programma con questa opzione:\ngcc -g esempio.c -o esempio\nSuccessivamente, è possibile avviare GDB, specificando il nome del programma compilato come argomento:\ngdb ./esempio\nA questo punto dovrebbero essere apparse un po’ di righe di intestazione con le informazioni di gdb, l’ultima riga invece dovrebbe assomigliare a (gdb). Vuol dire che siamo in una sessione di gdb pronta a ricevere comandi per il debugging del programma.",
    "crumbs": [
      "Risorse",
      "Strumenti di sviluppo",
      "Usare il debugger GDB"
    ]
  },
  {
    "objectID": "extra/gdb.html#comandi-di-base",
    "href": "extra/gdb.html#comandi-di-base",
    "title": "GDB - Usare il debugger GNU",
    "section": "Comandi di base",
    "text": "Comandi di base\ngdb accetta comandi testuali per interagire con il programma in esecuzione.\nIl comando run (o r) avvia l’esecuzione del programma monitorato da GDB. Provando ad eseguire il comando run si dovrebbe vedere l’output del programma, che in questo caso dovrebbe essere:\n(gdb) run\nStarting program: /home/matteo/Scrivania/prova/esempio\n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".\n1\n2\n3\n4\n5\n[Inferior 1 (process 192487) exited normally]\nCome si può vedere dall’output, il programma è stato eseguito, ha stampato i valori che ci aspettavamo, e si è concluso normalmente. Però non abbiamo avuto modo di controllare il funzionamento del programma, e non abbiamo potuto vedere come il programma si comporta durante l’esecuzione. Per questo esiste il comando break (o b), che permette di impostare un breakpoint in un punto specifico del programma, in modo da poter controllare il funzionamento del programma in quel punto. Per impostare un breakpoint all’inizio della funzione main si può eseguire il comando break main:\n(gdb) break main\nBreakpoint 1 at 0x555555555175: file esempio.c, line 5.\nOra che abbiamo impostato un breakpoint, possiamo eseguire il programma con il comando run e il programma si fermerà al breakpoint appena impostato.\n(gdb) run\nStarting program: /home/matteo/Scrivania/prova/esempio\n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".\n\nBreakpoint 1, main () at esempio.c:5\n5   {\nEffettivamente viene stampata la riga 5 del file esempio.c, che corrisponde all’inizio della funzione main, purtroppo però si vede solo la parentesi graffa. Per vedere cosa si trova intorno al breakpoint si può utilizzare il comando list (o l). In questo caso si avrà il seguente output:\n(gdb) list\n1   #include &lt;stdio.h&gt;\n2   #define N 5\n3\n4   int main(void)\n5   {\n6       // crea un array di N interi\n7       int arr[N];\n8\n9       // inizializza l'array con valori incrementali\n10      for (int i = 0; i &lt; N; i++)\nCome si può vedere, il comando list mostra il codice sorgente intorno al breakpoint.\nPer andare avanti di un’istruzione si può utilizzare il comando next (o n). Questo comando permette di eseguire l’istruzione successiva del programma, considerando le chiamate a funzione come singole istruzioni. Se si esegue il comando next si dovrebbe vedere l’output seguente:\n(gdb) next\n10      for (int i = 0; i &lt; N; i++)\nQuesta volta si vede la riga 10 del file esempio.c, che corrisponde all’inizio del ciclo for. Stranamente l’istruzione a riga 7 in cui viene dichiarato l’array arr non ha fermato l’esecuzione di gdb su quella riga. , e quindi gdb non si ferma su quella riga. Ad ogni modo però si può controllare che esista l’array con il comando print (o p), che permette di stampare il valore di una variabile. Per stampare l’array arr si può eseguire il comando print arr:\n(gdb) print arr\n$1 = {-8711, 32767, 100, 0, 4096}\nL’array ha dimensione 5 come ci aspettavamo, ma contiene valori strani. Questo è dovuto al fatto che C non inizializza le variabili quando vengono dichiarate, e quindi l’array arr contiene valori casuali.\nPossiamo andare avanti con l’esecuzione eseguendo il comando next un po’ di volte:\n(gdb) next\n12          arr[i] = i + 1;\n(gdb) next\n10      for (int i = 0; i &lt; N; i++)\n(gdb) next\n12          arr[i] = i + 1;\n(gdb)\n10      for (int i = 0; i &lt; N; i++)\n(gdb)\n12          arr[i] = i + 1;\n(gdb)\n10      for (int i = 0; i &lt; N; i++)\n(gdb)\n12          arr[i] = i + 1;\n(gdb)\n10      for (int i = 0; i &lt; N; i++)\n12          arr[i] = i + 1;\n(gdb)\n10      for (int i = 0; i &lt; N; i++)\nSi vedono sempre le stesse righe 10 e 12, che corrispondono all’inizio e alla fine del ciclo for. Si noti che premere invio senza digitare un comando esegue l’ultimo comando digitato, quindi se si esegue tante volte di seguito il comando next si può scriverlo la prima volta e poi premere invio tante volte quante si vuole eseguire il comando. A questo punto, eseguendo il comando print arr si dovrebbe vedere l’array arr con i valori inizializzati:\n(gdb) print arr\n$1 = {1, 2, 3, 4, 5}\n\nLista dei comandi più comuni\n\nrun (o r): Avvia l’esecuzione del programma monitorato da GDB.\nbreak  (o b ): Permette di impostare un breakpoint in un punto specifico del programma, identificabile tramite il nome di una funzione, un numero di riga (preceduto dal nome del file e due punti per maggiore specificità), o un indirizzo di memoria.\nnext (o n): Consente di eseguire l’istruzione successiva del programma, considerando le chiamate a funzione come singole istruzioni.\nstep (o s): Simile al comando next, ma consente di “entrare” nelle chiamate a funzione per esaminarne il dettaglio.\nprint  (o p ): Stampa il valore dell’espressione specificata, che può essere una variabile, un’espressione valida in C, o una chiamata a funzione.\ncontinue (o c): Riprende l’esecuzione del programma fino al raggiungimento del successivo breakpoint.\nquit (o q): Termina la sessione di GDB.\n\nGDB offre un’ampia gamma di funzionalità avanzate oltre a quelle introdotte in questa guida, rendendolo uno strumento estremamente potente per il debugging di programmi.",
    "crumbs": [
      "Risorse",
      "Strumenti di sviluppo",
      "Usare il debugger GDB"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hello C 2024",
    "section": "",
    "text": "Dispense per l’introdottozione al linguaggio di programmazione C. Questa è la pagina web della parte di programmazione in C del corso di dati e algoritmi per la laurea triennale in ingegneria elettronica presso l’Università di Padova.\n\nQuesto sito\nIl sito è organizzato per 3 macro aree:\n\nlezioni\nesercizi\nrisorse\n\nLa sezione lezioni raccoglie tutti i contenuti presentati a lezione, ogni lezione è riportata in formato html e pdf, inoltre è possibile consultare anche le diapositive viste a lezione in formato RevealJS. Oltre ai contenuti visti in classe sono presenti, saltuariamente, brevi guide sull’utilizzo/installazione di software o approfondimenti.\nLa sezione esercizi raccoglie molti esercizi per ripassare gli argomenti visti in classe e prepararsi all’esame, in generale vi sono esercizi di varia difficoltà.\nLa sezione risorse contiene materiali vari: una lista di letture consigliate sul linguaggio C oltre al libro di testo del corso, un elenco di materiali didattici reperibili online, domande e risposte comuni sull’esame, una guida sull’installazione dell’ambiente di sviluppo per scrivere programmi C.\n\n\nProgramma del corso\nDi seguito il programma del corso, tutti gli argomenti elencati potranno essere inclusi negli esercizi d’esame.\n\nBasi di C\n\nIntroduzione al linguaggio C\nStruttura di un programma\ncompilatore gcc\n\nSintassi del linguaggio\n\nTipi di dato di base\nOperatori (precedenza e associatività)\nStrutture di controllo (if-else, switch, for, while)\nFunzioni\nRicorsione\n\nArray, puntatori e stringhe\n\nArray\nPuntatori\nstringhe e funzioni di libreria\noperatori di indirizzamento ( & e * )\nallocazione dinamica di memoria\n\nStrutture dati\n\nstruct\nunion\ntypedef\nliste concatenate\nalberi binari\n\nAlgoritmi\n\nvisite di alberi (preorder, inorder, postorder)\nricerca binaria\nvisita di liste"
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Risorse",
    "section": "",
    "text": "Questa sezione è dedicata a risorse che possono essere utili da consultare per avere dei riferimenti ma non è necessario studiarle.\nIn particolare ci sono:\n\nuna sezione dedicata ai libri di testo in cui si può consultare una lista di letture suggerite oltre ad avere informazioni sul libro di testo ufficiale del corso;\nuna guida alla scrittura di codice chiaro in C, non è un requisito del corso scrivere seguendo questi criteri, è comunque consigliato applicare delle regole di formattazione per scrivere codice chiaro e coerente;\nuna sezione dedicata a domande e risposte frequenti in cui, in particolare, vengono descritte le modalità d’esame.",
    "crumbs": [
      "Lezioni",
      "Risorse"
    ]
  },
  {
    "objectID": "lessons/02/index.html",
    "href": "lessons/02/index.html",
    "title": "Strutture di controllo e tipi di base",
    "section": "",
    "text": "Tenendo a mente l’architettura di Von Neumann per i calcolatori, si può riassumere che i computer hanno bisogno di 2 principali elementi: dati e istruzioni per manipolare i dati. I linguaggi di programmazione forniscono in maniera trasparente queste componenti attraverso l’uso di variabili ed espressioni.\nLe espressioni sono un insieme di:",
    "crumbs": [
      "Lezioni",
      "Strutture di controllo e tipi di base"
    ]
  },
  {
    "objectID": "lessons/02/index.html#tipi-numerici-2",
    "href": "lessons/02/index.html#tipi-numerici-2",
    "title": "Strutture di controllo e tipi di base",
    "section": "Tipi numerici",
    "text": "Tipi numerici\nI vari tipi di interi e tipi di virgola mobile si distinguono per il numero di byte usati per la loro rappresentazione in memoria e, conseguentemente, per il range di valori che possono rappresentare.\nLa dimensione di un tipo di dato, espressa in byte, e il suo range di valori dipendono dal compilatore e dall’architettura del computer. Per determinare la dimensione di un tipo di dato si può utilizzare l’operatore sizeof, mentre per conoscere il range di valori utilizzabili si possono sfruttare le librerie limits.h (per i tipi interi) e float.h (per i tipi di virgola mobile).\n#include &lt;limits.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    printf(\"size of short: %lu\\n\", sizeof(short));\n    printf(\"size of int: %lu\\n\", sizeof(int));\n    printf(\"size of double: %lu\\n\", sizeof(double));\n    printf(\"INT_MAX = %d\\n\", INT_MAX);\n    printf(\"INT_MIN = %d\\n\", INT_MIN);\n    printf(\"UINT_MAX = %u\\n\", UINT_MAX);\n    printf(\"LONG_MAX = %ld\\n\", LONG_MAX);\n    printf(\"LONG_MIN = %ld\\n\", LONG_MIN);\n    printf(\"ULONG_MAX = %lu\\n\", ULONG_MAX);\n    printf(\"SHRT_MAX = %d\\n\", SHRT_MAX);\n    printf(\"SHRT_MIN = %d\\n\", SHRT_MIN);\n    printf(\"USHRT_MAX = %u\\n\", USHRT_MAX);\n}\n\nL’esempio precedente illustra come ottenere informazioni su dimensione e range di alcuni tipi numerici in C. È importante notare come la gestione attenta di questi aspetti possa prevenire errori di overflow e underflow.",
    "crumbs": [
      "Lezioni",
      "Strutture di controllo e tipi di base"
    ]
  },
  {
    "objectID": "lessons/02/index.html#tipi-char-1",
    "href": "lessons/02/index.html#tipi-char-1",
    "title": "Strutture di controllo e tipi di base",
    "section": "Tipi char",
    "text": "Tipi char\nIl tipo char è usato per rappresentare singoli caratteri. In C, i caratteri sono trattati come piccoli interi, consentendo di eseguire operazioni aritmetiche su di loro grazie alla codifica ASCII.\nEsempio di dichiarazione:\nchar lettera = 'A';\nè essenziale usare gli apici singoli (’ ’) per denotare i valori di tipo char, distinguendoli dalle stringhe, che sono rappresentate tra virgolette doppie (” “).\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    char lettera_minuscola = 'a';\n    char lettera_maiuscola = lettera_minuscola - 32;\n    printf(\"La lettera maiuscola corrispondente è: %c\\n\", lettera_maiuscola);\n    return 0;\n}\nQuesto frammento di codice dimostra la conversione di una lettera minuscola in maiuscola sfruttando la differenza costante nei valori ASCII.\n\n\n\n\n\n\nTabella ASCII\n\n\n\nNella tabella ASCII, i valori dei caratteri alfabetici maiuscoli sono minori di quelli dei corrispondenti caratteri minuscoli, per trovare la distanza tra i due valori basta effettuare l’operazione 'A' - 'a'. Questo valore è costante e può essere usato per convertire una lettera minuscola in maiuscola e viceversa. Per maggiori dettagli si veda la tabella ASCII alla pagina del manuale linux man ascii.",
    "crumbs": [
      "Lezioni",
      "Strutture di controllo e tipi di base"
    ]
  },
  {
    "objectID": "lessons/02/index.html#conversioni-tra-tipi-1",
    "href": "lessons/02/index.html#conversioni-tra-tipi-1",
    "title": "Strutture di controllo e tipi di base",
    "section": "Conversioni tra tipi",
    "text": "Conversioni tra tipi\nIn generale, per effettuare operazioni aritmetiche tra due numeri, questi devono essere dello stesso tipo.\nIn C è possibile mescolare tipi diversi nella stessa espressione, e il compilatore effettuerà automaticamente le conversioni necessarie per eseguire l’operazione richiesta.\n\nConversioni implicite\nint a = 5;\nfloat b = 1.618;\n\na + b; // 6.618\nIn questo esempio, il valore intero a viene convertito implicitamente in virgola mobile prima di eseguire l’operazione di somma. Questo tipo di conversione è chiamato “promotion”.\nSe assegno un valore a una variabile di tipo diverso, il compilatore effettuerà una conversione implicita.\nint i = 1;\nfloat f;\nf = i; // 1.0\nf = 2; // 2.0\nÈ vero quindi anche il contrario:\nfloat f = 1.618;\nint i;\ni = f; // 3\nIn questo caso, il valore in virgola mobile viene troncato al valore intero più vicino, si noti che non viene effettuato alcun arrotondamento.\n\n\nCast espliciti\nÈ possibile convertire esplicitamente il tipo di un’ espressione con l’operazione di casting:\n(nome_tipo) espressione\nIl risultato dell’espressione viene convertito al tipo specificato.\nUn caso frequente è quando si esegue una divisione tra due interi:\nfloat quotient;\nint dividend, divisor;\nquotient = (float) dividend / divisor;\n\n\n\n\n\n\nNota\n\n\n\nIn questo caso, dividend viene convertito in float prima di eseguire la divisione, ciò comporta che divisor venga convertito implicitamente in float, infatti, come vedremo nel paragrafo successivo, l’operatore di casting ha la precedenza su quello di divisione.",
    "crumbs": [
      "Lezioni",
      "Strutture di controllo e tipi di base"
    ]
  },
  {
    "objectID": "lessons/02/index.html#tipi-di-operatori",
    "href": "lessons/02/index.html#tipi-di-operatori",
    "title": "Strutture di controllo e tipi di base",
    "section": "Tipi di Operatori",
    "text": "Tipi di Operatori\nGli operatori in C possono essere suddivisi in diverse categorie in base al tipo di operazioni che eseguono. Ogni operatore ha una priorità che determina l’ordine in cui viene valutato all’interno di un’espressione. Gli operatori con una priorità più alta vengono valutati prima degli operatori con una priorità più bassa. Nel caso di operatori della stessa priorità, l’associatività determina l’ordine di valutazione.\nEcco una tabella riassuntiva degli operatori C, ordinati da quelli con più alta priorità a quelli con minore priorità:\n\n\n\n\n\n\n\n\nCategoria\nOperatori\nAssociatività\n\n\n\n\nPostfissi\n++ -- -&gt; . () []\nSinistra-Destra\n\n\nUnari / Prefissi\n+ - ! ~ ++ -- (type) * & sizeof\nDestra-Sinistra\n\n\nMoltiplicativi\n* / %\nSinistra-Destra\n\n\nAdditivi\n+ -\nSinistra-Destra\n\n\nShift\n&lt;&lt; &gt;&gt;\nSinistra-Destra\n\n\nRelazionali\n&lt; &gt; &lt;= &gt;=\nSinistra-Destra\n\n\nUguaglianza\n== !=\nSinistra-Destra\n\n\nBitwise AND\n&\nSinistra-Destra\n\n\nBitwise XOR\n^\nSinistra-Destra\n\n\nBitwise OR\n|\nSinistra-Destra\n\n\nLogico AND\n&&\nSinistra-Destra\n\n\nLogico OR\n||\nSinistra-Destra\n\n\nCondizionale\n?:\nDestra-Sinistra\n\n\nAssegnamento\n= += -= *= /= %= &lt;&lt;= &gt;&gt;= &= ^= |=\nDestra-Sinistra\n\n\nVirgola\n,\nSinistra-Destra\n\n\n\nAlcuni operatori sono comuni a molti linguaggi di programmazione (additivi, moltiplicativi, relazionali, uguaglianza, …), altri però acquisiscono un significato specifico in C, come ad esempio l’operatore di dereferenziazione * o l’operatore di indirizzamento &. Nel corso di questa lezione ne approfondiremo alcuni, mentre altri verranno trattati successivamente.",
    "crumbs": [
      "Lezioni",
      "Strutture di controllo e tipi di base"
    ]
  },
  {
    "objectID": "lessons/02/index.html#side-effects",
    "href": "lessons/02/index.html#side-effects",
    "title": "Strutture di controllo e tipi di base",
    "section": "Side-Effects",
    "text": "Side-Effects\nGli operatori di incremento e decremento (++ e --) sono potenti ma vanno usati con cautela. Possono essere utilizzati sia come operazioni prefisse che postfix. La differenza principale tra queste due forme sta nel momento in cui viene effettuata l’operazione di incremento o decremento.\nNel caso dell’operatore di post-incremento i++, l’incremento avviene dopo che il valore di i viene utilizzato nell’espressione corrente. Nel caso dell’operatore di pre-incremento ++i, l’incremento avviene prima che il valore di i venga utilizzato nell’espressione.\nQuesto può portare a comportamenti diversi, soprattutto quando si utilizzano questi operatori all’interno della stessa espressione o dello stesso statement. Ad esempio:\nint i = 1;\nprintf(\"i is %d\\n\", i++);  // Stampa: i is 1\nprintf(\"i is %d\\n\", i);    // Stampa: i is 2\nprintf(\"i is %d\\n\", ++i);  // Stampa: i is 3\nprintf(\"i is %d\\n\", i);    // Stampa: i is 3\nNel primo printf, l’operatore post-incremento viene utilizzato, quindi il valore di i (1) viene stampato e poi incrementato a 2. Nel secondo printf, il valore incrementato di i (2) viene stampato. Nel terzo printf, l’operatore pre-incremento viene utilizzato, quindi i viene incrementato a 3 e poi stampato. Infine, nel quarto printf, viene stampato di nuovo il valore corrente di i, che è 3.\nÈ importante prestare attenzione a questi comportamenti per evitare risultati inaspettati nel proprio codice.\n\n\n\n\n\n\nNota\n\n\n\nGli altri operatori di uso frequente che comportano un side effect sono quelli di assegnamento =, +=, -= e così via. Questi operatori modificano il valore della variabile a sinistra dell’operatore.",
    "crumbs": [
      "Lezioni",
      "Strutture di controllo e tipi di base"
    ]
  },
  {
    "objectID": "lessons/02/index.html#espressioni-istruzione-1",
    "href": "lessons/02/index.html#espressioni-istruzione-1",
    "title": "Strutture di controllo e tipi di base",
    "section": "Espressioni istruzione",
    "text": "Espressioni istruzione\nTutte le espressioni possono essere anche statement: in una linea posso avere anche solo una operazione singola seguita da ;\ni = 1;      // utile\ni++;        // utile\ni * j + 2   // inutile, potrebbe dare warning\n            // \"statement with no effect\"\nNella seconda riga dell’esempio il risultato viene scartato, ma la modifica avviene lo stesso.",
    "crumbs": [
      "Lezioni",
      "Strutture di controllo e tipi di base"
    ]
  },
  {
    "objectID": "lessons/02/index.html#operatori-booleani",
    "href": "lessons/02/index.html#operatori-booleani",
    "title": "Strutture di controllo e tipi di base",
    "section": "Operatori Booleani",
    "text": "Operatori Booleani\nEcco gli operatori booleani disponibili in C:\n\n&& (AND logico)\n|| (OR logico)\n! (NOT logico)\n== (uguaglianza)\n!= (diverso)\n&gt; (maggiore)\n&lt; (minore)\n&gt;= (maggiore o uguale)\n&lt;= (minore o uguale)\n\nQuesti operatori producono tutti 0 o 1 come risultato, ma in C qualsiasi valore diverso da 0 è considerato vero.\n\n\n\n\n\n\nAvviso\n\n\n\nÈ importante ricordarsi che gli operatori bitwise (&, |, ^, ~) non sono operatori booleani, ma operatori di manipolazione dei bit. Non vanno confusi con gli operatori booleani, pertanto non vanno utilizzati per valutare espressioni booleane.\n\n\n\nAND Logico (&&)\nL’operatore && restituisce 1 se entrambe le espressioni booleane sono non-zero, altrimenti restituisce 0. È un operatore a corto circuito, quindi se il risultato è già noto dopo aver valutato la prima espressione, la seconda non viene valutata.\n\n\nOR Logico (||)\nL’operatore || restituisce 1 se almeno una delle due espressioni booleane è non-zero, altrimenti restituisce 0. Anche questo è un operatore a corto circuito.\n\n\nNOT Logico (!)\nL’operatore ! inverte il valore di verità di un’espressione. Restituisce 1 se l’espressione è zero e 0 se l’espressione è non-zero.\n\n\nOperatori di Confronto\nGli operatori di confronto (==, !=, &gt;, &lt;, &gt;=, &lt;=) confrontano due valori e restituiscono un valore intero in base alla relazione tra di essi.\n\n\n\n\n\n\nNota\n\n\n\nMentre il risultato di questi operatori è intuitivo su degli interi o float, bisogna notare che dalla parte sinistra e destra possono esserci anche char (che in C sono rappresentati come interi da un byte), che valore restituisce l’espressione 'Z' &lt; 'a'? E ':' &lt; ';'? Suggerimento: per rispondere senza scrivere codice si provi a consultare la pagina del manuale di ascii (man ascii).",
    "crumbs": [
      "Lezioni",
      "Strutture di controllo e tipi di base"
    ]
  },
  {
    "objectID": "lessons/02/index.html#valutazione-delle-espressioni-booleane",
    "href": "lessons/02/index.html#valutazione-delle-espressioni-booleane",
    "title": "Strutture di controllo e tipi di base",
    "section": "Valutazione delle Espressioni Booleane",
    "text": "Valutazione delle Espressioni Booleane\nLe espressioni booleane vengono valutate in base alle regole della logica booleana. Il risultato di un’espressione booleana è un valore intero, dove 0 rappresenta “falso” e 1 rappresenta “vero”. Ad esempio:\nint i = 3, j = 2, k = 1;\nint result = (i &lt; j && j &lt; k); // result sarà 0 perché entrambe le espressioni sono false\nIn questo caso, l’espressione i &lt; j && j &lt; k sarà valutata come 0 && 0, il che restituirà 0 perché entrambe le espressioni sono false.",
    "crumbs": [
      "Lezioni",
      "Strutture di controllo e tipi di base"
    ]
  },
  {
    "objectID": "lessons/02/index.html#il-tipo-bool",
    "href": "lessons/02/index.html#il-tipo-bool",
    "title": "Strutture di controllo e tipi di base",
    "section": "Il tipo bool",
    "text": "Il tipo bool\nCome già detto, il tipo di ritorno delle espressioni logiche in C è un intero, il tipo booleano non esiste nativamente in C. Quindi, per rappresentare valori booleani, si utilizzano valori interi, dove:\n\n\\(0 \\rightarrow\\) falso\n\\(1 \\rightarrow\\) vero (e tutti gli interi diversi da \\(0\\))\n\n\n\n\n\n\n\nNota\n\n\n\nDa C99 in poi, bool è un tipo definito in stdbool.h che può assumere solo i valori true e false.\n#include &lt;stdbool.h&gt;\nbool b = true;\nSi tratta di un tipo di dato intero, ma è considerato un tipo booleano. Ciò è possibile grazie all’uso di macro definite in stdbool.h:\n// nel file stdbool.h\n#define true 1\n#define false 0\n#define bool _Bool // _Bool è un tipo di dato intero introdotto in C99",
    "crumbs": [
      "Lezioni",
      "Strutture di controllo e tipi di base"
    ]
  },
  {
    "objectID": "lessons/02/index.html#if-else-1",
    "href": "lessons/02/index.html#if-else-1",
    "title": "Strutture di controllo e tipi di base",
    "section": "if-else",
    "text": "if-else\nL’istruzione if-else permette di eseguire un blocco di codice solo se una condizione è vera. La sintassi è la seguente:\nif (espressione) {\n    // statements\n} else {\n    // statements\n}\nSe la condizione è vera, viene eseguito il blocco di codice immediatamente successivo all’istruzione if. Altrimenti, viene eseguito il blocco di codice immediatamente successivo all’istruzione else.\n#include &lt;stdio.h&gt;\n\nint main() {\n    int x = 10;\n\n    if (x &gt; 5) {\n        printf(\"x è maggiore di 5\\n\");\n    } else {\n        printf(\"x è minore o uguale a 5\\n\");\n    }\n\n    return 0;\n}\nIl codice stampa:\nx è maggiore di 5\n\nif-else annidati\nÈ possibile annidare più istruzioni if-else all’interno di un blocco di codice.\n#include &lt;stdio.h&gt;\n\nint main() {\n    int x = 10;\n\n    if (x &gt; 5) {\n        if (x &gt; 7) {\n            printf(\"x è maggiore di 7\\n\");\n        } else {\n            printf(\"x è minore o uguale a 7\\n\");\n        }\n    } else {\n        printf(\"x è minore o uguale a 5\\n\");\n    }\n\n    return 0;\n}\nIl codice stampa:\nx è maggiore di 7\nOppure si può usare l’istruzione else if per evitare l’annidamento.\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    int x = 10;\n    if (x &gt; 7)\n    {\n        printf(\"x è maggiore di 7\\n\");\n    }\n    else if (x &gt; 5)\n    {\n        printf(\"x è maggiore di 5\\n\");\n    }\n    else\n    {\n        printf(\"x è minore o uguale a 5\\n\");\n    }\n}\n\nQuesta versione stampa lo stesso risultato della precedente, in questo caso però, il secondo if è allineato con il primo else, rendendo il codice più leggibile.\n\n\n\n\n\n\nAttenzione\n\n\n\nUn errore comune è confondere l’operatore di assegnamento = con l’operatore di confronto ==. Ad esempio, l’espressione x = 10 assegna il valore 10 alla variabile x, mentre l’espressione x == 10 confronta il valore della variabile x con 10. Se si scrive if (x = 10), l’espressione è sempre vera, perché assegna 10 alla variabile x e restituisce 10, che è considerato true. Per confrontare il valore della variabile x con 10, si deve invece scrivere if (x == 10).",
    "crumbs": [
      "Lezioni",
      "Strutture di controllo e tipi di base"
    ]
  },
  {
    "objectID": "lessons/02/index.html#if-ternario-2",
    "href": "lessons/02/index.html#if-ternario-2",
    "title": "Strutture di controllo e tipi di base",
    "section": "If ternario",
    "text": "If ternario\nL’if ternario è una forma compatta dell’istruzione if-else. La sintassi è la seguente:\nespressione ? valore_se_vera : valore_se_falsa\nSe l’espressione è vera, viene restituito valore_se_vera, altrimenti viene restituito valore_se_falsa.\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    int x = 10;\n    int y = (x &gt; 5) ? 1 : 0;\n\n    printf(\"y = %d\\n\", y);\n}\n\nQuesto modo di scrivere l’istruzione if-else è utile quando si vuole assegnare un valore a una variabile in base a una condizione con una sola riga di codice. Tuttavia, se l’espressione è complessa, l’uso dell’if ternario può rendere il codice meno leggibile. In questi casi si sconsiglia di utilizzarlo e si preferisce l’istruzione if-else standard.",
    "crumbs": [
      "Lezioni",
      "Strutture di controllo e tipi di base"
    ]
  },
  {
    "objectID": "lessons/02/index.html#switch-1",
    "href": "lessons/02/index.html#switch-1",
    "title": "Strutture di controllo e tipi di base",
    "section": "switch",
    "text": "switch\nTanti if in cascata potrebbero essere sostituiti da uno switch. La sintassi è la seguente:\nswitch (espressione) {\n    case constant-expression:\n        // statements\n        break;\n    case constant-expression:\n        // statements\n        break;\n    // ...\n    default:\n        // statements\n}\nL’espressione a fianco dell’istruzione case è senza variabili o chiamate a funzioni. L’istruzione break è necessaria per terminare il blocco di codice. Se non è presente, il controllo del flusso di esecuzione continua con il blocco di codice successivo. L’istruzione default è opzionale e viene eseguita se nessuna delle costanti corrisponde all’espressione.\nUn esempio di utilizzo dello switch è il seguente:\n#include &lt;stdio.h&gt;\n\nint main() {\n    int x = 2;\n\n    switch (x) {\n        case 1:\n            printf(\"x è 1\\n\");\n            break;\n        case 2:\n            printf(\"x è 2\\n\");\n            break;\n        default:\n            printf(\"x non è nè 1 nè 2\\n\");\n    }\n\n    return 0;\n}\n\n\n\n\n\n\nImportante\n\n\n\nLo switch può essere utilizzato solo con espressioni di tipo intero (int, char, short, long, ecc.) e con espressioni di tipo enum (che verrà trattato in seguito).",
    "crumbs": [
      "Lezioni",
      "Strutture di controllo e tipi di base"
    ]
  },
  {
    "objectID": "lessons/02/index.html#cicli-3",
    "href": "lessons/02/index.html#cicli-3",
    "title": "Strutture di controllo e tipi di base",
    "section": "Cicli",
    "text": "Cicli\nCaratteristica fondamentale di un linguaggio di programmazione sono i cicli. C implementa i classici for, while, ma anche do…while\n\nwhile (expression) { statements }\ndo { statements } while (expression)\nfor (initialization; condition; increment) { statements }\n\nQueste while e for sono equivalenti: tutto ciò che si può fare con un ciclo for si può fare con un ciclo while e viceversa. La scelta di quale istruzione utilizzare dipende dal contesto e dalla preferenza personale.\nL’istruzione do-while è simile a while, ma la condizione viene valutata alla fine del blocco di codice. Questo significa che il blocco di codice viene eseguito almeno una volta, anche se la condizione è falsa.\n\n\n\n\n\n\nNota\n\n\n\nDal C99 è possibile dichiarare variabili all’interno del ciclo for. Queste variabili sono visibili solo all’interno del ciclo. In C89 e nelle versioni precedenti, le variabili devono essere dichiarate all’inizio del blocco di codice.\nfor (int i = 0; i &lt; 10; i++) {\n    // ...\n}\n\n\n\nCicli infiniti\nUn ciclo infinito è un ciclo che non termina mai. Un ciclo infinito può essere creato utilizzando un’istruzione while con una condizione sempre vera, ad esempio while (1), oppure utilizzando un’istruzione for senza condizione, ad esempio for (;;). Un ciclo infinito può essere interrotto con un’istruzione break.\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    int i = 0;\n    while (1)\n    {\n        printf(\"%d\\n\", i);\n        i++;\n        if (i == 10)\n            break;\n    }\n}\n\n\n\nbreak e continue\nL’istruzione break termina immediatamente il ciclo in cui si trova. L’istruzione continue termina l’iterazione corrente del ciclo e passa alla successiva. Entrambe le istruzioni possono essere utilizzate all’interno di cicli for, while e do-while. L’istruzione break può essere utilizzata anche all’interno di un blocco switch per terminare immediatamente l’esecuzione del blocco.\n\n\n\n\n\n\nAvviso\n\n\n\nÈ bene non abusare di break e continue, perché possono rendere il codice meno leggibile. In generale, è meglio evitare di utilizzare break e `continue all’interno di cicli annidati.",
    "crumbs": [
      "Lezioni",
      "Strutture di controllo e tipi di base"
    ]
  },
  {
    "objectID": "lessons/02/slide.html#tipi-di-dato",
    "href": "lessons/02/slide.html#tipi-di-dato",
    "title": "Strutture di controllo e tipi di base",
    "section": "Tipi di dato",
    "text": "Tipi di dato\nLe varibili possono contenere diversi tipi di dati, i tipi di dati base in C sono:\n\ninteri: int, short, long int, unsigned short/int/long int\nvirgola mobile: float, double, long double\nchar: caratteri\n\nInoltre esiste il tipo speciale void che indica l’assenza di informazione."
  },
  {
    "objectID": "lessons/02/slide.html#tipi-numerici",
    "href": "lessons/02/slide.html#tipi-numerici",
    "title": "Strutture di controllo e tipi di base",
    "section": "Tipi numerici",
    "text": "Tipi numerici\nI vari tipi di interi e tipi di virgola mobile si distinguono per il numero di byte usati per la loro rappresentazione in memoria e, conseguentemente, per il range di valori che possono rappresentare.\n\n\n\n\n\n\nNota\n\n\nIl numero di byte usati per rappresentare un tipo di dato dipende dal compilatore e dall’architettura del computer. Per sapere quanti byte vengono usati per rappresentare un tipo di dato si può usare l’operatore sizeof.\nPer conoscere il range di valori che può rappresentare un tipo di dato si può usare la libreria limits.h per i tipi interi e float.h per i tipi di virgola mobile."
  },
  {
    "objectID": "lessons/02/slide.html#tipi-numerici-1",
    "href": "lessons/02/slide.html#tipi-numerici-1",
    "title": "Strutture di controllo e tipi di base",
    "section": "Tipi numerici",
    "text": "Tipi numerici\n#include &lt;limits.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    printf(\"size of short: %lu\\n\", sizeof(short));\n    printf(\"size of int: %lu\\n\", sizeof(int));\n    printf(\"size of double: %lu\\n\", sizeof(double));\n    printf(\"INT_MAX = %d\\n\", INT_MAX);\n    printf(\"INT_MIN = %d\\n\", INT_MIN);\n    printf(\"UINT_MAX = %u\\n\", UINT_MAX);\n    printf(\"LONG_MAX = %ld\\n\", LONG_MAX);\n    printf(\"LONG_MIN = %ld\\n\", LONG_MIN);\n    printf(\"ULONG_MAX = %lu\\n\", ULONG_MAX);\n    printf(\"SHRT_MAX = %d\\n\", SHRT_MAX);\n    printf(\"SHRT_MIN = %d\\n\", SHRT_MIN);\n    printf(\"USHRT_MAX = %u\\n\", USHRT_MAX);\n}\n\n\n\nQuando si ha a che fare con questi valori è bene stare attenti agli overflow."
  },
  {
    "objectID": "lessons/02/slide.html#tipi-char",
    "href": "lessons/02/slide.html#tipi-char",
    "title": "Strutture di controllo e tipi di base",
    "section": "Tipi char",
    "text": "Tipi char\nIl tipo char è usato per rappresentare un singolo carattere. In C i caratteri sono rappresentati come interi senza segno di 8 bit.\nI char vanno sempre scritti tra apici singoli, scrivendo un solo carattere. Il C lin interpreterà come un intero."
  },
  {
    "objectID": "lessons/02/slide.html#conversioni-tra-tipi",
    "href": "lessons/02/slide.html#conversioni-tra-tipi",
    "title": "Strutture di controllo e tipi di base",
    "section": "Conversioni tra tipi",
    "text": "Conversioni tra tipi\nIn generale, per effettuare operazioni aritmetiche tra due numeri, questi devono essere dello stesso tipo.\nIn C è possibile mescolare tipi diversi nella stessa espressione, e il compilatore effettuerà automaticamente le conversioni necessarie per eseguire l’operazione richiesta."
  },
  {
    "objectID": "lessons/02/slide.html#conversioni-implicite",
    "href": "lessons/02/slide.html#conversioni-implicite",
    "title": "Strutture di controllo e tipi di base",
    "section": "Conversioni implicite",
    "text": "Conversioni implicite\nint a = 5;\nfloat b = 1.618;\n\na + b; // 6.618\nIn questo esempio, il valore intero a viene convertito implicitamente in virgola mobile prima di eseguire l’operazione di somma. Questo tipo di conversione è chiamato “promotion”."
  },
  {
    "objectID": "lessons/02/slide.html#conversioni-implicite-1",
    "href": "lessons/02/slide.html#conversioni-implicite-1",
    "title": "Strutture di controllo e tipi di base",
    "section": "Conversioni implicite",
    "text": "Conversioni implicite\nSe assegno un valore a una variabile di tipo diverso, il compilatore effettuerà una conversione implicita.\nint i = 1;\nfloat f;\nf = i; // 1.0\nf = 2; // 2.0\nÈ vero quindi anche il contrario:\nfloat f = 1.618;\nint i;\ni = f; // 1"
  },
  {
    "objectID": "lessons/02/slide.html#cast-espliciti",
    "href": "lessons/02/slide.html#cast-espliciti",
    "title": "Strutture di controllo e tipi di base",
    "section": "Cast espliciti",
    "text": "Cast espliciti\nÈ possibile convertire esplicitamente il tipo di un’ espressione con l’operazione di casting:\n(nome_tipo) espressione\nIl risultato dell’espressione viene convertito al tipo specificato.\nUn caso frequente è quando si esegue una divisione tra due interi:\nfloat quotient;\nint dividend, divisor;\nquotient = (float) dividend / divisor;"
  },
  {
    "objectID": "lessons/02/slide.html#operatori-1",
    "href": "lessons/02/slide.html#operatori-1",
    "title": "Strutture di controllo e tipi di base",
    "section": "Operatori",
    "text": "Operatori\nEsistono molteplici operatori, ognuno ha varie caratteristiche:\n\narietà: numero di argomenti (unario, binario, ternario)\nprecedenza: ordine in cui vengono analizzati gli operatori\nassociatività: se ci sono più operatori uguali (o di uguale precedenza)\nside-effects, se presenti (cioè le variabili coinvolte vengono cambiate o no)"
  },
  {
    "objectID": "lessons/02/slide.html#operatori-2",
    "href": "lessons/02/slide.html#operatori-2",
    "title": "Strutture di controllo e tipi di base",
    "section": "Operatori",
    "text": "Operatori\nGli operatori più in alto hanno priorità più alta:"
  },
  {
    "objectID": "lessons/02/slide.html#quiz",
    "href": "lessons/02/slide.html#quiz",
    "title": "Strutture di controllo e tipi di base",
    "section": "Quiz!",
    "text": "Quiz!\nIndovina l’output del seguente codice:\ni = 1;\nprintf(\"i is %d\\n\", i++);\nprintf(\"i is %d\\n\", i);\nprintf(\"i is %d\\n\", ++i);\nprintf(\"i is %d\\n\", i);"
  },
  {
    "objectID": "lessons/02/slide.html#operatori-3",
    "href": "lessons/02/slide.html#operatori-3",
    "title": "Strutture di controllo e tipi di base",
    "section": "Operatori",
    "text": "Operatori\ni++ è il post-incremento, ++i è il pre-incremento\ni = 1;\nprintf(\"i is %d\\n\", i++); /* i is 1 */\nprintf(\"i is %d\\n\", i);   /* i is 2 */\nprintf(\"i is %d\\n\", ++i); /* i is 3 */\nprintf(\"i is %d\\n\", i);   /* i is 3 */\n\n\n\n\n\n\nDa grandi poteri derivano grandi bugs…\n\n\nGli operatori di post/pre-incremento sono molto utili e vengono usati spesso, vanno però usati con attenzione. Nella maggior parte delle situazioni è bene usare queste operazioni atomicamente (da sole in una riga)."
  },
  {
    "objectID": "lessons/02/slide.html#espressioni-istruzione",
    "href": "lessons/02/slide.html#espressioni-istruzione",
    "title": "Strutture di controllo e tipi di base",
    "section": "Espressioni istruzione",
    "text": "Espressioni istruzione\nTutte le espressioni possono essere anche statement: in una linea posso avere anche solo una operazione singola seguita da ;\ni = 1;      // utile\ni++;        // utile\ni * j + 2   // inutile, potrebbe dare warning\n            // \"statement with no effect\"\nNella seconda riga dell’esempio il risultato viene scartato, ma la modifica avviene lo stesso."
  },
  {
    "objectID": "lessons/02/slide.html#espressioni-logiche-1",
    "href": "lessons/02/slide.html#espressioni-logiche-1",
    "title": "Strutture di controllo e tipi di base",
    "section": "Espressioni logiche",
    "text": "Espressioni logiche\nAlcuni operatori ci dicono se una certa espressione è “vera” o “falsa”, ad esempio:\ni &lt; j && j &lt; k ci dice se \\(i\\) è minore sia di \\(j\\) che di \\(k\\)\n\n\n\n\n\n\nNota\n\n\n\\(i &lt; j &lt; k\\) si può scrivere ma non fa quello che sembra, in realtà: (i &lt; j) &lt; k è vero con int i=3, j=2, k=1."
  },
  {
    "objectID": "lessons/02/slide.html#bool",
    "href": "lessons/02/slide.html#bool",
    "title": "Strutture di controllo e tipi di base",
    "section": "bool",
    "text": "bool\nIl tipo di ritorno di queste espressioni in C è un intero, il tipo booleano non esiste in C (in C99 si è provato a sistemare).\n\n\\(0 \\rightarrow\\) falso\n\\(1 \\rightarrow\\) vero (e tutti gli interi diversi da \\(0\\))\n\n\n\n\n\n\n\nNota\n\n\nDa C99 in poi, bool è un tipo definito in stdbool.h che può assumere solo i valori true e false.\n#include &lt;stdbool.h&gt;\nbool b = true;"
  },
  {
    "objectID": "lessons/02/slide.html#espressioni-logiche-2",
    "href": "lessons/02/slide.html#espressioni-logiche-2",
    "title": "Strutture di controllo e tipi di base",
    "section": "Espressioni logiche",
    "text": "Espressioni logiche\nGli operatori booleani producono tutti 0 oppure 1 come risultato, ma bisogna ricordare che qualunque valore diverso da 0 è considerato vero.\nL’espressione (5 && 1) viene valutata come vera in quanto entrambi i valori sono diversi da 0"
  },
  {
    "objectID": "lessons/02/slide.html#espressioni-logiche-3",
    "href": "lessons/02/slide.html#espressioni-logiche-3",
    "title": "Strutture di controllo e tipi di base",
    "section": "Espressioni logiche",
    "text": "Espressioni logiche\n\n!expr restituisce 1 se expr è 0\nexpr1 && expr2 restituisce 1 se entrambe le espressioni sono non-zero\nexpr1 || expr2 restituisce 1 se almeno una delle due espressioni è non-zero\n\n\n\n\n\n\n\nNota\n\n\nSia && che || sono operatori a corto circuito, cioè se il risultato è già noto dopo aver valutato la prima espressione, la seconda non viene valutata."
  },
  {
    "objectID": "lessons/02/slide.html#quiz-1",
    "href": "lessons/02/slide.html#quiz-1",
    "title": "Strutture di controllo e tipi di base",
    "section": "Quiz!",
    "text": "Quiz!\nQual è il valore di verità delle seguenti espressioni?\n\n!0\n1 && 2\n1 || 0\n1 &gt; 0\n'a' &gt; 'b'\n'Z' &gt; 'a'\n':' &lt; ';'"
  },
  {
    "objectID": "lessons/02/slide.html#control-flow-1",
    "href": "lessons/02/slide.html#control-flow-1",
    "title": "Strutture di controllo e tipi di base",
    "section": "Control flow",
    "text": "Control flow\nEssendo C un linguaggio strutturato, possiede un insieme di istruzioni di controllo del flusso di esecuzione del programma. Le principali istruzioni di controllo del flusso sono:\n\n\n\nif-else\nswitch\nfor\n\n\n\nwhile\ndo-while\nbreak\ncontinue"
  },
  {
    "objectID": "lessons/02/slide.html#if-else",
    "href": "lessons/02/slide.html#if-else",
    "title": "Strutture di controllo e tipi di base",
    "section": "if-else",
    "text": "if-else\nL’istruzione if-else permette di eseguire un blocco di codice solo se una condizione è vera. La sintassi è la seguente:\nif (espressione) {\n    // statements\n} else {\n    // statements\n}"
  },
  {
    "objectID": "lessons/02/slide.html#if-else-annidati",
    "href": "lessons/02/slide.html#if-else-annidati",
    "title": "Strutture di controllo e tipi di base",
    "section": "if-else annidati",
    "text": "if-else annidati\nOppure si può usare l’istruzione else if per evitare annidamenti.\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    int x = 10;\n    if (x &gt; 7)\n    {\n        printf(\"x è maggiore di 7\\n\");\n    }\n    else if (x &gt; 5)\n    {\n        printf(\"x è maggiore di 5\\n\");\n    }\n    else\n    {\n        printf(\"x è minore o uguale a 5\\n\");\n    }\n}\n\n\n\n\n\n\n\nAttenzione\n\n\nUn errore comune è confondere l’operatore di assegnamento = con l’operatore di confronto ==. Ad esempio, l’espressione x = 10 assegna il valore 10 alla variabile x, mentre l’espressione x == 10 confronta il valore della variabile x con 10. Se si scrive if (x = 10), l’espressione è sempre vera, perché assegna 10 alla variabile x e restituisce 10, che è considerato true. Per confrontare il valore della variabile x con 10, si deve invece scrivere if (x == 10)."
  },
  {
    "objectID": "lessons/02/slide.html#if-ternario",
    "href": "lessons/02/slide.html#if-ternario",
    "title": "Strutture di controllo e tipi di base",
    "section": "If ternario",
    "text": "If ternario\nL’if ternario è una forma compatta dell’istruzione if-else. La sintassi è la seguente:\nespressione ? valore_se_vera : valore_se_falsa\nSe l’espressione è vera, viene restituito valore_se_vera, altrimenti viene restituito valore_se_falsa."
  },
  {
    "objectID": "lessons/02/slide.html#if-ternario-1",
    "href": "lessons/02/slide.html#if-ternario-1",
    "title": "Strutture di controllo e tipi di base",
    "section": "If ternario",
    "text": "If ternario\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    int x = 10;\n    int y = (x &gt; 5) ? 1 : 0;\n\n    printf(\"y = %d\\n\", y);\n}\n\nQuesto modo di scrivere l’istruzione if-else è utile quando si vuole assegnare un valore a una variabile in base a una condizione con una sola riga di codice. Se l’espressione è complessa, l’uso dell’if ternario può rendere il codice meno leggibile."
  },
  {
    "objectID": "lessons/02/slide.html#switch",
    "href": "lessons/02/slide.html#switch",
    "title": "Strutture di controllo e tipi di base",
    "section": "switch",
    "text": "switch\nTanti if in cascata potrebbero essere sostituiti da uno switch. La sintassi è la seguente:\nswitch (espressione) {\n    case constant-expression:\n        // statements\n        break;\n    case constant-expression:\n        // statements\n        break;\n    // ...\n    default:\n        // statements\n}\nLo switch può essere utilizzato solo con espressioni di tipo intero (int, char, short, long, ecc.) e con espressioni di tipo enum (che verrà trattato in seguito)."
  },
  {
    "objectID": "lessons/02/slide.html#cicli",
    "href": "lessons/02/slide.html#cicli",
    "title": "Strutture di controllo e tipi di base",
    "section": "Cicli",
    "text": "Cicli\nCaratteristica fondamentale di un linguaggio di programmazione sono i cicli. C implementa i classici for, while, ma anche do…while\n\nwhile (expression) { statements }\ndo { statements } while (expression)\nfor (initialization; condition; increment) { statements }"
  },
  {
    "objectID": "lessons/02/slide.html#cicli-1",
    "href": "lessons/02/slide.html#cicli-1",
    "title": "Strutture di controllo e tipi di base",
    "section": "Cicli",
    "text": "Cicli\nwhile e for sono equivalenti: tutto ciò che si può fare con un ciclo for si può fare con un ciclo while e viceversa. La scelta di quale istruzione utilizzare dipende dal contesto e dalla preferenza personale.\nL’istruzione do-while è simile a while, ma la condizione viene valutata alla fine del blocco di codice. Questo significa che il blocco di codice viene eseguito almeno una volta, anche se la condizione è falsa."
  },
  {
    "objectID": "lessons/02/slide.html#cicli-2",
    "href": "lessons/02/slide.html#cicli-2",
    "title": "Strutture di controllo e tipi di base",
    "section": "Cicli",
    "text": "Cicli\nDal C99 è possibile dichiarare variabili all’interno del ciclo for. Queste variabili sono visibili solo all’interno del ciclo. In C89 e nelle versioni precedenti, le variabili devono essere dichiarate all’inizio del blocco di codice.\nfor (int i = 0; i &lt; 10; i++) {\n    // ...\n}"
  },
  {
    "objectID": "lessons/02/slide.html#cicli-infiniti",
    "href": "lessons/02/slide.html#cicli-infiniti",
    "title": "Strutture di controllo e tipi di base",
    "section": "Cicli infiniti",
    "text": "Cicli infiniti\nUn ciclo infinito è un ciclo che non termina mai. Può essere creato utilizzando un’istruzione while con una condizione sempre vera o for senza condizione, ad esempio while (1) oppure for (;;).\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    int i = 0;\n    while (1)\n    {\n        printf(\"%d\\n\", i);\n        i++;\n        if (i == 10)\n            break;\n    }\n}"
  },
  {
    "objectID": "lessons/02/slide.html#break-e-continue",
    "href": "lessons/02/slide.html#break-e-continue",
    "title": "Strutture di controllo e tipi di base",
    "section": "break e continue",
    "text": "break e continue\n\nL’istruzione break termina immediatamente il ciclo in cui si trova.\nL’istruzione continue termina l’iterazione corrente del ciclo e passa alla successiva.\n\n\n\n\n\n\n\nAvviso\n\n\nÈ bene non abusare di break e continue, perché possono rendere il codice meno leggibile. In generale, è meglio evitare di utilizzare break e `continue all’interno di cicli annidati."
  },
  {
    "objectID": "lessons/02/slide.html#esercizio-fizzbuzz",
    "href": "lessons/02/slide.html#esercizio-fizzbuzz",
    "title": "Strutture di controllo e tipi di base",
    "section": "Esercizio: FizzBuzz",
    "text": "Esercizio: FizzBuzz\nScrivere un programma che stampi i numeri da 1 a 100, ma per i multipli di 3 stampi “Fizz” e per i multipli di 5 stampi “Buzz”. Per i numeri che sono sia multipli di 3 che di 5 stampi “FizzBuzz”.\n\n\n\n\n\n\nSuggerimento\n\n\nL’operatore modulo % restituisce il resto della divisione tra due numeri. Ad esempio, 5 % 3 restituisce 2, perché 5 diviso 3 dà 1 con un resto di 2.\n\n\n\n\n\n\n\nDati e Algoritmi"
  },
  {
    "objectID": "lessons/03/index.html",
    "href": "lessons/03/index.html",
    "title": "Array e Funzioni",
    "section": "",
    "text": "Introduciamo ora gli array, la prima struttura dati che affronteremo.\nGeneralmente una variabile può contenere un solo valore, spesso però si vuole eseguire operazioni su una sequenza di variabili, una soluzione è l’utilizzo di un array (o vettore). Un array è una collezione di elementi omogenei (tutti dello stesso tipo).\nLa dichiarazione di un array avviene specificando il tipo e il numero degli elementi:\nint a[10]\n\n\n\n\n\n\nConsiglio\n\n\n\nL’introduzione di costanti hardcoded produce codice difficile da rifattorizzare e mantenere, per questo, spesso, si stabilisce ad inizio programma una costante (o una macro) per scrivere un valore in un unico posto:\n#define N 10\nint a[N];\noppure:\nconst int N = 10;\nint a[N];\nnei precedenti esempi viene definita \\(N\\) ad inizio programma, nel resto del codice basterà usare questa costante quando ci si deve riferire alla dimensione dell’array \\(a\\). Qualora ci si accorgesse in futuro che 10 non sia un numero sufficiente per contenere i dati del programma, basterà cambiare una sola riga di codice.\n\n\n\nSi accede a un elemento dell’array tramite subscripting:\nint a[2];\na[0] = 1;\na[1] = 2;\nGli indici degli array in C partono da 0, come in Java.\n\n\n\n\n\n\nNota\n\n\n\nL’espressione a[i] (o simili) è un lvalue (left-value), ossia può essere usata come variabile, può quindi trovarsi a sinistra di un’assegnazione.\n\n\nIl compilatore C non controlla i limiti degli array, quindi è possibile accedere a elementi fuori dal range definito, questo può causare errori difficili da individuare.\nint a[10], i;\nfor (i = 0; i &lt;= 10; i++) {\n    a[i] = 0;\n}\nIn certi compilatori il codice sopra riportato causa un loop infinito (più spesso però genera un errore a runtime e ferma l’esecuzione).\nSi intuisce che C sia molto permissivo con il subscripting, il seguente codice quindi è perfettamente legittimo:\nint a[50];\nint i = 0, j = 3;\na[i+j*10] = 0;\n\ni = 0;\nwhile (i &lt; j)\n    a[i++] = 0;\n\n\nUn array può essere inizializzato al momento della dichiarazione:\nint a[5] = {1, 2, 3, 4, 5};\nSe si mettono meno numeri, i restanti elementi vengono inizializzati a 0 (ma questo non succede se non ne specifico nessuno!):\nint a[5] = {1, 2, 3}; // a = {1, 2, 3, 0, 0}\nint b[4] = {0}; // b = {0, 0, 0, 0}\nSe metto più elementi di quelli dichiarati il compilatore segnala un errore. Se invece si omette la dimensione dell’array, il compilatore la calcola automaticamente dalla lista di initializzazione:\nint a[] = {1, 2, 3}; // a ha dimensione 3\n\n\n\nIn C non esiste un sistema per ottenere senza sforzo la dimensione di un array, per questo, spesso, si utilizza una variabile per memorizzare la dimensione dell’array.\nTuttavia si può usare sizeof per ottenere la dimensione di un array:\nint a[10];\nsizeof(a); /* restituisce 40 su una macchina a 32 bit */\nsizeof(a[0]); /* 4 */\nsizeof(a)/sizeof(a[0]); /* 10, la dimensione dell'array */\n\n\n\nUn array può contenere elementi di qualsiasi tipo, anche altri array! Per dichiarare un array multidimensionale si specifica il numero di elementi per ogni dimensione:\nint matrix[5][9];\nPer accedere a un elemento di un array multidimensionale si usano più indici:\nmatrix[1][5] = 42; e NON matrix[1,5] = 42;",
    "crumbs": [
      "Lezioni",
      "Array e Funzioni"
    ]
  },
  {
    "objectID": "lessons/03/index.html#inizializzazione",
    "href": "lessons/03/index.html#inizializzazione",
    "title": "Array e Funzioni",
    "section": "",
    "text": "Un array può essere inizializzato al momento della dichiarazione:\nint a[5] = {1, 2, 3, 4, 5};\nSe si mettono meno numeri, i restanti elementi vengono inizializzati a 0 (ma questo non succede se non ne specifico nessuno!):\nint a[5] = {1, 2, 3}; // a = {1, 2, 3, 0, 0}\nint b[4] = {0}; // b = {0, 0, 0, 0}\nSe metto più elementi di quelli dichiarati il compilatore segnala un errore. Se invece si omette la dimensione dell’array, il compilatore la calcola automaticamente dalla lista di initializzazione:\nint a[] = {1, 2, 3}; // a ha dimensione 3",
    "crumbs": [
      "Lezioni",
      "Array e Funzioni"
    ]
  },
  {
    "objectID": "lessons/03/index.html#dimensione-di-un-array-1",
    "href": "lessons/03/index.html#dimensione-di-un-array-1",
    "title": "Array e Funzioni",
    "section": "",
    "text": "In C non esiste un sistema per ottenere senza sforzo la dimensione di un array, per questo, spesso, si utilizza una variabile per memorizzare la dimensione dell’array.\nTuttavia si può usare sizeof per ottenere la dimensione di un array:\nint a[10];\nsizeof(a); /* restituisce 40 su una macchina a 32 bit */\nsizeof(a[0]); /* 4 */\nsizeof(a)/sizeof(a[0]); /* 10, la dimensione dell'array */",
    "crumbs": [
      "Lezioni",
      "Array e Funzioni"
    ]
  },
  {
    "objectID": "lessons/03/index.html#array-multidimensionali-2",
    "href": "lessons/03/index.html#array-multidimensionali-2",
    "title": "Array e Funzioni",
    "section": "",
    "text": "Un array può contenere elementi di qualsiasi tipo, anche altri array! Per dichiarare un array multidimensionale si specifica il numero di elementi per ogni dimensione:\nint matrix[5][9];\nPer accedere a un elemento di un array multidimensionale si usano più indici:\nmatrix[1][5] = 42; e NON matrix[1,5] = 42;",
    "crumbs": [
      "Lezioni",
      "Array e Funzioni"
    ]
  },
  {
    "objectID": "lessons/03/slide.html#array-1",
    "href": "lessons/03/slide.html#array-1",
    "title": "Array e Funzioni",
    "section": "Array",
    "text": "Array\nGeneralmente una variabile può contenere un solo valore, spesso però si vuole eseguire operazioni su una sequenza di variabili, una soluzione è l’utilizzo di un array (o vettore). Un array è una collezione di elementi omogenei (tutti dello stesso tipo)."
  },
  {
    "objectID": "lessons/03/slide.html#array-2",
    "href": "lessons/03/slide.html#array-2",
    "title": "Array e Funzioni",
    "section": "Array",
    "text": "Array\nLa dichiarazione di un array avviene specificando il tipo e il numero degli elementi:\nint a[10]\nLa dimensione dell’array è una costante intera, spesso definita tramite una macro o una costante:\n#define N 10\nint a[N];\noppure:\nconst int N = 10;\nint a[N];"
  },
  {
    "objectID": "lessons/03/slide.html#array-3",
    "href": "lessons/03/slide.html#array-3",
    "title": "Array e Funzioni",
    "section": "Array",
    "text": "Array\nSi accede a un elemento dell’array tramite subscripting:\nint a[2];\na[0] = 1;\na[1] = 2;\n\nint i;\ni = a[0] + a[1]; // i = 3\nGli indici degli array in C partono da 0, come in Java."
  },
  {
    "objectID": "lessons/03/slide.html#array-e-indici",
    "href": "lessons/03/slide.html#array-e-indici",
    "title": "Array e Funzioni",
    "section": "Array e indici",
    "text": "Array e indici\nIl compilatore C non controlla i limiti degli array, quindi è possibile accedere a elementi fuori dal range definito, questo può causare errori difficili da individuare.\nint a[10], i;\nfor (i = 0; i &lt;= 10; i++) {\n    a[i] = 0;\n}\n\n\nIn certi compilatori il codice sopra riportato causa un loop infinito (più spesso però genera un errore a runtime e ferma l’esecuzione)."
  },
  {
    "objectID": "lessons/03/slide.html#array-e-indici-1",
    "href": "lessons/03/slide.html#array-e-indici-1",
    "title": "Array e Funzioni",
    "section": "Array e indici",
    "text": "Array e indici\nSi intuisce che C sia molto permissivo con il subscripting, il seguente codice quindi è perfettamente legittimo:\nint a[50];\nint i = 0, j = 3;\na[i+j*10] = 0;\n\ni = 0;\nwhile (i &lt; j)\n    a[i++] = 0;"
  },
  {
    "objectID": "lessons/03/slide.html#array-inizializzazione",
    "href": "lessons/03/slide.html#array-inizializzazione",
    "title": "Array e Funzioni",
    "section": "Array: inizializzazione",
    "text": "Array: inizializzazione\nUn array può essere inizializzato al momento della dichiarazione:\nint a[5] = {1, 2, 3, 4, 5};\nSe si mettono meno numeri, i restanti elementi vengono inizializzati a 0 (ma questo non succede se non ne specifico nessuno!):\nint a[5] = {1, 2, 3}; // a = {1, 2, 3, 0, 0}\nint b[4] = {0}; // b = {0, 0, 0, 0}"
  },
  {
    "objectID": "lessons/03/slide.html#array-inizializzazione-1",
    "href": "lessons/03/slide.html#array-inizializzazione-1",
    "title": "Array e Funzioni",
    "section": "Array: inizializzazione",
    "text": "Array: inizializzazione\nSe metto più elementi di quelli dichiarati il compilatore segnala un errore. Se invece si omette la dimensione dell’array, il compilatore la calcola automaticamente dalla lista di initializzazione:\nint a[] = {1, 2, 3}; // a ha dimensione 3"
  },
  {
    "objectID": "lessons/03/slide.html#dimensione-di-un-array",
    "href": "lessons/03/slide.html#dimensione-di-un-array",
    "title": "Array e Funzioni",
    "section": "Dimensione di un array",
    "text": "Dimensione di un array\nIn C non esiste un sistema per ottenere senza sforzo la dimensione di un array, per questo, spesso, si utilizza una variabile per memorizzare la dimensione dell’array.\nTuttavia si può usare sizeof per ottenere la dimensione di un array:\nint a[10];\nsizeof(a); /* restituisce 40 su una macchina a 32 bit */\nsizeof(a[0]); /* 4 */\nsizeof(a)/sizeof(a[0]); /* 10, la dimensione dell'array */"
  },
  {
    "objectID": "lessons/03/slide.html#array-multidimensionali",
    "href": "lessons/03/slide.html#array-multidimensionali",
    "title": "Array e Funzioni",
    "section": "Array multidimensionali",
    "text": "Array multidimensionali\nUn array può contenere elementi di qualsiasi tipo, anche altri array! Per dichiarare un array multidimensionale si specifica il numero di elementi per ogni dimensione:\nint matrix[5][9];\nPer accedere a un elemento di un array multidimensionale si usano più indici:\nmatrix[1][5] = 42; e NON matrix[1,5] = 42;"
  },
  {
    "objectID": "lessons/03/slide.html#array-multidimensionali-1",
    "href": "lessons/03/slide.html#array-multidimensionali-1",
    "title": "Array e Funzioni",
    "section": "Array multidimensionali",
    "text": "Array multidimensionali\nint matrix[5][9]; matrix[1][5] = 42;"
  },
  {
    "objectID": "lessons/03/slide.html#array-esempio-di-esercizio",
    "href": "lessons/03/slide.html#array-esempio-di-esercizio",
    "title": "Array e Funzioni",
    "section": "Array: esempio di esercizio",
    "text": "Array: esempio di esercizio\nScrivere un programma che distribuisca una mano di carte per il gioco della briscola (3 carte) e le stampi a video."
  },
  {
    "objectID": "lessons/03/slide.html#array-esercizi-1",
    "href": "lessons/03/slide.html#array-esercizi-1",
    "title": "Array e Funzioni",
    "section": "Array: esercizi (1)",
    "text": "Array: esercizi (1)\nScrivere un programma per calcolare la somma di due array di interi di dimensione 10. La soluzione si compone di 2 parti:\n\ninizializzazione di due array di interi di dimensione 10;\nsomma degli elementi dei due array e stampa del risultato."
  },
  {
    "objectID": "lessons/03/slide.html#array-esercizi-2",
    "href": "lessons/03/slide.html#array-esercizi-2",
    "title": "Array e Funzioni",
    "section": "Array: esercizi (2)",
    "text": "Array: esercizi (2)\nScrivere un programma che stampi la somma delle righe e delle colonne di una matrice \\(5 \\times 5\\) di interi.\nLa matrice è la seguente: 8 3 9 0 10 3 5 17 1 1 2 8 6 23 1 15 7 3 2 9 6 14 2 6 0\nEsempio di esecuzione:\nSomma righe: 30 27 40 36 28\nSomma colonne: 34 37 37 32 21"
  },
  {
    "objectID": "lessons/03/slide.html#funzioni-in-c",
    "href": "lessons/03/slide.html#funzioni-in-c",
    "title": "Array e Funzioni",
    "section": "Funzioni in C",
    "text": "Funzioni in C\nIn C si può pensare a una qualsiasi funzione come una scatola nera con un certo numero di ingressi e un solo output.\n\nPraticamente una funzione è un sottoprogramma, un insieme di istruzioni che esegue un compito specifico."
  },
  {
    "objectID": "lessons/03/slide.html#funzioni-sintassi",
    "href": "lessons/03/slide.html#funzioni-sintassi",
    "title": "Array e Funzioni",
    "section": "Funzioni: sintassi",
    "text": "Funzioni: sintassi\nreturn_type function_name( parameters )\n{\n    declarations\n    statements\n}\nEsempio:\ndouble average(int a, int b)\n{\n    double average;\n    average = (a + b) / 2.0;\n    return average;\n}"
  },
  {
    "objectID": "lessons/03/slide.html#funzioni-1",
    "href": "lessons/03/slide.html#funzioni-1",
    "title": "Array e Funzioni",
    "section": "Funzioni",
    "text": "Funzioni\nIl valore di ritorno può non esserci, anche i parametri possono essere void oppure si possono omettere:\nvoid print_hello(void)\n{\n    printf(\"Hello, world!\\n\");\n    return;\n}\n\n\n\n\n\n\nNota\n\n\nL’istruzione return può essere omessa in una funzione void."
  },
  {
    "objectID": "lessons/03/slide.html#dichiarazione-e-definizione",
    "href": "lessons/03/slide.html#dichiarazione-e-definizione",
    "title": "Array e Funzioni",
    "section": "Dichiarazione e definizione",
    "text": "Dichiarazione e definizione\nLe funzioni possono essere dichiarate e definite in due momenti diversi del programma.\nLa dichiarazione di una funzione è una promessa che il programmatore fa al compilatore: “presto ti dirò cosa fa questa funzione”.\nLa sintassi della dichiarazione è la stessa della definizione, ma senza il corpo della funzione:\nreturn_type function_name( parameters );"
  },
  {
    "objectID": "lessons/03/slide.html#dichiarazione-e-definizione-1",
    "href": "lessons/03/slide.html#dichiarazione-e-definizione-1",
    "title": "Array e Funzioni",
    "section": "Dichiarazione e definizione",
    "text": "Dichiarazione e definizione\nEsempio:\n#include &lt;stdio.h&gt;\n\nint sum(int a, int b); // dichiarazione\n\nint main(void)\n{\n    int x = 3, y = 4;\n    int z = sum(x, y);\n    printf(\"La somma di %d e %d è %d\\n\", x, y, z);\n    return 0;\n}\n\nint sum(int a, int b) // definizione\n{\n    return a + b;\n}"
  },
  {
    "objectID": "lessons/03/slide.html#argomenti-di-funzione",
    "href": "lessons/03/slide.html#argomenti-di-funzione",
    "title": "Array e Funzioni",
    "section": "Argomenti di funzione",
    "text": "Argomenti di funzione\nGli argomenti possono anche essere degli array, mentre il tipo di ritorno no.\nSe si passa un array come argomento, si può omettere la sua dimensione, ma in tal caso non sarà possibile conoscere la dimensione dell’array all’interno della funzione, per questo spesso si passa anche la dimensione dell’array come argomento."
  },
  {
    "objectID": "lessons/03/slide.html#esercizi",
    "href": "lessons/03/slide.html#esercizi",
    "title": "Array e Funzioni",
    "section": "Esercizi",
    "text": "Esercizi\n\nScrivere una funzione che trovi il valore minimo in un array di numeri interi la firma della funzione è int array_min(int arr[], int size).\nScrivere una funzione ricorsiva per sommare gli elementi di un array di double, la firma della funzione è double array_sum(double arr[], int size).\nScrivere una funzione ricorsiva che, dato un array di caratteri, ne stampi il contenuto su standard output. La firma della funzione è void print_string(char arr[], int size).\nModificare la soluzione dell’esercizio precedente per stampare l’array in ordine inverso. Implementare poi una soluzione non ricorsiva allo stesso problema.\nScrivere una funzione ricorsiva all che, dato un array di interi, restituisca true se tutti gli elementi dell’array sono diversi da 0, false altrimenti.\n\n\n\n\n\nDati e Algoritmi"
  },
  {
    "objectID": "lessons/04/index.html",
    "href": "lessons/04/index.html",
    "title": "Puntatori",
    "section": "",
    "text": "Il termine puntatore produce sempre un po’ di confusione tra i principianti del C, in realtà, una volta capito il concetto, si tratta di una feature molto potente e utile del linguaggio. Non sono effettivamente complicati, ma è facile fare confusione, spero che questa guida possa aiutare a chiarire le idee…\nQuando si dichiara una variabile si comunica al compilatore il suo tipo e il suo nome prima del suo utilizzo, questo è fondamentale perché la dichiarazione permette al compilatore di allocare un blocco di memoria per immagazzinare la variabile. Quindi:",
    "crumbs": [
      "Lezioni",
      "Puntatori"
    ]
  },
  {
    "objectID": "lessons/04/index.html#esempio-di-utilizzo",
    "href": "lessons/04/index.html#esempio-di-utilizzo",
    "title": "Puntatori",
    "section": "Esempio di utilizzo",
    "text": "Esempio di utilizzo\nSpesso un esempio chiarisce meglio il concetto, di seguito si introducono due esempi per chiarire il concetto di puntatore, e la sintassi\n1int i, j, *p;\n2i = 5;\n3p = &i;\n4j = *p;\n5printf(\"%d\\n\", j); // stampa 5\n\n1\n\nSi dichiarano tre variabili: i, j e p, p è un puntatore a un intero.\n\n2\n\nSi assegna il valore 5 a i.\n\n3\n\nSi assegna l’indirizzo di i a p, l’operatore & è usato per ottenere l’indirizzo di i.\n\n4\n\nSi assegna il valore puntato da p a j, l’operatore * è usato per accedere al valore puntato da p.\n\n5\n\nSi stampa il valore di j, che è 5.\n\n\n// esempio 2\nint *p, *q, i;\np = &i;\n*p = 6;\nq = p;\n(*q)++;\nprintf(\"%d\\n\", i); // stampa 7\nIl secondo esempio è un po’ più complesso, ma il concetto è lo stesso. Si dichiarano due puntatori p e q e una variabile i. Si assegna l’indirizzo di i a p, si assegna il valore 6 a i tramite *p, si assegna p a q e si incrementa il valore puntato da q di 1. L’espressione (*q)++ è equivalente a *q = *q + 1, servono le parentesi perché l’operatore ++ ha una precedenza maggiore rispetto all’operatore *.",
    "crumbs": [
      "Lezioni",
      "Puntatori"
    ]
  },
  {
    "objectID": "lessons/04/index.html#esempio-di-utilizzo-di-puntatori-con-funzioni",
    "href": "lessons/04/index.html#esempio-di-utilizzo-di-puntatori-con-funzioni",
    "title": "Puntatori",
    "section": "Esempio di utilizzo di puntatori con funzioni",
    "text": "Esempio di utilizzo di puntatori con funzioni\nScrivere una funzione che scambi il valore di due variabili.\nIl prototipo della funzione è: void swap(int *a, int *b);\nVerrebbe spontaneo risolvere il problema senza usare i puntatori:\nvoid swap(int a, int b) {\n1    int temp = a;\n2    a = b;\n3    b = temp;\n    printf(\"a = %d, b = %d\\n\", a, b);\n}\n\n1\n\nSi salva il valore di a in una variabile temporanea.\n\n2\n\nSi assegna il valore di b a a.\n\n3\n\nSi assegna il valore salvato in precedenza a b.\n\n\nAll’ultima riga il codice effettivamente ha scambiato i valori di a e b, ma si tratta di variabili locali alla funzione, quindi i valori di a e b all’esterno della funzione non sono stati modificati. Per rendere la modifica permanente si devono usare i puntatori:\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n    printf(\"a = %d, b = %d\\n\", *a, *b);\n}\nLa soluzione è identica alla precedente, ma questa volta i valori di a e b vengono modificati direttamente, ciò vuol dire che i valori di a e b all’esterno della funzione saranno modificati.",
    "crumbs": [
      "Lezioni",
      "Puntatori"
    ]
  },
  {
    "objectID": "lessons/04/index.html#esercizio",
    "href": "lessons/04/index.html#esercizio",
    "title": "Puntatori",
    "section": "Esercizio",
    "text": "Esercizio\nScrivere una funzione che trovi il minimo e il massimo in un array di interi.\nIl prototipo della funzione è: void minmax(const int *a, int n, int *min, int *max);\n Scarica la soluzione",
    "crumbs": [
      "Lezioni",
      "Puntatori"
    ]
  },
  {
    "objectID": "lessons/04/slide.html#la-memoria",
    "href": "lessons/04/slide.html#la-memoria",
    "title": "Puntatori",
    "section": "La memoria",
    "text": "La memoria\nLa memoria è divisa in celle della dimensione di un byte e ogni byte ha un proprio indirizzo.\nOgni variabile è composta da un numero specifico di byte contigui (sizeof serve proprio a conoscere lo spazio in memoria di una variabile)."
  },
  {
    "objectID": "lessons/04/slide.html#indirizzi-di-memoria",
    "href": "lessons/04/slide.html#indirizzi-di-memoria",
    "title": "Puntatori",
    "section": "Indirizzi di memoria",
    "text": "Indirizzi di memoria"
  },
  {
    "objectID": "lessons/04/slide.html#variabili-in-memoria",
    "href": "lessons/04/slide.html#variabili-in-memoria",
    "title": "Puntatori",
    "section": "Variabili in memoria",
    "text": "Variabili in memoria\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    int n = 50;\n    printf(\"%d\\n\", n);\n}"
  },
  {
    "objectID": "lessons/04/slide.html#variabili-in-memoria-1",
    "href": "lessons/04/slide.html#variabili-in-memoria-1",
    "title": "Puntatori",
    "section": "Variabili in memoria",
    "text": "Variabili in memoria"
  },
  {
    "objectID": "lessons/04/slide.html#variabili-in-memoria-2",
    "href": "lessons/04/slide.html#variabili-in-memoria-2",
    "title": "Puntatori",
    "section": "Variabili in memoria",
    "text": "Variabili in memoria\nPer conoscere l’indirizzo nella memoria di una variabile è possibile utilizzare l’operatore &:\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    int n = 50;\n    printf(\"%p\\n\", &n);\n}\n\n\n\n\n\n\nNota\n\n\nSi noti che %p che permette di visualizzare l’indirizzo di una locazione in memoria. &n può essere letteralmente tradotto come “l’indirizzo di n”. Eseguendo questo codice si otterrà un indirizzo di memoria che inizia con 0x."
  },
  {
    "objectID": "lessons/04/slide.html#puntatori-1",
    "href": "lessons/04/slide.html#puntatori-1",
    "title": "Puntatori",
    "section": "Puntatori",
    "text": "Puntatori\n\nUn puntatore è una variabile che contiene l’informazione per accedere ad un’altra variabile, ossia il suo indirizzo.\n\nRiassunto:\nAd ogni variabile è associato un indirizzo di memoria. Questo indirizzo è un numero che identifica la posizione della variabile in memoria. Un puntatore contiene questo numero."
  },
  {
    "objectID": "lessons/04/slide.html#puntatori-2",
    "href": "lessons/04/slide.html#puntatori-2",
    "title": "Puntatori",
    "section": "Puntatori",
    "text": "Puntatori\nÈ possibile compiere operazioni con questi puntatori, di fatto sono un nuovo tipo di variabile detta variabile puntatore.\nPer dichiarare un puntatore si usa il simbolo *:\nint *p;\nin questo caso p è un puntatore che punta ad una variabile di tipo int.\nint n = 50;\nint *p = &n;"
  },
  {
    "objectID": "lessons/04/slide.html#puntatori-operatori",
    "href": "lessons/04/slide.html#puntatori-operatori",
    "title": "Puntatori",
    "section": "Puntatori: operatori",
    "text": "Puntatori: operatori\nEsistono due operatori che si possono usare con i puntatori:\n\n& restituisce l’indirizzo di memoria di una variabile\n* restituisce il valore puntato da un puntatore\n\nint i, j, *p;\n// ...\np = &i; // il valore di p è l'indirizzo di i\nj = *p; // il valore di j è il valore puntato da p"
  },
  {
    "objectID": "lessons/04/slide.html#puntatori-3",
    "href": "lessons/04/slide.html#puntatori-3",
    "title": "Puntatori",
    "section": "Puntatori",
    "text": "Puntatori\n#include &lt;stdio.h&gt;\nint main(void)\n{\n    int n = 50;\n    int *p = &n;\n    printf(\"%d\\n\", p); // stampa l'indirizzo di n\n    printf(\"%d\\n\", *p); // stampa il valore di n\n}"
  },
  {
    "objectID": "lessons/04/slide.html#puntatori-4",
    "href": "lessons/04/slide.html#puntatori-4",
    "title": "Puntatori",
    "section": "Puntatori",
    "text": "Puntatori"
  },
  {
    "objectID": "lessons/04/slide.html#puntatori-5",
    "href": "lessons/04/slide.html#puntatori-5",
    "title": "Puntatori",
    "section": "Puntatori",
    "text": "Puntatori"
  },
  {
    "objectID": "lessons/04/slide.html#puntatori-6",
    "href": "lessons/04/slide.html#puntatori-6",
    "title": "Puntatori",
    "section": "Puntatori",
    "text": "Puntatori\nSi possono dichiarare insieme ad altre variabili:\nint *p, x, *y, a[10];\nQualsiasi tipo può essere usato."
  },
  {
    "objectID": "lessons/04/slide.html#puntatori-attenzione",
    "href": "lessons/04/slide.html#puntatori-attenzione",
    "title": "Puntatori",
    "section": "Puntatori: attenzione!",
    "text": "Puntatori: attenzione!\n\nApplicare l’operatore * ad un puntatore non inizializzato è un errore:\n\nint *p;\nprintf(\"%d\\n\", *p); // errore!\n\nAssegnare un valore a un puntatore non inizializzato è un errore:\n\nint *p; // p non è inizializzato\n*p = 5; // errore!"
  },
  {
    "objectID": "lessons/04/slide.html#puntatori-esempio",
    "href": "lessons/04/slide.html#puntatori-esempio",
    "title": "Puntatori",
    "section": "Puntatori: esempio",
    "text": "Puntatori: esempio\n// esempio 1\nint i, j, *p;\ni = 5;\np = &i;\nj = *p;\nprintf(\"%d\\n\", j); // stampa 5\n\n// -----------------------------\n// esempio 2\nint *p, *q, i;\np = &i;\n*p = 6;\nq = p;\n(*q)++;\nprintf(\"%d\\n\", i); // stampa 7"
  },
  {
    "objectID": "lessons/04/slide.html#puntatori-e-funzioni",
    "href": "lessons/04/slide.html#puntatori-e-funzioni",
    "title": "Puntatori",
    "section": "Puntatori e funzioni",
    "text": "Puntatori e funzioni\nIn C non è possibile restituire più di un valore da una funzione.\nvoid incrementa(int a, int b) {\n    a++;\n    b++;\n    // alla fine della funzione i valori di a e b vengono persi\n}\nI puntatori permettono di aggirare questa limitazione. Possono essere passati come argomenti di funzioni:\nvoid incrementa(int *a, int *b) {\n    *a = *a + 1;\n    *b = *b + 1;\n}\nCi si basa unicamente sui side effects, è possibile quindi restituire più di un valore."
  },
  {
    "objectID": "lessons/04/slide.html#puntatori-e-funzioni-1",
    "href": "lessons/04/slide.html#puntatori-e-funzioni-1",
    "title": "Puntatori",
    "section": "Puntatori e funzioni",
    "text": "Puntatori e funzioni\nLa chiamata di funzione avviene così:\nint i = 1;\nint j = 10;\nincrementa(&i, &j);\nprintf(\"%d\\n\", i); // stampa 2\nprintf(\"%d\\n\", j); // stampa 11\nAbbiamo già visto questa sintassi con scanf."
  },
  {
    "objectID": "lessons/04/slide.html#puntatori-esercizi-1",
    "href": "lessons/04/slide.html#puntatori-esercizi-1",
    "title": "Puntatori",
    "section": "Puntatori: esercizi (1)",
    "text": "Puntatori: esercizi (1)\nScrivere una funzione che scambi il valore di due variabili.\nIl prototipo della funzione è:\nvoid swap(int *a, int *b);"
  },
  {
    "objectID": "lessons/04/slide.html#puntatori-e-array",
    "href": "lessons/04/slide.html#puntatori-e-array",
    "title": "Puntatori",
    "section": "Puntatori e array",
    "text": "Puntatori e array\nIn realtà, in C, un array è un puntatore al primo elemento dell’array.\nint a[10];\na è un puntatore al primo elemento dell’array.\nL’operatore [] permette di scorrere la memoria a partire dal primo elemento dell’array."
  },
  {
    "objectID": "lessons/04/slide.html#puntatori-e-array-1",
    "href": "lessons/04/slide.html#puntatori-e-array-1",
    "title": "Puntatori",
    "section": "Puntatori e array",
    "text": "Puntatori e array\nGli array possono quindi essere trattati come puntatori:\nint a[10], *p;\np = a;\np punta al primo elemento dell’array."
  },
  {
    "objectID": "lessons/04/slide.html#puntatori-e-array-2",
    "href": "lessons/04/slide.html#puntatori-e-array-2",
    "title": "Puntatori",
    "section": "Puntatori e array",
    "text": "Puntatori e array\nGli elementi dell’array si trovano in posizioni di memoria contigue.\nQuindi l’operazione p + 1 punta al secondo elemento dell’array.\nint a[] = {1, 2, 3, 4, 5};\nint *p = a;\n\np + 1; // è l'indirizzo del secondo elemento dell'array\np + 2; // è l'indirizzo del terzo elemento dell'array\n// per accedere al valore si usa *p\n*(p + 1); // è il valore del secondo elemento dell'array\np[1]; // è il valore del secondo elemento dell'array"
  },
  {
    "objectID": "lessons/04/slide.html#puntatori-e-array-3",
    "href": "lessons/04/slide.html#puntatori-e-array-3",
    "title": "Puntatori",
    "section": "Puntatori e array",
    "text": "Puntatori e array\n\n\n\n\n\n\nNota\n\n\nC capisce da solo che p è un puntatore ad un array di interi, quindi p + 1 punta al secondo elemento dell’array che si trova dopo un salto di 4 byte (la dimensione di un intero)."
  },
  {
    "objectID": "lessons/04/slide.html#puntatori-e-array-4",
    "href": "lessons/04/slide.html#puntatori-e-array-4",
    "title": "Puntatori",
    "section": "Puntatori e array",
    "text": "Puntatori e array\nint a[10], *p;\np = a;\nfor (int i = 0; i &lt; 10; i++) {\n    *(p + i) = i;\n    // oppure\n    // p[i] = i;\n}\nLa sintassi p[i] è uno zucchero sintattico per *(p + i)."
  },
  {
    "objectID": "lessons/04/slide.html#puntatori-esercizi-2",
    "href": "lessons/04/slide.html#puntatori-esercizi-2",
    "title": "Puntatori",
    "section": "Puntatori: esercizi (2)",
    "text": "Puntatori: esercizi (2)\nScrivere una funzione che trovi il minimo e il massimo in un array di interi.\nIl prototipo della funzione è:\nvoid minmax(const int *a, int n, int *min, int *max);"
  },
  {
    "objectID": "lessons/04/slide.html#puntatori-di-puntatori",
    "href": "lessons/04/slide.html#puntatori-di-puntatori",
    "title": "Puntatori",
    "section": "Puntatori di puntatori?",
    "text": "Puntatori di puntatori?\nUn puntatore può puntare ad un altro puntatore.\nint i = 5;\nint *p = &i;\nint **q = &p;\nPuò sembrare strano, ma è una pratica molto comune."
  },
  {
    "objectID": "lessons/04/slide.html#puntatori-di-puntatori-1",
    "href": "lessons/04/slide.html#puntatori-di-puntatori-1",
    "title": "Puntatori",
    "section": "Puntatori di puntatori?",
    "text": "Puntatori di puntatori?\nLe stringhe in C sono array di caratteri terminati da un carattere nullo.\nchar s[] = \"Hi!\";\n// char *s = \"Hi!\";\ns è un puntatore al primo carattere della stringa."
  },
  {
    "objectID": "lessons/04/slide.html#puntatori-di-puntatori-2",
    "href": "lessons/04/slide.html#puntatori-di-puntatori-2",
    "title": "Puntatori",
    "section": "Puntatori di puntatori?",
    "text": "Puntatori di puntatori?"
  },
  {
    "objectID": "lessons/04/slide.html#puntatori-di-puntatori-3",
    "href": "lessons/04/slide.html#puntatori-di-puntatori-3",
    "title": "Puntatori",
    "section": "Puntatori di puntatori?",
    "text": "Puntatori di puntatori?\nIl caso più comune di puntatore a puntatore è quello delle stringhe.\nQuando si deve memorizzare un array di stringhe si usa un array di puntatori a caratteri.\nint main(int argc, char **argv) {\n    // argv è un array di puntatori a caratteri\n}\n// oppure\nint main(int argc, char *argv[]) {\n    // argv è un array di puntatori a caratteri\n}\n\n\n\n\nDati e Algoritmi"
  },
  {
    "objectID": "lessons/05/slide.html#strutture-in-c",
    "href": "lessons/05/slide.html#strutture-in-c",
    "title": "Uso avanzato dei puntatori",
    "section": "Strutture in C",
    "text": "Strutture in C\nIl C non permette di definire Classi e oggetti, si possono comunque definire dei tipi aggiuntivi per aggregare dati:\n\nStrutture: insieme di dati\nUnioni: alternative tra tipi diversi\nEnumerazioni: insieme di costanti"
  },
  {
    "objectID": "lessons/05/slide.html#struct",
    "href": "lessons/05/slide.html#struct",
    "title": "Uso avanzato dei puntatori",
    "section": "struct",
    "text": "struct\nUna struttura è un insieme di dati, si differenzia dagli array perché:\n\ngli elementi possono essere di tipo diverso\ngli elementi sono identificati da un nome\n\nstruct studente {\n    char nome[20];\n    char cognome[20];\n    int matricola;\n};"
  },
  {
    "objectID": "lessons/05/slide.html#inizializzazione",
    "href": "lessons/05/slide.html#inizializzazione",
    "title": "Uso avanzato dei puntatori",
    "section": "Inizializzazione",
    "text": "Inizializzazione\nSi possono inizializzare le strutture quando vengono dichiarate:\nstruct studente s = {\"Mario\", \"Rossi\", 12345};\nSi possono inizializzare meno elementi rispetto a quelli dichiarati, in questo caso gli elementi non inizializzati vengono impostati a 0.\nUn modo alternativo di inizializzare:\nstruct studente s = {\n    .nome = \"Mario\",\n    .cognome = \"Rossi\",\n    .matricole = 12345,\n};"
  },
  {
    "objectID": "lessons/05/slide.html#accedere-agli-elementi",
    "href": "lessons/05/slide.html#accedere-agli-elementi",
    "title": "Uso avanzato dei puntatori",
    "section": "Accedere agli elementi",
    "text": "Accedere agli elementi\nPer accedere ai singoli elementi di una struttura (detti anche membri) si usa l’operatore . (punto) dopo il nome della variabile:\nstruct studente s = {\"Mario\", \"Rossi\", 12345};\n\nprintf(\"Nome: %s\\n\", s.nome);\nprintf(\"Cognome: %s\\n\", s.cognome);\ns.matricola = 54321;"
  },
  {
    "objectID": "lessons/05/slide.html#copie-di-strutture",
    "href": "lessons/05/slide.html#copie-di-strutture",
    "title": "Uso avanzato dei puntatori",
    "section": "Copie di strutture",
    "text": "Copie di strutture\nSi può copiare interamente una struttura usando una variabile dello stesso tipo:\nstruct studente a, b = {\"Matteo\", \"Spanio\", 56789};\na = b;\n\n\n\n\n\n\nImportante\n\n\nSolo l’operatore = è valido tra 2 struct, gli operatori == e != NON si possono usare per vedere se due strutture sono uguali."
  },
  {
    "objectID": "lessons/05/slide.html#dare-i-nomi-alle-strutture",
    "href": "lessons/05/slide.html#dare-i-nomi-alle-strutture",
    "title": "Uso avanzato dei puntatori",
    "section": "Dare i nomi alle strutture",
    "text": "Dare i nomi alle strutture\nLe stutture possono avere un nome, gli si può associare un tipo, oppure possono essere anonime.\nLe strutture col nome, detto structure tag, si dichiarano come abbiamo già visto:\nstruct nome {\n    type member_name;\n};\n\n\n\n\n\n\nAvviso\n\n\nIl tipo di una variabile struct è struct nome_struct, omettere la parola struct è un errore."
  },
  {
    "objectID": "lessons/05/slide.html#strutture-anonime",
    "href": "lessons/05/slide.html#strutture-anonime",
    "title": "Uso avanzato dei puntatori",
    "section": "Strutture anonime",
    "text": "Strutture anonime\nNel caso in cui un si voglia usare una struct solo in un punto specifico del codice non è necessario associarvi un nome, si può dichiarare e associare direttamente:\nstruct { int x; int y; } punto;\npunto.x = 12;\npunto.y = 18;"
  },
  {
    "objectID": "lessons/05/slide.html#typedef",
    "href": "lessons/05/slide.html#typedef",
    "title": "Uso avanzato dei puntatori",
    "section": "typedef",
    "text": "typedef\ntypedef è un operatore che permette di definire alias per i tipi:\ntypedef int Bool;\ntypedef float Euro;\ntypedef char* String;\nQueste dichiarazioni permettono scrivere codice più chiaro."
  },
  {
    "objectID": "lessons/05/slide.html#strutture-con-typedef",
    "href": "lessons/05/slide.html#strutture-con-typedef",
    "title": "Uso avanzato dei puntatori",
    "section": "Strutture con typedef",
    "text": "Strutture con typedef\nDal momento che le strutture sono usate moltissimo e i programmatori sono pigri, solitamente, si preferisce omettere la parola chiave struct per riferirsi al tipo delle strutture grazie a typedef:\ntypedef struct {\n    int x;\n    int y;\n} Point;\nPoint punto = {\n    .x = 1,\n    .y = 2,\n};"
  },
  {
    "objectID": "lessons/05/slide.html#cast-a-strutture",
    "href": "lessons/05/slide.html#cast-a-strutture",
    "title": "Uso avanzato dei puntatori",
    "section": "Cast a strutture",
    "text": "Cast a strutture\nUna volta definito il tipo con typedef, si può popolare una struttura con la stessa sintassi dell’inizializzazione, occorre fare un cast esplicito però:\ntypedef struct {\n    int x;\n    int y;\n} Point;\n\nPoint s;\ns = (Point) { .x = 1, .y = 2 };"
  },
  {
    "objectID": "lessons/05/slide.html#struct-1",
    "href": "lessons/05/slide.html#struct-1",
    "title": "Uso avanzato dei puntatori",
    "section": "struct",
    "text": "struct\nA prescindere da quale metodo di definizione si scelga, le strutture possono essere argomenti di funzioni e restituite da funzioni:\n#include &lt;math.h&gt;\ntypedef struct point {\n    int x;\n    int y;\n} Point;\n\nPoint somma(Point a, struct point b) {\n    return (Point) { .x = a.x + b.x, .y = a.y + b.y };\n}\n\nfloat distanza(Point a, Point b) {\n    return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));\n}"
  },
  {
    "objectID": "lessons/05/slide.html#struct-e-puntatori",
    "href": "lessons/05/slide.html#struct-e-puntatori",
    "title": "Uso avanzato dei puntatori",
    "section": "struct e puntatori",
    "text": "struct e puntatori\nSi possono creare puntatori a strutture (come per qualsiasi altro tipo di dato):\nstruct point *p;\nPoint *p1;\n\nvoid foo(Point* p);"
  },
  {
    "objectID": "lessons/05/slide.html#struct-2",
    "href": "lessons/05/slide.html#struct-2",
    "title": "Uso avanzato dei puntatori",
    "section": "struct",
    "text": "struct\n\nSi possono creare array di strutture:\n\nPoint punti[10];\npunti[0].x = 1;\n\nInserire un array in una struttura\nInserire una struttura in un’altra struttura\nInserire unioni in una struttura\nInserire strutture in unioni"
  },
  {
    "objectID": "lessons/05/slide.html#esempio",
    "href": "lessons/05/slide.html#esempio",
    "title": "Uso avanzato dei puntatori",
    "section": "Esempio",
    "text": "Esempio\nSi vuole creare un sistema informatico per la gestione squadra della nazionale Italiana di calcio che giocò ai mondiali del 1982:\n\nimplementare una struttura dati per memorizzare i dati di un giocatore di calcio;\nmemorizzare l’elenco dei giocatori della squadra;\nordinare i giocatori in base numero di maglia."
  },
  {
    "objectID": "lessons/05/slide.html#memorizzare-un-giocatore",
    "href": "lessons/05/slide.html#memorizzare-un-giocatore",
    "title": "Uso avanzato dei puntatori",
    "section": "Memorizzare un giocatore",
    "text": "Memorizzare un giocatore\nAi fini della classifica è necessario memorizzare il nome della squadra e i punti ottenuti:\n#define BUFFER_SIZE 128\ntypedef struct giocatore\n{\n    char nome[BUFFER_SIZE];\n    char cognome[BUFFER_SIZE];\n    unsigned int numero_maglia; // non esistono numeri di maglia negativi\n} Giocatore;"
  },
  {
    "objectID": "lessons/05/slide.html#memorizzare-la-lista-dei-giocatori",
    "href": "lessons/05/slide.html#memorizzare-la-lista-dei-giocatori",
    "title": "Uso avanzato dei puntatori",
    "section": "Memorizzare la lista dei giocatori",
    "text": "Memorizzare la lista dei giocatori\nLa struct Giocatore è di fatto un tipo di dato, possiamo quindi creare un array di esami dove memorizzare la formazione:\n#define NUM 22\nGiocatore squadra[NUM];"
  },
  {
    "objectID": "lessons/05/slide.html#ordinare-i-giocatori",
    "href": "lessons/05/slide.html#ordinare-i-giocatori",
    "title": "Uso avanzato dei puntatori",
    "section": "Ordinare i giocatori",
    "text": "Ordinare i giocatori\nPer ordinare i giocatori in base al numero di maglia, bisogna introdurre un algoritmo di ordinamento:\nIl più intuitivo, ma non il più efficiente, è il Bubble Sort:\n\nScarica l’esempio completo"
  },
  {
    "objectID": "lessons/05/slide.html#unioni",
    "href": "lessons/05/slide.html#unioni",
    "title": "Uso avanzato dei puntatori",
    "section": "Unioni",
    "text": "Unioni\n\nLe unioni sono simili alle strutture, nel senso che permettono di usare membri di tipo diverso\nLa differenza è che una struttura tiene tutti i membri in memoria, mentre una union tiene solo un membro alla volta\n\nunion {\n    int i;\n    double d;\n} u;\n\nstruct {\n    int i;\n    double d;\n} s;"
  },
  {
    "objectID": "lessons/05/slide.html#unioni-1",
    "href": "lessons/05/slide.html#unioni-1",
    "title": "Uso avanzato dei puntatori",
    "section": "Unioni",
    "text": "Unioni\nSi può inizializzare solo un elemento di una union:\nunion {\n    int i;\n    double d;\n} u = { .i = 3 };\n\nu.d = 5.7\nCome per le strutture, posso dare nomi alle unioni tramite tag oppure con typedef."
  },
  {
    "objectID": "lessons/05/slide.html#enumerazioni",
    "href": "lessons/05/slide.html#enumerazioni",
    "title": "Uso avanzato dei puntatori",
    "section": "Enumerazioni",
    "text": "Enumerazioni\nIn molti programmi si usano interi come “codici” per indicare varie cose. Un caso comune sono per esempio i codici di errore.\nSpesso si usano macro o costanti, ma è più chiaro usare enumerazioni:\nenum {CUORI, QUADRI, FIORI, PICCHE} s1, s2;\nOra le variabili s1 e s2 possono assumere solo uno dei quattro valori definiti."
  },
  {
    "objectID": "lessons/05/slide.html#strutture-dati-1",
    "href": "lessons/05/slide.html#strutture-dati-1",
    "title": "Uso avanzato dei puntatori",
    "section": "Strutture dati",
    "text": "Strutture dati\nLe strutture sono molto utili per definire… strutture dati.\nPer esempio si possono definire array dinamici, liste concatenate, alberi, pile, code…"
  },
  {
    "objectID": "lessons/05/slide.html#array-con-strutture",
    "href": "lessons/05/slide.html#array-con-strutture",
    "title": "Uso avanzato dei puntatori",
    "section": "Array con strutture",
    "text": "Array con strutture\nGli array in C sono molto limitati, infatti dobbiamo gestire la loro lunghezza a mano…\nSi può creare una struttura che contenga un array e la sua lunghezza:\n#define MAX 1024\n\ntypedef struct intarray {\n    int array[MAX];\n    int length;\n} IntArray;"
  },
  {
    "objectID": "lessons/05/slide.html#array-con-strutture-1",
    "href": "lessons/05/slide.html#array-con-strutture-1",
    "title": "Uso avanzato dei puntatori",
    "section": "Array con strutture",
    "text": "Array con strutture\nAdesso si può passare la struttura come argomento di una funzione:\nvoid stampa_array(IntArray a) {\n    for (int i = 0; i &lt; a.length; i++) {\n        printf(\"%d \", a.array[i]);\n    }\n    printf(\"\\n\");\n}\nSi nota subito che non abbiamo più bisogno di passare la lunghezza dell’array come argomento.\nScarica l’esempio completo\n\n\n\n\nDati e Algoritmi"
  },
  {
    "objectID": "lessons/05/index.html",
    "href": "lessons/05/index.html",
    "title": "Uso avanzato dei puntatori",
    "section": "",
    "text": "Il C non permette di definire Classi e oggetti, si possono comunque definire dei tipi aggiuntivi:\n\nStrutture: insieme di dati\nUnioni: alternative tra tipi diversi\nEnumerazioni: insieme di costanti\n\n\n\nUna struttura è un insieme di dati, si differenzia dagli array perché:\n\ngli elementi possono essere di tipo diverso;\ngli elementi sono identificati da un nome;\n\nDi seguito un esempio di dichiarazione di una struttura:\nstruct studente {\n    char nome[20];\n    char cognome[20];\n    int matricola;\n};\nCome si può vedere dall’esempio, la dichiarazione di una struttura è introdotta dalla parola chiave struct, seguita dal nome della struttura e da una lista di dichiarazioni di variabili. Ricorda fortemente la dichiarazione di una classe in Java, in questo caso però non ci sono metodi, e i dati non si chiamano campi o attributi, ma membri. I membri hanno un nome e un tipo, possono essere di qualsiasi tipo, anche un’altra struttura. La grossa differenza con Java è che i membri sono sempre pubblici e non c’è modo di dichiararli privati.\n\n\nSi possono inizializzare le strutture quando vengono dichiarate:\nstruct studente s = {\"Mario\", \"Rossi\", 12345};\nSi possono inizializzare meno elementi rispetto a quelli dichiarati, in questo caso gli elementi non inizializzati vengono impostati a 0 (nel caso delle stringhe l’inizializzazione a zero equivale a dire stringa vuota \"\").\n\n\n\n\n\n\nAvviso\n\n\n\nIl tipo di una variabile struct è struct nome_struct, omettere la parola struct è un errore.\n\n\nUn modo alternativo di inizializzare una struttura è quello di specificare il nome dei membri:\nstruct studente s = {\n    .nome = \"Mario\",\n    .cognome = \"Rossi\",\n    .matricole = 12345,\n};\nIn questa modalità l’ordine degli elementi non è importante, ma è necessario specificare il nome di tutti i membri. Questo metodo è molto utile quando si hanno strutture con molti membri e si vuole inizializzare solo alcuni di essi.\n\n\n\nPer accedere ai singoli membri di una struttura si usa l’operatore . (punto) dopo il nome della variabile:\nstruct studente s = {\"Mario\", \"Rossi\", 12345};\n\nprintf(\"Nome: %s\\n\", s.nome);\nprintf(\"Cognome: %s\\n\", s.cognome);\ns.matricola = 54321;\n\n\n\nSi può copiare interamente una struttura usando una variabile dello stesso tipo:\nstruct studente a, b = {\"Matteo\", \"Spanio\", 56789};\na = b;\nIn questo caso si può notare una delle principali differenze con gli array:\n1int a[] = {1, 2, 3, 4, 5};\n2int *b;\n3b = a;\n\n1\n\na è un array di interi;\n\n2\n\nb è un puntatore a intero;\n\n3\n\nb = a non è una copia dell’array a ma assegna a b l’indirizzo di a, pertanto qualsiasi modifica dei dati di a si riflette anche in b (e viceversa). Cioè a e b puntano alla stessa area di memoria.\n\n\nUtilizzando le strutture invece, la copia è effettiva:\nstruct array {\n    int dati[5];\n};\n1struct array a = {{1, 2, 3, 4, 5}};\n2struct array b;\n3b = a;\n\n1\n\na inizializzo a con un array di interi;\n\n2\n\nb dichiaro b come struttura;\n\n3\n\nb = a copio a in b, vengono effettivamente copiati i dati dell’array a.dati in b.dati. Cioè a e b si trovano in aree di memoria diverse.\n\n\n\n\n\n\n\n\nImportante\n\n\n\nSolo l’operatore = è valido tra 2 struct, gli operatori == e != NON si possono usare per vedere se due strutture sono uguali.\n\n\n\n\n\nLe stutture possono avere un nome, gli si può associare un tipo, oppure possono essere anonime.\nLe strutture col nome, detto structure tag, si dichiarano come abbiamo già visto:\nstruct nome {\n    type member_name;\n};\n\n\n\nNel caso in cui un si voglia usare una struct solo in un punto specifico del codice non è necessario associarvi un nome, si può dichiarare e associare direttamente:\nstruct { int x; int y; } punto;\npunto.x = 12;\npunto.y = 18;\nCosì facendo la struttura non ha un nome e non può essere riutilizzata facilmente, ogni volta che si vuole dichiarare una variabile di quel tipo bisogna riscrivere la struttura.\n\n\n\ntypedef è un operatore che permette di definire alias per i tipi:\ntypedef int Bool;\ntypedef float Euro;\ntypedef char* String;\nQueste dichiarazioni permettono scrivere codice più chiaro.\nLo stesso effetto si può ottenere dichiarando delle macro:\n#define BOOL int\n#define EURO float\n#define STRING char*\nIn generale si preferisce usare typedef perché è più chiaro e il compilatore può fare dei controlli sui tipi.\nDal momento che le strutture sono usate moltissimo e i programmatori sono pigri, solitamente, si preferisce omettere la parola chiave struct per riferirsi al tipo delle strutture grazie a typedef:\ntypedef struct {\n    int x;\n    int y;\n} Point;\nPoint punto = {\n    .x = 1,\n    .y = 2,\n};\nIn questo modo si può dichiarare una variabile di tipo Point senza usare la parola chiave struct.\n\n\n\nUna volta definito il tipo con typedef, si può popolare una struttura con la stessa sintassi dell’inizializzazione, occorre fare un cast esplicito però:\ntypedef struct {\n    int x;\n    int y;\n} Point;\n\nPoint s;\ns = (Point) { .x = 1, .y = 2 };\nA prescindere da quale metodo di definizione si scelga, le strutture possono essere argomenti di funzioni e restituite da funzioni:\n#include &lt;math.h&gt;\ntypedef struct point {\n    int x;\n    int y;\n} Point;\n\nPoint somma(Point a, struct point b) {\n    return (Point) { .x = a.x + b.x, .y = a.y + b.y };\n}\n\nfloat distanza(Point a, Point b) {\n    return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));\n}\n\n\n\nSi possono creare puntatori a strutture (come per qualsiasi altro tipo di dato):\nstruct point *p;\nPoint *p1;\n\nvoid foo(Point* p);\n\n\n\n\nSi possono creare array di strutture:\nPoint punti[10];\npunti[0].x = 1;\nSi può inserire un array in una struttura:\nstruct libretto {\n    int voti[10];\n    int num_voti;\n};\nSi può inserire una struttura in un’altra struttura:\nstruct data {\n    int giorno;\n    int mese;\n    int anno;\n};\n\nstruct persona {\n    char nome[20];\n    char cognome[20];\n    struct data data_nascita;\n};\nsi possono anche innestare struct anonime:\nstruct {\n    char nome[20];\n    char cognome[20];\n    struct {\n        int giorno;\n        int mese;\n        int anno;\n    } data_nascita;\n} persona;\nSi possono inserire unioni1 in una struttura:\nstruct {\n    char nome[20];\n    char cognome[20];\n    union {\n        int matricola;\n        char codice_fiscale[16];\n    } id;\n} persona;\nSi può inserire strutture in unioni:\nunion {\n    struct {\n        int giorno;\n        int mese;\n        int anno;\n    } data;\n    int intero;\n} u;\n\n\n\nVediamo ora un esempio di programma basato sulle strutture.\nSi vuole creare un sistema informatico per la gestione squadra della nazionale Italiana di calcio che giocò ai mondiali del 1982:\n\nimplementare una struttura dati per memorizzare i dati di un giocatore di calcio;\nmemorizzare l’elenco dei giocatori della squadra;\nordinare i giocatori in base numero di maglia.\n\nUn giocatore è identificabile da nome, cognome e numero di maglia (chiaramente si potrebbero aggiungere molti altri dati, come la data di nascita, il ruolo, ecc.). Si può quindi definire una struttura Giocatore che contenga questi dati:\n#define BUFFER_SIZE 128 // dimensione massima di un buffer\ntypedef struct giocatore\n{\n    char nome[BUFFER_SIZE];\n    char cognome[BUFFER_SIZE];\n    unsigned int numero_maglia; // non esistono numeri di maglia negativi\n} Giocatore;\nIl codice sopra riportato definisce la struttura struct giocatore e vi associa il nuovo tipo Giocatore. La struttura contiene tre membri: nome, cognome e numero_maglia, in quanto stringhe, il nome e cognome sono di tipo char[], mentre il numero di maglia è un intero senza segno. Si noti che gli array vengono dichiarati con una dimensione massima BUFFER_SIZE, ciò vuol dire che il nome e il cognome possono avere una lunghezza massima di BUFFER_SIZE - 1 caratteri, purtroppo C non controlla che questa condizione sia rispettata. In altre parole, all’interno del programma posso inizializzare una struttura Giocatore con un nome o cognome più lungo di BUFFER_SIZE - 1 caratteri, ma il comportamento del programma in questo caso è indefinito. Questo è uno dei più grandi problemi di C.\n\n\nLa struct Giocatore è di fatto un tipo di dato, possiamo quindi creare un array di esami dove memorizzare la formazione:\n#define NUM 22\nGiocatore squadra[NUM];\nLa squadra è composta da 22 giocatori (11 titolari, 5 in panchina e 6 riserve). Questa dichiarazione crea un array di 22 elementi di tipo Giocatore e lo assegna alla variabile squadra. Quando si dichiara un array di strutture, si può accedere ai membri di ciascuna struttura usando la notazione . (punto):\nsquadra[0].numero_maglia = 1;\nQuesto perchè squadra[0] è una struttura di tipo Giocatore e numero_maglia è un membro di questa struttura, quando invece si ha un puntatore a una struttura, si usa l’operatore -&gt; (freccia):\nGiocatore *p = &squadra[0];\np-&gt;numero_maglia = 1;\nL’operatore -&gt; è una comodità sintattica, infatti p-&gt;numero_maglia è equivalente a (*p).numero_maglia.\n\n\n\nPer ordinare i giocatori in base al numero di maglia, bisogna introdurre un algoritmo di ordinamento:\nIl più intuitivo (ma non il più efficiente) è il Bubble Sort, di seguito una descrizione dell’algoritmo in pseudocodice:\nRepeat n-1 times\n    For i from 0 to n–2\n        If numbers[i] and numbers[i+1] out of order\n            Swap them\n    If no swaps\n        Quit\nL’idea è quella di scorrere l’array di numeri e scambiare i numeri adiacenti se non sono in ordine. Questo processo viene ripetuto finché non si è completato un passaggio senza scambi. Questo algoritmo è molto inefficiente, ma è molto semplice da implementare. La complessità computazionale del Bubble Sort è \\(O(n^2)\\).\nL’implementazione dello pseudocodice è molto semplice, infatti si tratta di due cicli annidati e uno scambio di due elementi:\n\nSi scorre l’array squadra NUM - 1 volte;\nSi scorre l’array squadra da 0 a NUM - 2;\nSi controlla se squadra[i] e squadra[i + 1] sono fuori ordine, in tal caso si scambiano. La funzione swap l’abbiamo già vista nella lezione sui puntatori.\n\nvoid bubble_sort(Giocatore *squadra, size_t n)\n{\n    for (size_t i = 0; i &lt; n - 1; i++)\n    {\n        for (size_t j = 0; j &lt; n - 2; j++)\n        {\n            if (squadra[j].numero_maglia &gt; squadra[j + 1].numero_maglia)\n            {\n                swap(&squadra[j], &squadra[j + 1], sizeof(Giocatore));\n            }\n        }\n    }\n}\nPer ottimizzare il codice, si può usare un flag per controllare se durante un passaggio non si è effettuato alcuno scambio, in tal caso si può uscire dal ciclo:\nvoid bubble_sort(Giocatore *squadra, size_t n)\n{\n    for (size_t i = 0; i &lt; n - 1; i++)\n    {\n        int scambiato = 0;\n        for (size_t j = 0; j &lt; n - 2; j++)\n        {\n            if (squadra[j].numero_maglia &gt; squadra[j + 1].numero_maglia)\n            {\n                swap(&squadra[j], &squadra[j + 1], sizeof(Giocatore));\n                scambiato = 1;\n            }\n        }\n        if (!scambiato)\n        {\n            break;\n        }\n    }\n}\nDi seguito un’animazione che mostra come funziona il Bubble Sort:\n\nSe stai consultando questa guida in formato HTML, puoi scaricare una versione completa del codice sorgente cliccando sul pulsante qui sotto, altrimenti puoi scaricarlo collegandoti a questo link.\n Scarica l'esempio completo \n\n\n\n\nLe unioni sono simili alle strutture, nel senso che permettono di usare membri di tipo diverso, la differenza sta nel fatto che una struttura tiene tutti i membri in memoria, mentre una union tiene solo un membro alla volta:\nunion {\n    int i;\n    double d;\n} u;\n\nstruct {\n    int i;\n    double d;\n} s;\nIn questo caso u occupa in memoria lo spazio necessario per la variabile più grande, in questo caso double (8 byte), mentre s occupa lo spazio necessario per entrambi i membri (4 + 8 byte).\nSi può inizializzare solo un elemento di una union:\nunion {\n    int i;\n    double d;\n} u = { .i = 3 };\nSi presti molta attenzione a non leggere mai un membro di una union che non è stato inizializzato, il comportamento del programma in questo caso è indefinito.\nCome per le strutture, posso dare nomi alle unioni tramite tag oppure con typedef.\n\n\n\nIn molti programmi si usano interi come “codici” per indicare varie cose. Un caso comune sono per esempio i codici di errore.\nSpesso si usano macro o costanti, ma è più chiaro usare enumerazioni:\nenum {\n    CUORI,\n    QUADRI,\n    FIORI,\n    PICCHE\n} s1, s2;`\nOra le variabili s1 e s2 possono assumere solo uno dei quattro valori definiti.\nUn esempio molto comune è la definizione del tipo booleano:\ntypedef enum {\n    FALSE,\n    TRUE\n} Bool;\nIn questo modo si può usare Bool come tipo di variabile, e assegnare solo i valori FALSE e TRUE. Solitamente gli elementi di un’enumerazione sono scritti in maiuscolo, per distinguerli dalle variabili. In questo caso FALSE e TRUE sono costanti, FALSE ha valore 0 e TRUE ha valore 1.\nDi default C assegna dei valori interi crescenti agli elementi dell’enumerazione, ma si possono assegnare valori specifici:\nenum {\n    LUN = 1,\n    MAR = 2,\n    MER = 3,\n    GIO = 4,\n    VEN = 5,\n    SAB = 6,\n    DOM = 7\n} giorno;\nSe non si assegna un valore, C assegna il valore dell’elemento precedente più uno.",
    "crumbs": [
      "Lezioni",
      "Uso avanzato dei puntatori"
    ]
  },
  {
    "objectID": "lessons/05/index.html#struct-3",
    "href": "lessons/05/index.html#struct-3",
    "title": "Uso avanzato dei puntatori",
    "section": "",
    "text": "Una struttura è un insieme di dati, si differenzia dagli array perché:\n\ngli elementi possono essere di tipo diverso;\ngli elementi sono identificati da un nome;\n\nDi seguito un esempio di dichiarazione di una struttura:\nstruct studente {\n    char nome[20];\n    char cognome[20];\n    int matricola;\n};\nCome si può vedere dall’esempio, la dichiarazione di una struttura è introdotta dalla parola chiave struct, seguita dal nome della struttura e da una lista di dichiarazioni di variabili. Ricorda fortemente la dichiarazione di una classe in Java, in questo caso però non ci sono metodi, e i dati non si chiamano campi o attributi, ma membri. I membri hanno un nome e un tipo, possono essere di qualsiasi tipo, anche un’altra struttura. La grossa differenza con Java è che i membri sono sempre pubblici e non c’è modo di dichiararli privati.\n\n\nSi possono inizializzare le strutture quando vengono dichiarate:\nstruct studente s = {\"Mario\", \"Rossi\", 12345};\nSi possono inizializzare meno elementi rispetto a quelli dichiarati, in questo caso gli elementi non inizializzati vengono impostati a 0 (nel caso delle stringhe l’inizializzazione a zero equivale a dire stringa vuota \"\").\n\n\n\n\n\n\nAvviso\n\n\n\nIl tipo di una variabile struct è struct nome_struct, omettere la parola struct è un errore.\n\n\nUn modo alternativo di inizializzare una struttura è quello di specificare il nome dei membri:\nstruct studente s = {\n    .nome = \"Mario\",\n    .cognome = \"Rossi\",\n    .matricole = 12345,\n};\nIn questa modalità l’ordine degli elementi non è importante, ma è necessario specificare il nome di tutti i membri. Questo metodo è molto utile quando si hanno strutture con molti membri e si vuole inizializzare solo alcuni di essi.\n\n\n\nPer accedere ai singoli membri di una struttura si usa l’operatore . (punto) dopo il nome della variabile:\nstruct studente s = {\"Mario\", \"Rossi\", 12345};\n\nprintf(\"Nome: %s\\n\", s.nome);\nprintf(\"Cognome: %s\\n\", s.cognome);\ns.matricola = 54321;\n\n\n\nSi può copiare interamente una struttura usando una variabile dello stesso tipo:\nstruct studente a, b = {\"Matteo\", \"Spanio\", 56789};\na = b;\nIn questo caso si può notare una delle principali differenze con gli array:\n1int a[] = {1, 2, 3, 4, 5};\n2int *b;\n3b = a;\n\n1\n\na è un array di interi;\n\n2\n\nb è un puntatore a intero;\n\n3\n\nb = a non è una copia dell’array a ma assegna a b l’indirizzo di a, pertanto qualsiasi modifica dei dati di a si riflette anche in b (e viceversa). Cioè a e b puntano alla stessa area di memoria.\n\n\nUtilizzando le strutture invece, la copia è effettiva:\nstruct array {\n    int dati[5];\n};\n1struct array a = {{1, 2, 3, 4, 5}};\n2struct array b;\n3b = a;\n\n1\n\na inizializzo a con un array di interi;\n\n2\n\nb dichiaro b come struttura;\n\n3\n\nb = a copio a in b, vengono effettivamente copiati i dati dell’array a.dati in b.dati. Cioè a e b si trovano in aree di memoria diverse.\n\n\n\n\n\n\n\n\nImportante\n\n\n\nSolo l’operatore = è valido tra 2 struct, gli operatori == e != NON si possono usare per vedere se due strutture sono uguali.\n\n\n\n\n\nLe stutture possono avere un nome, gli si può associare un tipo, oppure possono essere anonime.\nLe strutture col nome, detto structure tag, si dichiarano come abbiamo già visto:\nstruct nome {\n    type member_name;\n};\n\n\n\nNel caso in cui un si voglia usare una struct solo in un punto specifico del codice non è necessario associarvi un nome, si può dichiarare e associare direttamente:\nstruct { int x; int y; } punto;\npunto.x = 12;\npunto.y = 18;\nCosì facendo la struttura non ha un nome e non può essere riutilizzata facilmente, ogni volta che si vuole dichiarare una variabile di quel tipo bisogna riscrivere la struttura.\n\n\n\ntypedef è un operatore che permette di definire alias per i tipi:\ntypedef int Bool;\ntypedef float Euro;\ntypedef char* String;\nQueste dichiarazioni permettono scrivere codice più chiaro.\nLo stesso effetto si può ottenere dichiarando delle macro:\n#define BOOL int\n#define EURO float\n#define STRING char*\nIn generale si preferisce usare typedef perché è più chiaro e il compilatore può fare dei controlli sui tipi.\nDal momento che le strutture sono usate moltissimo e i programmatori sono pigri, solitamente, si preferisce omettere la parola chiave struct per riferirsi al tipo delle strutture grazie a typedef:\ntypedef struct {\n    int x;\n    int y;\n} Point;\nPoint punto = {\n    .x = 1,\n    .y = 2,\n};\nIn questo modo si può dichiarare una variabile di tipo Point senza usare la parola chiave struct.\n\n\n\nUna volta definito il tipo con typedef, si può popolare una struttura con la stessa sintassi dell’inizializzazione, occorre fare un cast esplicito però:\ntypedef struct {\n    int x;\n    int y;\n} Point;\n\nPoint s;\ns = (Point) { .x = 1, .y = 2 };\nA prescindere da quale metodo di definizione si scelga, le strutture possono essere argomenti di funzioni e restituite da funzioni:\n#include &lt;math.h&gt;\ntypedef struct point {\n    int x;\n    int y;\n} Point;\n\nPoint somma(Point a, struct point b) {\n    return (Point) { .x = a.x + b.x, .y = a.y + b.y };\n}\n\nfloat distanza(Point a, Point b) {\n    return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));\n}\n\n\n\nSi possono creare puntatori a strutture (come per qualsiasi altro tipo di dato):\nstruct point *p;\nPoint *p1;\n\nvoid foo(Point* p);",
    "crumbs": [
      "Lezioni",
      "Uso avanzato dei puntatori"
    ]
  },
  {
    "objectID": "lessons/05/index.html#array-di-struct",
    "href": "lessons/05/index.html#array-di-struct",
    "title": "Uso avanzato dei puntatori",
    "section": "",
    "text": "Si possono creare array di strutture:\nPoint punti[10];\npunti[0].x = 1;\nSi può inserire un array in una struttura:\nstruct libretto {\n    int voti[10];\n    int num_voti;\n};\nSi può inserire una struttura in un’altra struttura:\nstruct data {\n    int giorno;\n    int mese;\n    int anno;\n};\n\nstruct persona {\n    char nome[20];\n    char cognome[20];\n    struct data data_nascita;\n};\nsi possono anche innestare struct anonime:\nstruct {\n    char nome[20];\n    char cognome[20];\n    struct {\n        int giorno;\n        int mese;\n        int anno;\n    } data_nascita;\n} persona;\nSi possono inserire unioni1 in una struttura:\nstruct {\n    char nome[20];\n    char cognome[20];\n    union {\n        int matricola;\n        char codice_fiscale[16];\n    } id;\n} persona;\nSi può inserire strutture in unioni:\nunion {\n    struct {\n        int giorno;\n        int mese;\n        int anno;\n    } data;\n    int intero;\n} u;",
    "crumbs": [
      "Lezioni",
      "Uso avanzato dei puntatori"
    ]
  },
  {
    "objectID": "lessons/05/index.html#esempio-mondiali-1982",
    "href": "lessons/05/index.html#esempio-mondiali-1982",
    "title": "Uso avanzato dei puntatori",
    "section": "",
    "text": "Vediamo ora un esempio di programma basato sulle strutture.\nSi vuole creare un sistema informatico per la gestione squadra della nazionale Italiana di calcio che giocò ai mondiali del 1982:\n\nimplementare una struttura dati per memorizzare i dati di un giocatore di calcio;\nmemorizzare l’elenco dei giocatori della squadra;\nordinare i giocatori in base numero di maglia.\n\nUn giocatore è identificabile da nome, cognome e numero di maglia (chiaramente si potrebbero aggiungere molti altri dati, come la data di nascita, il ruolo, ecc.). Si può quindi definire una struttura Giocatore che contenga questi dati:\n#define BUFFER_SIZE 128 // dimensione massima di un buffer\ntypedef struct giocatore\n{\n    char nome[BUFFER_SIZE];\n    char cognome[BUFFER_SIZE];\n    unsigned int numero_maglia; // non esistono numeri di maglia negativi\n} Giocatore;\nIl codice sopra riportato definisce la struttura struct giocatore e vi associa il nuovo tipo Giocatore. La struttura contiene tre membri: nome, cognome e numero_maglia, in quanto stringhe, il nome e cognome sono di tipo char[], mentre il numero di maglia è un intero senza segno. Si noti che gli array vengono dichiarati con una dimensione massima BUFFER_SIZE, ciò vuol dire che il nome e il cognome possono avere una lunghezza massima di BUFFER_SIZE - 1 caratteri, purtroppo C non controlla che questa condizione sia rispettata. In altre parole, all’interno del programma posso inizializzare una struttura Giocatore con un nome o cognome più lungo di BUFFER_SIZE - 1 caratteri, ma il comportamento del programma in questo caso è indefinito. Questo è uno dei più grandi problemi di C.\n\n\nLa struct Giocatore è di fatto un tipo di dato, possiamo quindi creare un array di esami dove memorizzare la formazione:\n#define NUM 22\nGiocatore squadra[NUM];\nLa squadra è composta da 22 giocatori (11 titolari, 5 in panchina e 6 riserve). Questa dichiarazione crea un array di 22 elementi di tipo Giocatore e lo assegna alla variabile squadra. Quando si dichiara un array di strutture, si può accedere ai membri di ciascuna struttura usando la notazione . (punto):\nsquadra[0].numero_maglia = 1;\nQuesto perchè squadra[0] è una struttura di tipo Giocatore e numero_maglia è un membro di questa struttura, quando invece si ha un puntatore a una struttura, si usa l’operatore -&gt; (freccia):\nGiocatore *p = &squadra[0];\np-&gt;numero_maglia = 1;\nL’operatore -&gt; è una comodità sintattica, infatti p-&gt;numero_maglia è equivalente a (*p).numero_maglia.\n\n\n\nPer ordinare i giocatori in base al numero di maglia, bisogna introdurre un algoritmo di ordinamento:\nIl più intuitivo (ma non il più efficiente) è il Bubble Sort, di seguito una descrizione dell’algoritmo in pseudocodice:\nRepeat n-1 times\n    For i from 0 to n–2\n        If numbers[i] and numbers[i+1] out of order\n            Swap them\n    If no swaps\n        Quit\nL’idea è quella di scorrere l’array di numeri e scambiare i numeri adiacenti se non sono in ordine. Questo processo viene ripetuto finché non si è completato un passaggio senza scambi. Questo algoritmo è molto inefficiente, ma è molto semplice da implementare. La complessità computazionale del Bubble Sort è \\(O(n^2)\\).\nL’implementazione dello pseudocodice è molto semplice, infatti si tratta di due cicli annidati e uno scambio di due elementi:\n\nSi scorre l’array squadra NUM - 1 volte;\nSi scorre l’array squadra da 0 a NUM - 2;\nSi controlla se squadra[i] e squadra[i + 1] sono fuori ordine, in tal caso si scambiano. La funzione swap l’abbiamo già vista nella lezione sui puntatori.\n\nvoid bubble_sort(Giocatore *squadra, size_t n)\n{\n    for (size_t i = 0; i &lt; n - 1; i++)\n    {\n        for (size_t j = 0; j &lt; n - 2; j++)\n        {\n            if (squadra[j].numero_maglia &gt; squadra[j + 1].numero_maglia)\n            {\n                swap(&squadra[j], &squadra[j + 1], sizeof(Giocatore));\n            }\n        }\n    }\n}\nPer ottimizzare il codice, si può usare un flag per controllare se durante un passaggio non si è effettuato alcuno scambio, in tal caso si può uscire dal ciclo:\nvoid bubble_sort(Giocatore *squadra, size_t n)\n{\n    for (size_t i = 0; i &lt; n - 1; i++)\n    {\n        int scambiato = 0;\n        for (size_t j = 0; j &lt; n - 2; j++)\n        {\n            if (squadra[j].numero_maglia &gt; squadra[j + 1].numero_maglia)\n            {\n                swap(&squadra[j], &squadra[j + 1], sizeof(Giocatore));\n                scambiato = 1;\n            }\n        }\n        if (!scambiato)\n        {\n            break;\n        }\n    }\n}\nDi seguito un’animazione che mostra come funziona il Bubble Sort:\n\nSe stai consultando questa guida in formato HTML, puoi scaricare una versione completa del codice sorgente cliccando sul pulsante qui sotto, altrimenti puoi scaricarlo collegandoti a questo link.\n Scarica l'esempio completo",
    "crumbs": [
      "Lezioni",
      "Uso avanzato dei puntatori"
    ]
  },
  {
    "objectID": "lessons/05/index.html#unioni-2",
    "href": "lessons/05/index.html#unioni-2",
    "title": "Uso avanzato dei puntatori",
    "section": "",
    "text": "Le unioni sono simili alle strutture, nel senso che permettono di usare membri di tipo diverso, la differenza sta nel fatto che una struttura tiene tutti i membri in memoria, mentre una union tiene solo un membro alla volta:\nunion {\n    int i;\n    double d;\n} u;\n\nstruct {\n    int i;\n    double d;\n} s;\nIn questo caso u occupa in memoria lo spazio necessario per la variabile più grande, in questo caso double (8 byte), mentre s occupa lo spazio necessario per entrambi i membri (4 + 8 byte).\nSi può inizializzare solo un elemento di una union:\nunion {\n    int i;\n    double d;\n} u = { .i = 3 };\nSi presti molta attenzione a non leggere mai un membro di una union che non è stato inizializzato, il comportamento del programma in questo caso è indefinito.\nCome per le strutture, posso dare nomi alle unioni tramite tag oppure con typedef.",
    "crumbs": [
      "Lezioni",
      "Uso avanzato dei puntatori"
    ]
  },
  {
    "objectID": "lessons/05/index.html#enumerazioni-1",
    "href": "lessons/05/index.html#enumerazioni-1",
    "title": "Uso avanzato dei puntatori",
    "section": "",
    "text": "In molti programmi si usano interi come “codici” per indicare varie cose. Un caso comune sono per esempio i codici di errore.\nSpesso si usano macro o costanti, ma è più chiaro usare enumerazioni:\nenum {\n    CUORI,\n    QUADRI,\n    FIORI,\n    PICCHE\n} s1, s2;`\nOra le variabili s1 e s2 possono assumere solo uno dei quattro valori definiti.\nUn esempio molto comune è la definizione del tipo booleano:\ntypedef enum {\n    FALSE,\n    TRUE\n} Bool;\nIn questo modo si può usare Bool come tipo di variabile, e assegnare solo i valori FALSE e TRUE. Solitamente gli elementi di un’enumerazione sono scritti in maiuscolo, per distinguerli dalle variabili. In questo caso FALSE e TRUE sono costanti, FALSE ha valore 0 e TRUE ha valore 1.\nDi default C assegna dei valori interi crescenti agli elementi dell’enumerazione, ma si possono assegnare valori specifici:\nenum {\n    LUN = 1,\n    MAR = 2,\n    MER = 3,\n    GIO = 4,\n    VEN = 5,\n    SAB = 6,\n    DOM = 7\n} giorno;\nSe non si assegna un valore, C assegna il valore dell’elemento precedente più uno.",
    "crumbs": [
      "Lezioni",
      "Uso avanzato dei puntatori"
    ]
  },
  {
    "objectID": "lessons/05/index.html#array-con-strutture-2",
    "href": "lessons/05/index.html#array-con-strutture-2",
    "title": "Uso avanzato dei puntatori",
    "section": "Array con strutture",
    "text": "Array con strutture\nGli array in C sono molto limitati, infatti dobbiamo gestire la loro lunghezza a mano, per questo è una pratica comune creare una struttura che contenga un array e la sua lunghezza:\n#define MAX 1024\n\ntypedef struct intarray {\n    int array[MAX];\n    int length;\n} IntArray;\nQuesta struttura dati si comporta come segue: array è un array con una dimensione massima di MAX elementi, length è il numero di elementi effettivamente presenti nell’array, ciò vuol dire che length è sempre minore o uguale a MAX. Di seguito un esempio di utilizzo:\n1IntArray a = {.length=0};\n2a.array[a.length++] = 1;\n3printf(\"%d, %d\\n\", a.array[0], a.length);\n\n1\n\nInizializzo la struttura a con length=0, non c’è bisogno di inizializzare l’array perchè si presuppone che prima di accedere all’array si verifichi sempre fino a che indice è valido l’array tramite length;\n\n2\n\nInizializzo il primo elemento dell’array con il valore 1 e incremento length, si noti che l’espressione a.length++ restituisce il valore di a.length prima dell’incremento;\n\n3\n\nStampo il primo elemento dell’array e la lunghezza dell’array.\n\n\nAdesso si può passare la struttura come argomento di una funzione:\n1void stampa_array(IntArray a) {\n2    for (int i = 0; i &lt; a.length; i++) {\n        printf(\"%d \", a.array[i]);\n    }\n    printf(\"\\n\");\n}\n\n1\n\nSi nota subito che non abbiamo più bisogno di passare la lunghezza dell’array come argomento.\n\n2\n\nSi può usare a.length per scorrere l’array, pertanto se la dimensione è 0 il ciclo non viene eseguito, ecco perchè non c’è bisogno di inizializzare i valori dell’array se length è 0.\n\n\nSe stai consultando questa guida in formato HTML, puoi scaricare un esempio di codice sorgente in cui si utilizza questa struttura dati cliccando sul pulsante qui sotto, altrimenti puoi scaricarlo collegandoti a questo link.\n Scarica l'esempio completo",
    "crumbs": [
      "Lezioni",
      "Uso avanzato dei puntatori"
    ]
  },
  {
    "objectID": "lessons/05/index.html#footnotes",
    "href": "lessons/05/index.html#footnotes",
    "title": "Uso avanzato dei puntatori",
    "section": "Note",
    "text": "Note\n\n\nSi veda la sezione seguente per informazioni dettagliate sulle unioni.↩︎",
    "crumbs": [
      "Lezioni",
      "Uso avanzato dei puntatori"
    ]
  },
  {
    "objectID": "lessons/01/slide.html#storia-e-standard",
    "href": "lessons/01/slide.html#storia-e-standard",
    "title": "Basi di C",
    "section": "Storia e Standard",
    "text": "Storia e Standard\n\n\n\n\n\ntimeline\n    section Birth of C\n        1972 : nasce C (New B) presso i Bell Labs.\n        1973 : UNIX viene interamente riscritto in C.\n    section Definition of C Language\n        1978 : Kerninghan & Ritchie pubblicano The C Programming Language.\n        1989 : Primo Standard C (C89)\n    section Actual C\n        1999 : Secondo standard C (C99)\n        2011 : Terzo standard C (C11)\n\n\nPrincipali momenti storici per lo sviluppo del linguaggio C"
  },
  {
    "objectID": "lessons/01/slide.html#storia-e-standard-1",
    "href": "lessons/01/slide.html#storia-e-standard-1",
    "title": "Basi di C",
    "section": "Storia e Standard",
    "text": "Storia e Standard\n\nIl linguaggio C fu ideato nei Bell Laboratories della AT&T nel 1972 da Dennis Ritchie, la definizione formale avvenne nel 1978 a cura di Brian Kernighan e D. Ritchie.\nGià nel 1973 il linguaggio fu usato per riscrivere completamente il sistema operativo UNIX.\nLa standarizzazione del linguaggio avvenne nel 1989 a cura dell’ANSI (American NaJonal Standard Institute), e in seguito venne recepita dall’ISO (InternaJonal OrganizaJon for Standardization, ISO/IEC 9899:1990).\nNel 1999 si concluse una nuova fase di standarizzazione del C, nella quale vennero aggiunte nuove funzionalità al linguaggio (ISO/IEC 9899:1999)."
  },
  {
    "objectID": "lessons/01/slide.html#caratteristiche",
    "href": "lessons/01/slide.html#caratteristiche",
    "title": "Basi di C",
    "section": "Caratteristiche",
    "text": "Caratteristiche\n\nSi tratta di un Linguaggio Compilato\nFortemente tipato\nMinimale\nPermissivo (il compilatore non si lamenta!)\nTecnicamente un linguaggio di alto livello, nella pratica ha molte feature che lo rendono uno dei linguaggi di più basso livello. Specialmente sulla gestione di memoria."
  },
  {
    "objectID": "lessons/01/slide.html#pregi-e-difetti",
    "href": "lessons/01/slide.html#pregi-e-difetti",
    "title": "Basi di C",
    "section": "Pregi e difetti",
    "text": "Pregi e difetti\n\n\n\nPregi\nDifetti\n\n\n\n\nEfficienza\nFacile fare errori\n\n\nCompattezza\nPuò diventare difficile da leggere\n\n\nPortabilità\nNon ci sono controlli a run time\n\n\nPermissività\nPermissività"
  },
  {
    "objectID": "lessons/01/slide.html#pregi-e-difetti-2",
    "href": "lessons/01/slide.html#pregi-e-difetti-2",
    "title": "Basi di C",
    "section": "Pregi e Difetti",
    "text": "Pregi e Difetti\n\nLa permissività è sia un pro che un contro: sta al programmatore giocarla a suo vantaggio\nEvitare di farsi male da soli!\nSeguire le convenzioni di scrittura\nAttivare i warning sul compilatore (+ altri tool)\nCommentare!"
  },
  {
    "objectID": "lessons/01/slide.html#linguaggio-strutturato",
    "href": "lessons/01/slide.html#linguaggio-strutturato",
    "title": "Basi di C",
    "section": "Linguaggio Strutturato",
    "text": "Linguaggio Strutturato\n\nÈ possibile (e necessario) definire funzioni, che accettano \\(N\\) parametri in input e restituiscono un valore come output.\nC non è un linguaggio a oggetti. Non esistono quindi le astrazioni tipiche di Java, classi, variabili di istanza, metodi…\nEsistono evoluzioni del C con queste caratteristiche (C++, C# e lo stesso Java ha ereditato molto dal C)."
  },
  {
    "objectID": "lessons/01/slide.html#installazione",
    "href": "lessons/01/slide.html#installazione",
    "title": "Basi di C",
    "section": "Installazione",
    "text": "Installazione\n\n\n\n\n\n\nLinux e Mac1\n\n\nDebian/Ubuntu2: per installare il compilatore: sudo apt install gcc -y\nMac: se non lo avete, facendo gcc -v il sistema vi proporrà di scaricare i tool da linea di comando di Apple. Accettando, vi verrà installato.\n\n\n\n\n\n\n\n\n\nWindows\n\n\npotete installare MinGW e modificare le variabili di PATH. Le istruzioni saranno caricate su Moodle.\n\n\n\nprobabilmente è già installato. Aprire il terminale per verificarlo con gcc –vper altre distribuzioni non debian based, usare il package manager di sistema"
  },
  {
    "objectID": "lessons/01/slide.html#installazione-1",
    "href": "lessons/01/slide.html#installazione-1",
    "title": "Basi di C",
    "section": "Installazione",
    "text": "Installazione\n\n\n\n\nflowchart LR\nA[Start]\nB{\"Scegli OS\"}\nC[Installare MinGW o WSL 2]\nE{\"digitare\\ngcc --version\"}\nF[Installare GCC]\nG[Ready to go]\n\nA --&gt; B\nB --&gt; |Windows| C\nB --&gt; |UNIX based| E\nC --&gt; E\nE --&gt; |errore| F\nE --&gt; |stampa versione| G\nF --&gt; G\n\n\nProcesso di installazione del compilatore"
  },
  {
    "objectID": "lessons/01/slide.html#installazione-2",
    "href": "lessons/01/slide.html#installazione-2",
    "title": "Basi di C",
    "section": "Installazione",
    "text": "Installazione\nVi servirà anche un editor di testo adatto al codice.\nAd esempio notepad++, sublime, gedit, kate, emacs, nano, vim…\n\n\n\n\n\n\nImportante\n\n\nÈ sconsigliato studiare su un IDE, anche se è consigliato usarli quando si lavora effettivamente.\n\n\n\n\n\n\n\n\n\nImpara facendo\n\n\nRiscrivere tutti gli esempi di codice senza usare copia e incolla aiuta a familiarizzare con la sintassi del linguaggio e gli strumenti di lavoro. Copiando si commettono errori da cui è possibile imparare, il compilatore segnalerà gli errori e si imparerà a correggerli."
  },
  {
    "objectID": "lessons/01/slide.html#la-compilazione",
    "href": "lessons/01/slide.html#la-compilazione",
    "title": "Basi di C",
    "section": "La compilazione",
    "text": "La compilazione\nPrendiamo in esame il nostro primo programma, hello.c\n#include &lt;stdio.h&gt;\n\n/* Il mio primo programma in C! */\nint main(void)\n{\n    printf(\"Hello, World!\");\n}"
  },
  {
    "objectID": "lessons/01/slide.html#la-compilazione-1",
    "href": "lessons/01/slide.html#la-compilazione-1",
    "title": "Basi di C",
    "section": "La compilazione",
    "text": "La compilazione\nNel venire compilato, il nostro programma passa attraverso altri tre programmi:\n\nPreprocessor: elimina i commenti ed esegue le direttive del preprocessore (le istruzioni che iniziano con #).\nCompiler: controlla se il codice è corretto (sintatticamente) e lo converte in linguaggio macchina, generando il codice oggetto.\nLinker: combina vari file oggetto e le librerie, producendo il file eseguibile. (a.out oppure a.exe)"
  },
  {
    "objectID": "lessons/01/slide.html#la-compilazione-2",
    "href": "lessons/01/slide.html#la-compilazione-2",
    "title": "Basi di C",
    "section": "La compilazione",
    "text": "La compilazione\nEsistono comandi per accedere separatamente ai vari passaggi, ma in genere viene tutto gestito da gcc (GNU C Compiler \\(\\rightarrow\\) GNU Compiler Collection)\ngcc -o &lt;nome_eseguibile&gt; &lt;sorgente.c&gt; &lt;sorgente2.c&gt; ... &lt;sorgenteN.c&gt;\nIl comando chiama il preprocessore su tutti i file, per tutti compila il file oggetto e chiama il linker che li unisce nell’unico eseguibile chiamato &lt;nome_eseguibile&gt;\n\n\n\n\n\n\nNota\n\n\ngcc -c &lt;sorgente.c&gt; &lt;sorgente2.c&gt; ... &lt;sorgenteN.c&gt;\nNon esegue il linking (utile se non si ha ancora il main ad esempio)"
  },
  {
    "objectID": "lessons/01/slide.html#sintassi-di-c",
    "href": "lessons/01/slide.html#sintassi-di-c",
    "title": "Basi di C",
    "section": "Sintassi di C",
    "text": "Sintassi di C\n#include &lt;stdio.h&gt;\n/* Il mio primo programma in C! */\nint main(void)\n{\n    int anno = 2024;\n    printf(\"Hello Dati e Algoritmi %d\", anno);\n}\n\n\n\nDirettiva"
  },
  {
    "objectID": "lessons/01/slide.html#sintassi-di-c-1",
    "href": "lessons/01/slide.html#sintassi-di-c-1",
    "title": "Basi di C",
    "section": "Sintassi di C",
    "text": "Sintassi di C\n#include &lt;stdio.h&gt;\n/* Il mio primo programma in C! */\nint main(void)\n{\n    int anno = 2024;\n    printf(\"Hello Dati e Algoritmi %d\", anno);\n}\n\n\nDirettiva\nCommento"
  },
  {
    "objectID": "lessons/01/slide.html#sintassi-di-c-2",
    "href": "lessons/01/slide.html#sintassi-di-c-2",
    "title": "Basi di C",
    "section": "Sintassi di C",
    "text": "Sintassi di C\n#include &lt;stdio.h&gt;\n/* Il mio primo programma in C! */\nint main(void)\n{\n    int anno = 2024;\n    printf(\"Hello Dati e Algoritmi %d\", anno);\n}\n\n\nDirettiva\nCommento\nFunzione"
  },
  {
    "objectID": "lessons/01/slide.html#sintassi-di-c-3",
    "href": "lessons/01/slide.html#sintassi-di-c-3",
    "title": "Basi di C",
    "section": "Sintassi di C",
    "text": "Sintassi di C\n#include &lt;stdio.h&gt;\n/* Il mio primo programma in C! */\nint main(void)\n{\n    int anno = 2024;\n    printf(\"Hello Dati e Algoritmi %d\", anno);\n}\n\n\nDirettiva\nCommento\nFunzione\nDichiarazione e assegnazione di variabile"
  },
  {
    "objectID": "lessons/01/slide.html#sintassi-di-c-4",
    "href": "lessons/01/slide.html#sintassi-di-c-4",
    "title": "Basi di C",
    "section": "Sintassi di C",
    "text": "Sintassi di C\n#include &lt;stdio.h&gt;\n/* Il mio primo programma in C! */\nint main(void)\n{\n    int anno = 2024;\n    printf(\"Hello Dati e Algoritmi %d\", anno);\n}\n\n\nDirettiva\nCommento\nFunzione\nDichiarazione e assegnazione di variabile\nChiamata di funzione"
  },
  {
    "objectID": "lessons/01/slide.html#commenti",
    "href": "lessons/01/slide.html#commenti",
    "title": "Basi di C",
    "section": "Commenti",
    "text": "Commenti\nI commenti classici di C si fanno con la sintassi\n/* testo del commento\nint i = 0; &lt;--- questo viene ignorato\nanche su più righe */\n\nDal C99, si può usare anche il commento monoriga\n// commento su una riga\nint i = 0; // questo viene eseguito\n// altro commento"
  },
  {
    "objectID": "lessons/01/slide.html#dichiarazioni-e-inizializzazioni",
    "href": "lessons/01/slide.html#dichiarazioni-e-inizializzazioni",
    "title": "Basi di C",
    "section": "Dichiarazioni e inizializzazioni",
    "text": "Dichiarazioni e inizializzazioni\nTutte le variabili devono essere dichiarate prima di essere usate:\nint altezza;\nfloat temperatura, peso;\nNon c’è inizializzazione di default! Occorre assegnare valori:\nint altezza;\naltezza = 175;\nfloat temperatura = 36.4f; // anche subito"
  },
  {
    "objectID": "lessons/01/slide.html#keyword-riservate",
    "href": "lessons/01/slide.html#keyword-riservate",
    "title": "Basi di C",
    "section": "Keyword riservate",
    "text": "Keyword riservate\nNon si possono usare le seguenti parole per nomi di variabili o altro:\nauto     break   case    char      const      continue   default   do\ndouble   else    enum    extern    float      for        goto      if\ninline*  int     long    register  restrict*  return     short     signed\nsizeof   static  struct  switch    typedef    union      unsigned  void\nvolatile while   _Bool*  _Complex* _Imaginary*\n*solo da C99\n\n\n\n\n\n\nIl C è case sensitive\n\n\nNomi di variabili valide sono:\nint a, A; float Auto;\nN.B. solo perché si può non vuol dire che sia una buona idea…"
  },
  {
    "objectID": "lessons/01/slide.html#inputoutput",
    "href": "lessons/01/slide.html#inputoutput",
    "title": "Basi di C",
    "section": "Input/Output",
    "text": "Input/Output\n\nAbbiamo già usato nei nostri esempi l’inclusione di stdio.h\nCi ha permesso di usare la funzione printf, con la quale possiamo stampare dei risultati a terminale\nL’altra importante funzione che ci permette di usare è scanf, che legge i dati forniti dall’utente a terminale\nEntrambe usano testo formattato, tramite uso di simboli speciali"
  },
  {
    "objectID": "lessons/01/slide.html#output-con-printf",
    "href": "lessons/01/slide.html#output-con-printf",
    "title": "Basi di C",
    "section": "Output con printf",
    "text": "Output con printf\n$ man 3 printf\n\nPRINTF(3)              Linux Programmer's Manual              PRINTF(3)\n\nNAME\n       printf,  fprintf, dprintf, sprintf, snprintf, vprintf, vfprintf,\n       vdprintf, vsprintf, vsnprintf - formatted output conversion\n\nSYNOPSIS\n       #include &lt;stdio.h&gt;\n\n       int printf(const char *format, ...);\n       int fprintf(FILE *stream, const char *format, ...);\n       int dprintf(int fd, const char *format, ...);\n       int sprintf(char *str, const char *format, ...);\n       int snprintf(char *str, size_t size, const char *format, ...);\n\n...\n\nDESCRIPTION\n       The functions in the printf() family produce output according to\n       a  format  as  described  below.   The  functions  printf()  and\n       vprintf()  write  output  to stdout, the standard output stream;\n       fprintf() and  vfprintf()  write  output  to  the  given  output\n       stream; sprintf(), snprintf(), vsprintf(), and vsnprintf() write\n       to the character string str."
  },
  {
    "objectID": "lessons/01/slide.html#il-manuale",
    "href": "lessons/01/slide.html#il-manuale",
    "title": "Basi di C",
    "section": "Il manuale",
    "text": "Il manuale\nIl comando man permette di visualizzare il manuale di un comando o di una funzione. È diviso in sezioni:\n\nProgrammi eseguibili e comandi della shell\nChiamate al sistema (funzioni fornite dal kernel)\nChiamate alle librerie (funzioni all’interno delle librerie di sistema)\nFile speciali (di solito trovabili in /dev)\nFormati dei file e convenzioni p.es. /etc/passwd\nGiochi\nPacchetti di macro e convenzioni p.es. man(7), groff(7).\nComandi per l’amministrazione del sistema (solitamente solo per root)\nRoutine del kernel [Non standard]"
  },
  {
    "objectID": "lessons/01/slide.html#output-con-printf-2",
    "href": "lessons/01/slide.html#output-con-printf-2",
    "title": "Basi di C",
    "section": "Output con printf",
    "text": "Output con printf\nGli specificatori iniziano con %, e per ciascuno deve esserci un parametro dopo la stringa di formattazione\nprintf(\"Misura %d metri e %d cm \\n\", met, cm);\nOutput: Misura 2 e 15 cm\nI caratteri speciali sii scrivono con \\ (backslash) il carattere di escaping\nprintf(\"Si va a capo con \\\\n\\n\");\nOutput: Si va a capo con \\n"
  },
  {
    "objectID": "lessons/01/slide.html#section",
    "href": "lessons/01/slide.html#section",
    "title": "Basi di C",
    "section": "",
    "text": "Tabella 1: Formattazione stringhe\n\n\n\n\n\nFormat specifier\nValue\nOutput\n\n\n\n\n%c\n'm'\nm\n\n\n%d\n255\n255\n\n\n%ld\n99\n99\n\n\n%x\n255\nff\n\n\n%f\n25.8\n25.799999\n\n\n%g\n25.8\n25.8\n\n\n%s\n\"hello\"\nhello\n\n\n%8.3f\n25.8\n˽˽25.800\n\n\n%6d\n255\n˽˽˽255\n\n\n%06d\n255\n000255\n\n\n%-6d\n255\n255˽˽˽\n\n\n\n\n\n\n\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    char c_val = 'm';\n    int i_val = 255;\n    long int l_val = 99;\n    float f_val = 25.8;\n\n    printf(\"%c\\n\", c_val);\n    printf(\"%d\\n\", i_val);\n    printf(\"%ld\\n\", l_val);\n    printf(\"%x\\n\", i_val);\n    printf(\"%f\\n\", f_val);\n    printf(\"%g\\n\", f_val);\n    printf(\"%s\\n\", \"hello\");\n    printf(\"%8.3f\\n\", f_val);\n    printf(\"%6d\\n\", i_val);\n    printf(\"%06d\\n\", i_val);\n    printf(\"%-6d\\n\", i_val);\n}"
  },
  {
    "objectID": "lessons/01/slide.html#output-con-printf-3",
    "href": "lessons/01/slide.html#output-con-printf-3",
    "title": "Basi di C",
    "section": "Output con printf",
    "text": "Output con printf\n\n%d per interi, es. \\(10\\)\n%f per float, es. \\(3.14\\)\n%e per float in notazione scientifica, es. \\(5.2\\times 10^4\\)\n%lf per double, es. \\(3.14\\)\n%s per stringhe, es. \"ciao\"\n%c per caratteri, es. 'a'\n%p per puntatori, es. 0x7fffbf7f3b4c\n%x per interi in esadecimale, es. ff\n%o per interi in ottale, es. 77\n%Nf per avere \\(N\\) “spazi” per la stampa, es. %5d per 112 con due spazi vuoti prima\n%.Nf per float con \\(N\\) cifre decimali, es. %.2f per \\(3.14\\)"
  },
  {
    "objectID": "lessons/01/slide.html#string-format",
    "href": "lessons/01/slide.html#string-format",
    "title": "Basi di C",
    "section": "String format",
    "text": "String format\nSi è già visto \\n per andare a capo, ma ce ne sono altri:\n\n\\n per andare a capo\n\\t per tabulare\n\\b per backspace\n\\\\ per stampare il backslash\n\\\" per stampare le virgolette\n\\0 per terminare una stringa"
  },
  {
    "objectID": "lessons/01/slide.html#input-con-scanf",
    "href": "lessons/01/slide.html#input-con-scanf",
    "title": "Basi di C",
    "section": "Input con scanf",
    "text": "Input con scanf\nscanf esegue pattern matching sull’input per popolare delle variabili\nint base, altezza;\nscanf(\n    \"%d%d\", // pattern\n    &base, &altezza // variabili da popolare\n);\nPer esempio se l’utente scrive 3 4 e preme invio, base sarà 3 e altezza sarà 4."
  },
  {
    "objectID": "lessons/01/slide.html#input-con-scanf-2",
    "href": "lessons/01/slide.html#input-con-scanf-2",
    "title": "Basi di C",
    "section": "Input con scanf",
    "text": "Input con scanf\nscanf scorre l’input ignorando ogni carattere bianco (spazi, tabulazioni, a capo).\nSe trova caratteri compatibili (+/-, 0-9, .) li legge e li converte nel tipo di variabile corrispondente.\nPopola le variabili fino a trovare un carattere bianco o un carattere non compatibile."
  },
  {
    "objectID": "lessons/01/slide.html#input-con-scanf-3",
    "href": "lessons/01/slide.html#input-con-scanf-3",
    "title": "Basi di C",
    "section": "Input con scanf",
    "text": "Input con scanf\n&base?\n\nÈ un puntatore! Per poter salvare in memoria il valore letto da scanf è necessario passare l’indirizzo di memoria della variabile, non la variabile stessa.\n\n\n\n\n\n\nAvviso\n\n\nDimenticarsi il simbolo & in questo caso darà un errore a runtime"
  },
  {
    "objectID": "lessons/01/slide.html#input-con-scanf-4",
    "href": "lessons/01/slide.html#input-con-scanf-4",
    "title": "Basi di C",
    "section": "Input con scanf",
    "text": "Input con scanf\nUn puntatore è un indirizzo di memoria. Quando si passa un puntatore a una funzione, si passa l’indirizzo di memoria della variabile, non la variabile stessa. Questo permette alla funzione di scrivere direttamente nella variabile, senza doverne fare una copia."
  },
  {
    "objectID": "lessons/01/slide.html#input-con-scanf-5",
    "href": "lessons/01/slide.html#input-con-scanf-5",
    "title": "Basi di C",
    "section": "Input con scanf",
    "text": "Input con scanf\n\nAttenzione a non confonder printf e scanf, per quanto simili siano.\nscanf accetta gli stessi format specifier di printf, ma alcuni hanno meno varietà. Usate per il momento solo %d e %f.\nprintf accetta valori, scanf accetta puntatori. Bisogna ricordarsi di non scrivere & davanti alle variabili in printf e di scriverlo in scanf (quando serve).\nSi possono mettere caratteri oltre ai format specifier in una scanf, ma può creare problemi."
  },
  {
    "objectID": "lessons/01/slide.html#esercizi",
    "href": "lessons/01/slide.html#esercizi",
    "title": "Basi di C",
    "section": "Esercizi",
    "text": "Esercizi\n\nScrivere un programma che legga due numeri e stampi la somma.\n\n\n\nScrivere un programma che legga due frazioni in formato \"n/m\" e stampi la loro somma (non semplificata).\n\n\n\n\n\n\n\n\n\nConsiglio\n\n\nIn questo caso possiamo richiedere all’utente che il formato includa lo slash, e quindi includerlo nel pattern di scanf.\n\n\n\n\n\n\n\n\nDati e Algoritmi\n\n\n\n\nAltri esercizi sono disponibili a questo link."
  },
  {
    "objectID": "lessons/01/index.html",
    "href": "lessons/01/index.html",
    "title": "Basi di C",
    "section": "",
    "text": "Il linguaggio C ha la fama di linguaggio di basso livello e sintassi complicata. Nel 1972 però, questo linguaggio compariva per la prima volta per semplificare la scrittura di codice, infatti a quel tempo i programmatori scrivevano soprattutto in Assembly. Vale la pena quindi ripercorrere i punti di passaggio che hanno compartecipato alla creazione e diffusione del linguaggio.",
    "crumbs": [
      "Lezioni",
      "Basi di C"
    ]
  },
  {
    "objectID": "lessons/01/index.html#storia-e-standard",
    "href": "lessons/01/index.html#storia-e-standard",
    "title": "Basi di C",
    "section": "Storia e Standard",
    "text": "Storia e Standard\n\n\n\n\n\ntimeline\n    section Birth of C\n        1972 : nasce C (New B) presso i Bell Labs.\n        1973 : UNIX viene interamente riscritto in C.\n    section Definition of C Language\n        1978 : Kerninghan & Ritchie pubblicano The C Programming Language.\n        1989 : Primo Standard C (C89)\n    section Actual C\n        1999 : Secondo standard C (C99)\n        2011 : Terzo standard C (C11)\n\n\nPrincipali momenti storici per lo sviluppo del linguaggio C\n\n\n\n\nDopo aver scritto l’intero sistema operativo UNIX in assembly i programmatori dei Bell Laboratories si accorsero che era difficile da mantenere1, così si misero a lavorare su nuovi linguaggio, prima B e successivamente New B, ribattezzato poi C, per reimplementare del tutto UNIX in C nel 1973.\nC risultò subito un linguaggio vanataggioso da usare soprattutto per la sua portabilità (di cui discuteremo più avanti in dettaglio), così, per tutti gli anni ‘70 e 80’, il suo utilizzo si diffuse enormemente. In queste situazioni, ossia quando uno strumento di lavoro viene diffuso molto rapidamente e su larga scala, è una buona idea proporre uno Standard, cioè una serie di “regole” che chiariscano come vada usato in maniera appropriata lo strumento, in questo caso un modo comune di scrivere in C; nel 1978 Brian Kernigan e Dennis Ritchie (l’inventore di C) scrissero The C Programming Language (Kernighan e Ritchie 1978), il primo tutorial di C ma questo non era uno standard, ma negli anni 80 nacquero comunque molte varianti di C ognuna con un proprio modo di scrivere.\n\nUno Standard per tutti\n\n“The nice thing about standards is that you have so many to choose from.”, Andrew S. Tanenbaum\n\nÈ in questo scenario che si vede l’intervento dell’American National Standard Institute (ANSI) che a partire dal 1983 si mise al lavoro per proporre uno standard C concludendolo nel 1989 e successivamente approvato dall’International Organization for Standardization (ISO) nel 1990 come ISO/IEC 9899:1990, meglio conosciuto come C89. Negli anni vennero poi apportate altre migliorie al linguaggio che portarono, nel 1999, alla creazione di un nuovo standard: l’ISO/IEC 9899:1999, solitamente detto C99.\nDopo il C99 sono stati creati altri standard: C11, C17 e C23. Ognuno di questi introduce variazioni che servono a mantenere il linguaggio aggiornato alle esigenze dei programmatori attuali. Dopo la creazione di uno standard però i compilatori devono essere riscritti per comprendere le nuove regole proposte, questo fa sì che spesso non sia possibile compilare i programmi con l’ultimo standard perchè questo esiste solo da un punto di vista teorico. Attualmente i compilatori più diffusi coprono gli standard C99 e C11 ma non è ancora possibile scrivere programmi in C23.",
    "crumbs": [
      "Lezioni",
      "Basi di C"
    ]
  },
  {
    "objectID": "lessons/01/index.html#caratteristiche",
    "href": "lessons/01/index.html#caratteristiche",
    "title": "Basi di C",
    "section": "Caratteristiche",
    "text": "Caratteristiche\nIn questa sezione si discutono brevemente le caratteristiche del linguaggio C evidenziandone pregi e difetti. L’aver concluso il precedente paragrafo parlando di compilatori lascia intuire che C sia un linguaggio compilato. Questo significa che il codice sorgente scritto in C deve essere tradotto in linguaggio macchina prima di poter essere eseguito. Altri punti caratteristici di C sono l’essere minimale (C rinuncia a molte astrazioni, questo, per esempio, permette di ridurre il numero di parole chiave del linguaggio), il fatto di essere fortemente tipato (le variabili devono essere dichiarate con un tipo e non possono cambiare tipo durante l’esecuzione del programma) e il fatto di essere permissivo (il compilatore non si lamenta di errori che in altri linguaggi sarebbero considerati gravi). Tecnicamente C è un linguaggio di alto livello, ma nella pratica ha molte feature che lo rendono uno dei linguaggi di più basso livello. Specialmente sulla gestione di memoria.\n\n\n\n\n\n\nCompilare o interpretare?\n\n\n\nNon tutti i linguaggi di programmazione vanno compilati. Alcuni vengono interpretati. La differenza, semplificando, è che un linguaggio compilato viene tradotto in linguaggio macchina una volta per tutte, mentre un linguaggio interpretato viene tradotto in linguaggio macchina ogni volta che viene eseguito. Esistono moltissimi linguaggi di entrambi i tipi, e non esiste una regola che renda un sistema migliore dell’altro. Generalmente i linguaggi compilati sono più veloci, ma i linguaggi interpretati sono più flessibili. Spesso per progetti di piccole dimensioni o script i programmatori preferiscono usare linguaggi interpretati, mentre per progetti di grandi dimensioni o software che deve essere veloce si preferisce usare linguaggi compilati (non è sempre così però).\nL’alternarsi tra i due tipi di linguaggi è una questione che esiste da tempo. È importante notare a riguardo che il predecessore di C, il linguaggio B, era un linguaggio interpretato. La scelta di C di essere compilato è stata una delle ragioni del suo successo. Allo stesso modo molti linguaggi interpretati si sono diffusi proprio per essere tali.\n\n\n\nPregi e difetti\nAlcuni linguaggi sono permissivi. Al programmatore basta avere solo un senso di base di come le cose funzionano. Gli errori nel codice vengono segnalati dal sistema di compilazione o di esecuzione e il programmatore può arrangiarsi e alla fine sistemare le cose in modo che funzionino correttamente. Il linguaggio C non è così.\nIl modello di programmazione in C è che il programmatore sa esattamente cosa vuole fare e come utilizzare le possibilità del linguaggio per raggiungere quel obiettivo. Il linguaggio permette al programmatore esperto di esprimere ciò che desidera nel minor tempo possibile, rimanendo fuori dal suo cammino. C è “semplice” nel senso che il numero di componenti nel linguaggio è piccolo: se due funzionalità del linguaggio realizzano più o meno la stessa cosa, C ne includerà solo una. La sintassi di C è concisa e il linguaggio non limita ciò che è “consentito”: il programmatore può praticamente fare ciò che desidera.\nIl sistema di tipi di C e i controlli degli errori esistono solo durante la compilazione. Il codice compilato viene eseguito in un modello di esecuzione ridotto senza controlli di sicurezza per conversioni di tipo errate, indici di array errati o puntatori errati. Non c’è un garbage collector per gestire la memoria. Invece, il programmatore gestisce manualmente la memoria heap. Tutto ciò rende C veloce ma fragile.\n\n\n\n\n\n\nThe billion-dollar mistake\n\n\n\n\n“I call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn’t resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.”, Tony Hoare\n\nSeppure non sia una caratteristica introdotta con C, la null reference è un problema che affligge molti linguaggi di programmazione. Tony Hoare, scrivendo il linguaggio ALGOL W, introdusse questo concetto, C, ispirandosi fortemente ad ALGOL, ereditò questa caratteristica. L’utilizzo sbagliato di un puntatore nullo è una delle cause principali di errori in C.\n\n\nDi seguito sono commentate le caratteristiche principali considerate come i maggiori pregi e difetti del C:\n\nEfficienza: il linguaggio C è nato per essere efficiente, doveva andare a sostituire il codice Assembly, è stato scritto quindi per essere veloce;\nCompattezza: il C è un linguaggio molto compatto, non ci sono molte parole chiave, non ci sono molte funzioni predefinite, non ci sono molte strutture dati predefinite, fornisce soltanto “lo stretto indispensabile”;\nPortabilità: sebbene il C non sia stato pensato per essere portabile, la creazione di uno standard e la sua associazione con UNIX ha reso il C un linguaggio solido e usato su molte piattaforme. Uno degli slogan che accompagna il C da molti anni è “write once, compile everywhere” (scrivi una volta, compila ovunque), che poi venne ripreso con l’arrivo di Java e del suo “write once, run everywhere”;\nPermissività: il C si basa su un’assunzione molto forte: il programmatore sa cosa sta facendo. Questo è sia un pro che un contro: da un lato permette al programmatore di fare tutto quello che vuole, dall’altro lato permette al programmatore di fare tutto quello che vuole. Questo significa che il programmatore può fare cose molto potenti, ma può anche fare cose molto pericolose.\nError prone: proprio per la permissività appena menzionata, c’è spazio per fare molti errori. Questo è un problema che si può risolvere con l’uso di strumenti di analisi statica e dinamica, con l’uso di buone pratiche di programmazione e con l’uso di commenti e documentazione.\nDifficile da leggere: proprio per la compattezza, il C può diventare difficile da leggere. Esistono addirittura delle competizioni di programmazione in cui il C viene usato per scrivere codice illeggibile.\nRun time: una volta compilato, il programma C perde molte informazioni, per esempio non è più possibile conoscere i tipi delle variabili, pertanto non è possibile fare controlli a run time.\nNon Object-oriented: lo stretto indispensabile fornito da C non include gli oggetti. Questo significa che non esistono le astrazioni tipiche di Java, classi, variabili di istanza, metodi… Esistono evoluzioni del C con queste caratteristiche (C++, C# e lo stesso Java ha ereditato molto dal C).",
    "crumbs": [
      "Lezioni",
      "Basi di C"
    ]
  },
  {
    "objectID": "lessons/01/index.html#installazione",
    "href": "lessons/01/index.html#installazione",
    "title": "Basi di C",
    "section": "Installazione",
    "text": "Installazione\nPer lavorare con il C, avrete bisogno di un compilatore C. Il compilatore più diffuso è gcc, è un compilatore open source, sviluppato da GNU. Storicamente lo sviluppo in C è stato fatto su sistemi Unix, quindi gcc è facilmente compatibile con tutti i sistemi Unix-like, mentre su Windows è necessario installare un ambiente di sviluppo come MinGW. Di seguito sono riportate le istruzioni per installare il compilatore su Linux e Mac. Per Windows, le istruzioni saranno caricate su Moodle.\n\n\n\n\n\n\nLinux e Mac2\n\n\n\nDebian/Ubuntu3: per installare il compilatore: sudo apt install gcc -y\nMac: se non lo avete, facendo gcc -v il sistema vi proporrà di scaricare i tool da linea di comando di Apple. Accettando, vi verrà installato.\n\n\n\n\n\n\n\n\nWindows\n\n\n\npotete installare MinGW e modificare le variabili di PATH. Le istruzioni saranno caricate su Moodle.\n\n\n\n\n\n\nflowchart LR\nA[Start]\nB{\"Scegli OS\"}\nC[Installare MinGW o WSL 2]\nE{\"digitare\\ngcc --version\"}\nF[Installare GCC]\nG[Ready to go]\n\nA --&gt; B\nB --&gt; |Windows| C\nB --&gt; |UNIX based| E\nC --&gt; E\nE --&gt; |errore| F\nE --&gt; |stampa versione| G\nF --&gt; G\n\n\nProcesso di installazione del compilatore\n\n\n\nPer scrivere effettivamente il codice è poi richiesto di installare un editor di testo adatto al codice. Dal momento che i programmatori adorano sviluppare strumenti per la programmazione è pieno di editor di testo che più o meno si equivalgono e che, in ogni caso, ricoprono abbondantemente le necessità del corso. Alcuni esempi sono: notepad++, sublime, gedit, kate, emacs, nano, vim…\n\n\n\n\n\n\nImportante\n\n\n\nÈ sconsigliato studiare su un IDE, anche se è consigliato usarli quando si lavora effettivamente.\n\n\n\n\n\n\n\n\nImpara facendo\n\n\n\nRiscrivere tutti gli esempi di codice senza usare copia e incolla aiuta a familiarizzare con la sintassi del linguaggio e gli strumenti di lavoro. Copiando si commettono errori da cui è possibile imparare, il compilatore segnalerà gli errori e si imparerà a correggerli.",
    "crumbs": [
      "Lezioni",
      "Basi di C"
    ]
  },
  {
    "objectID": "lessons/01/index.html#la-compilazione",
    "href": "lessons/01/index.html#la-compilazione",
    "title": "Basi di C",
    "section": "La compilazione",
    "text": "La compilazione\nOra che abbiamo installato il compilatore, possiamo iniziare a scrivere i nostri primi programmi.\nPrendiamo in esame il nostro primo programma, hello.c\n#include &lt;stdio.h&gt;\n\n/* Il mio primo programma in C! */\nint main(void)\n{\n    printf(\"Hello, World!\");\n}\nRispettando la tradizione, il nostro primo programma stamperà “Hello, World!” a terminale. Per il momento non concentriamoci troppo sulla sintassi, vediamo piuttosto l’esecuzione del programma. Ma come possiamo farlo eseguire? Come già anticipato in precedenza, il nostro codice sorgente non è direttamente eseguibile, ma deve essere prima compilato. Vediamo come fare.\nNel venire compilato, il nostro programma passa attraverso altri tre programmi:\n\nPreprocessor: elimina i commenti ed esegue le direttive del preprocessore (le istruzioni che iniziano con #).\nCompiler: controlla se il codice è corretto (sintatticamente) e lo converte in linguaggio macchina, generando il codice oggetto.\nLinker: combina vari file oggetto e le librerie, producendo il file eseguibile. (a.out oppure a.exe)\n\nEsistono comandi per accedere separatamente ai vari passaggi, ma in genere viene tutto gestito da gcc (GNU C Compiler \\(\\rightarrow\\) GNU Compiler Collection)\ngcc -o &lt;nome_eseguibile&gt; &lt;sorgente.c&gt; &lt;sorgente2.c&gt; ... &lt;sorgenteN.c&gt;\nIl comando chiama il preprocessore su tutti i file, per tutti compila il file oggetto e chiama il linker che li unisce nell’unico eseguibile chiamato &lt;nome_eseguibile&gt;\n\n\n\n\n\n\nNota\n\n\n\ngcc -c &lt;sorgente.c&gt; &lt;sorgente2.c&gt; ... &lt;sorgenteN.c&gt;\nNon esegue il linking (utile se non si ha ancora il main ad esempio)",
    "crumbs": [
      "Lezioni",
      "Basi di C"
    ]
  },
  {
    "objectID": "lessons/01/index.html#sintassi-di-c",
    "href": "lessons/01/index.html#sintassi-di-c",
    "title": "Basi di C",
    "section": "Sintassi di C",
    "text": "Sintassi di C\n1#include &lt;stdio.h&gt;\n2/* Il mio primo programma in C! */\n3int main(void)\n{\n4  int anno = 2024;\n5  printf(\"Hello Dati e Algoritmi %d\", anno);\n}\n\n1\n\nDirettiva: le direttive del preprocessore iniziano con # e vengono eseguite prima del resto del codice, in questo caso includiamo la libreria standard di input/output. Ci sono due principali usi delle direttive: includere librerie e definire macro. L’istruzione #include comunica al preprocessore che il programma ha bisogno delle funzioni definite in stdio.h, la libreria standard di input/output (infatti viene usato printf). L’istruzione #define la incontreremo più avanti, ad ogni modo è un sistema che viene spesso usato per definire costanti.\n\n2\n\nCommento: i commenti in C89 iniziano con /* e terminano con */. I commenti possono essere su più righe. Dal C99 si possono usare anche i commenti monoriga (//).\n\n3\n\nFunzione: la funzione main è il punto di partenza di ogni programma C. Il tipo di ritorno è int, e accetta un singolo argomento di tipo void. Il corpo della funzione è racchiuso tra parentesi graffe {}. main è una funzione speciale che indica il punto di partenza di ogni programma C. Il tipo di ritorno int indica che la funzione restituirà un valore intero (a volte il valore di ritorno del main può essere di tipo void, ma è una pratica non consigliata). L’argomento void indica che la funzione non accetta alcun argomento, si sarebbe potuto omettere, ma è buona pratica includerlo per chiarezza e attivare il controllo del compilatore.\n\n4\n\nDichiarazione e assegnazione di variabile: int anno = 2024; dichiara una variabile di tipo int chiamata anno e le assegna il valore 2024. Storicamente la dichiarazione di variabili in C doveva avvenire all’inizio di un blocco di codice, dal C99 non è più una regola da seguire rigidamente.\n\n5\n\nChiamata di funzione: in questo caso stiamo usando la funzione printf definita in stdio.h a cui vengono passati 2 argomenti.\n\n\n\nDichiarazioni e inizializzazioni\nTutte le variabili devono essere dichiarate prima di essere usate:\nint altezza;\nfloat temperatura, peso;\nUna delle fonti d’errore maggiori in C è che non esiste l’inizializzazione di default delle variabili, prima di utilizzarle nel programma bisogna assegnare un valore, come nel seguente esempio:\nint altezza;\naltezze = 175;\nfloat temperatura = 36.4f;\nNella prima riga viene dichiarata la variabile altezza e nella seconda le viene assegnato un valore, questa procedura può essere compattata in un’unica riga come nel caso di temperatura.\n\n\n\n\n\n\nImportante\n\n\n\nQuando si dichiara una variabile il compilatore crea dello spazio nella memoria per contenere la variabile del tipo dichiarato (ogni tipo ha una dimensione diversa…), per essere più efficiente C non azzera la memoria che si trova in quello spazio, pertanto, se si andasse a leggere il valore di una variabile prima del primo assegnamento si troverebbero dei valori casuali.\n\n\n\n\nKeyword riservate\nCome detto in precedenza C è un linguaggio con poche parole chiave, quelle poche che ci sono però non possono essere usate per altri scopi, pertanto le parole sotto riportate sono da considerarsi riservate per il linguaggio e non possono essere usate per dichiarazioni di variabili o macro.\nauto     break   case    char      const      continue   default   do\ndouble   else    enum    extern    float      for        goto      if\ninline*  int     long    register  restrict*  return     short     signed\nsizeof   static  struct  switch    typedef    union      unsigned  void\nvolatile while   _Bool*  _Complex* _Imaginary*\n*solo da C99\n\n\n\n\n\n\nIl C è case sensitive\n\n\n\nNomi di variabili valide sono:\nint a, A; float Auto;\nN.B. solo perché si può non vuol dire che sia una buona idea…",
    "crumbs": [
      "Lezioni",
      "Basi di C"
    ]
  },
  {
    "objectID": "lessons/01/index.html#inputoutput",
    "href": "lessons/01/index.html#inputoutput",
    "title": "Basi di C",
    "section": "Input/Output",
    "text": "Input/Output\nDifficilmente un programma può fare a meno di interagire con l’utente o con l’ambiente esterno. In C questo avviene tramite le funzioni printf e scanf. Queste funzioni fanno parte della libreria standard stdio.h, che è disponibile di default in ogni installazione di C.\nPer comprenderle meglio, è necessario capire come funzionano i formati di stampa e di lettura. Un buon punto di partenza è il manuale di printf e scanf (che si può trovare digitando man printf e man scanf in un terminale).\n\n\n\n\n\n\nIl comando man\n\n\n\nIl comando man è un comando che permette di visualizzare il manuale di un comando o di una funzione. Il numero tra parentesi tonde dopo il nome del comando indica la sezione del manuale in cui cercare. Per esempio, man 3 printf cerca il manuale della funzione printf nella sezione 3, che contiene le funzioni di libreria.\nLe sezioni del manuale sono:\n\nProgrammi eseguibili e comandi della shell\nChiamate al sistema (funzioni fornite dal kernel)\nChiamate alle librerie (funzioni all’interno delle librerie di sistema)\nFile speciali (di solito trovabili in /dev)\nFormati dei file e convenzioni p.es. /etc/passwd\nGiochi\nPacchetti di macro e convenzioni p.es. man(7), groff(7).\nComandi per l’amministrazione del sistema (solitamente solo per root)\nRoutine del kernel [Non standard]\n\nUn buon punto di partenza per saperne di più è man man.\n\n\n\nOutput con printf\n$ man 3 printf\n\nPRINTF(3)              Linux Programmer's Manual              PRINTF(3)\n\nNAME\n       printf,  fprintf, dprintf, sprintf, snprintf, vprintf, vfprintf,\n       vdprintf, vsprintf, vsnprintf - formatted output conversion\n\nSYNOPSIS\n       #include &lt;stdio.h&gt;\n\n       int printf(const char *format, ...);\n       int fprintf(FILE *stream, const char *format, ...);\n       int dprintf(int fd, const char *format, ...);\n       int sprintf(char *str, const char *format, ...);\n       int snprintf(char *str, size_t size, const char *format, ...);\n\n...\n\nDESCRIPTION\n       The functions in the printf() family produce output according to\n       a  format  as  described  below.   The  functions  printf()  and\n       vprintf()  write  output  to stdout, the standard output stream;\n       fprintf() and  vfprintf()  write  output  to  the  given  output\n       stream; sprintf(), snprintf(), vsprintf(), and vsnprintf() write\n       to the character string str.\n\nLa pagina del manuale di printf è veramente lunga e rischia di essere un po’ dispersiva. Uno dei punti cruciali è la descrizione degli specificatori di formato, che sono i simboli che permettono di formattare l’output. Questi simboli iniziano tutti con %, e per ciascuno deve esserci un parametro dopo la stringa di formattazione.\nAd esempio %d è il simbolo per stampare un intero, printf(\"%d\", 10) pertanto stampa 10. Di seguito è riportata una lista di specificatori di formato:\n\n\n\nTabella 1: Formattazione stringhe\n\n\n\n\n\nFormat specifier\nValue\nOutput\n\n\n\n\n%c\n'm'\nm\n\n\n%d\n255\n255\n\n\n%ld\n99\n99\n\n\n%x\n255\nff\n\n\n%f\n25.8\n25.799999\n\n\n%g\n25.8\n25.8\n\n\n%s\n\"hello\"\nhello\n\n\n%8.3f\n25.8\n˽˽25.800\n\n\n%6d\n255\n˽˽˽255\n\n\n%06d\n255\n000255\n\n\n%-6d\n255\n255˽˽˽\n\n\n\n\n\n\nIl seguente codice C mette in pratica i simboli di formattazione seguendo gli esempi della tabella, si noti che, per comodità, le espressioni usate più di una volta vengono salvate in variabili:\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    char c_val = 'm';\n    int i_val = 255;\n    long int l_val = 99;\n    float f_val = 25.8;\n\n    printf(\"%c\\n\", c_val);\n    printf(\"%d\\n\", i_val);\n    printf(\"%ld\\n\", l_val);\n    printf(\"%x\\n\", i_val);\n    printf(\"%f\\n\", f_val);\n    printf(\"%g\\n\", f_val);\n    printf(\"%s\\n\", \"hello\");\n    printf(\"%8.3f\\n\", f_val);\n    printf(\"%6d\\n\", i_val);\n    printf(\"%06d\\n\", i_val);\n    printf(\"%-6d\\n\", i_val);\n}\n\nLa seguente lista invece è un elenco più esaustivo di esempi di formattazione:\n\n%d per interi, es. \\(10\\)\n%f per float, es. \\(3.14\\)\n%e per float in notazione scientifica, es. \\(5.2\\times 10^4\\)\n%lf per double, es. \\(3.14\\)\n%s per stringhe, es. \"ciao\"\n%c per caratteri, es. 'a'\n%p per puntatori, es. 0x7fffbf7f3b4c\n%x per interi in esadecimale, es. ff\n%o per interi in ottale, es. 77\n%Nf per avere \\(N\\) “spazi” per la stampa, es. %5d per 112 con due spazi vuoti prima\n%.Nf per float con \\(N\\) cifre decimali, es. %.2f per \\(3.14\\)\n\n\n\nString format\nOltre ai simboli di formattazione, ci sono anche i caratteri speciali, che si scrivono con \\ (backslash) il carattere di escaping. Questi caratteri permettono di stampare a monitor dei codici che vengono interpretati in maniera speciale. Il più comune è \\n per andare a capo, ma ce ne sono altri, di seguito una lista dei più ricorrenti:\n\n\\n per andare a capo\n\\t per tabulare\n\\b per backspace\n\\\\ per stampare il backslash\n\\\" per stampare le virgolette\n\\0 per terminare una stringa\n\n\n\nInput con scanf\nPer ricevere l’input da terminale si usa la funzione scanf, questa funzione esegue pattern matching sull’input per popolare delle variabili. Per esempio:\nint base, altezza;\nscanf(\n1    \"%d%d\",\n2    &base, &altezza\n    );\n\n1\n\nPattern: %d%d indica che si aspettano due interi\n\n2\n\nVariabili da popolare: base e altezza sono le variabili che verranno popolate con i valori letti da terminale, si noti che il tipo deve essere coerente con il pattern. Se il pattern fosse stato %f le variabili avrebbero dovuto essere di tipo float.\n\n\n\n\n\n\n\n\nAvviso\n\n\n\nscanf scorre l’input ignorando ogni carattere bianco (spazi, tabulazioni, a capo). Se trova caratteri compatibili (+/-, 0-9, .) li legge e li converte nel tipo di variabile corrispondente.\n\n\nSi noti che è stato usato lo strano simbolo & davanti alle variabili base e altezza. Questo simbolo è chiamato operatore di indirizzamento e restituisce l’indirizzo di memoria della variabile. Questo è necessario perché scanf deve scrivere direttamente nella variabile, e non può farlo se non conosce l’indirizzo di memoria. Se si dimentica il simbolo & si otterrà un errore a runtime.\nDi fatto stiamo introducendo il concetto di puntatore, che è un argomento più avanzato e verrà trattato in seguito. Per ora è sufficiente sapere che un puntatore è un indirizzo di memoria. Quando si passa un puntatore a una funzione, si passa l’indirizzo di memoria della variabile, non la variabile stessa. Questo permette alla funzione di scrivere direttamente nella variabile, senza doverne fare una copia.",
    "crumbs": [
      "Lezioni",
      "Basi di C"
    ]
  },
  {
    "objectID": "lessons/01/index.html#esercizi",
    "href": "lessons/01/index.html#esercizi",
    "title": "Basi di C",
    "section": "Esercizi",
    "text": "Esercizi\n\nScrivere un programma che legga due numeri e stampi la somma.\nScrivere un programma che legga due frazioni in formato \"n/m\" e stampi la loro somma (non semplificata).\nScrivere un programma che legga un numero e stampi il suo quadrato.\nCompilare i programmi precedenti ed esplorarli usando il debugger gdb.\n\nAltri esercizi si possono trovare a questo link.",
    "crumbs": [
      "Lezioni",
      "Basi di C"
    ]
  },
  {
    "objectID": "lessons/01/index.html#footnotes",
    "href": "lessons/01/index.html#footnotes",
    "title": "Basi di C",
    "section": "Note",
    "text": "Note\n\n\nPer codice difficile da mantenere si intendono quei codici che hanno una struttura poco adatta all’aggiunta di nuove funzionalità nel tempo.↩︎\nprobabilmente è già installato. Aprire il terminale per verificarlo con gcc –v↩︎\nper altre distribuzioni non debian based, usare il package manager di sistema↩︎",
    "crumbs": [
      "Lezioni",
      "Basi di C"
    ]
  },
  {
    "objectID": "lessons/06/slide.html#strutture-dati-1",
    "href": "lessons/06/slide.html#strutture-dati-1",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "Strutture dati",
    "text": "Strutture dati\nLe strutture sono molto utili per definire… strutture dati.\nPer esempio si possono definire array dinamici, liste concatenate, alberi, pile, code…"
  },
  {
    "objectID": "lessons/06/slide.html#array-con-strutture",
    "href": "lessons/06/slide.html#array-con-strutture",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "Array con strutture",
    "text": "Array con strutture\nGli array in C sono molto limitati, infatti dobbiamo gestire la loro lunghezza a mano…\nSi può creare una struttura che contenga un array e la sua lunghezza:\n#define MAX 1024\n\ntypedef struct intarray {\n    int array[MAX];\n    int length;\n} IntArray;"
  },
  {
    "objectID": "lessons/06/slide.html#array-con-strutture-1",
    "href": "lessons/06/slide.html#array-con-strutture-1",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "Array con strutture",
    "text": "Array con strutture\nAdesso si può passare la struttura come argomento di una funzione:\nvoid stampa_array(IntArray a) {\n    for (int i = 0; i &lt; a.length; i++) {\n        printf(\"%d \", a.array[i]);\n    }\n    printf(\"\\n\");\n}\nSi nota subito che non abbiamo più bisogno di passare la lunghezza dell’array come argomento."
  },
  {
    "objectID": "lessons/06/slide.html#array-con-strutture-2",
    "href": "lessons/06/slide.html#array-con-strutture-2",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "Array con strutture",
    "text": "Array con strutture\nint append(IntArray *a, int value) {\n    if (a-&gt;length &lt; MAX) {\n        a-&gt;array[a-&gt;length] = value;\n        a-&gt;length++;\n        return 0;\n    }\n    return 1;\n}"
  },
  {
    "objectID": "lessons/06/slide.html#array-con-strutture-3",
    "href": "lessons/06/slide.html#array-con-strutture-3",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "Array con strutture",
    "text": "Array con strutture\nL’implementazione che abbiamo visto ha due grossi problemi:\n\nla dimensione dell’array è fissa\nla struttura IntArray funziona solo con array di interi, per fare array di float, char, ecc. bisogna creare ogni volta una nuova struttura"
  },
  {
    "objectID": "lessons/06/slide.html#memoria-dinamica-1",
    "href": "lessons/06/slide.html#memoria-dinamica-1",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "Memoria dinamica",
    "text": "Memoria dinamica\n\nLe strutture dati in C hanno dimensione fissa. Infatti gli array vengono inizializzati con un valore costante.\nEsistono però dei comandi che permettono di allocare dinamicamente zone di memoria, permettendo di fare strutture che crescono o si rimpiccioliscono durante l’esecuzione del programma."
  },
  {
    "objectID": "lessons/06/slide.html#memoria-dinamica-2",
    "href": "lessons/06/slide.html#memoria-dinamica-2",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "Memoria dinamica",
    "text": "Memoria dinamica\nLe operazioni per gestire la memoria dinamica si trovano nella libreria stdlib.h e sono:\n\nmalloc (memory allocation): alloca una zona di memoria di una certa dimensione\ncalloc (clear allocation): alloca una zona di memoria di una certa dimensione e la inizializza a 0\nrealloc (reallocate): cambia la dimensione di una zona di memoria già allocata"
  },
  {
    "objectID": "lessons/06/slide.html#puntatore-a-void",
    "href": "lessons/06/slide.html#puntatore-a-void",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "Puntatore a void",
    "text": "Puntatore a void\nmalloc, calloc e realloc restituiscono un puntatore a void, che è un puntatore generico.\nQuesto puntatore non fa riferimento a un certo tipo di dato, ma solo a un indirizzo di memoria."
  },
  {
    "objectID": "lessons/06/slide.html#malloc",
    "href": "lessons/06/slide.html#malloc",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "malloc",
    "text": "malloc\nvoid* malloc(size_t size);\nSupponendo di voler creare un array di interi di dimensione variabile, c’è bisogno di creare un puntatore ad interi e poi assegnargli l’indirizzo della nuova zona di memoria:\nint *a;\na = malloc(10 * sizeof(int));\nLa funzione malloc accetta come argomento il numero di byte da allocare. L’esempio crea 10 cellette di memoria, ciascuna grande quanto un intero (4 byte)."
  },
  {
    "objectID": "lessons/06/slide.html#calloc",
    "href": "lessons/06/slide.html#calloc",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "calloc",
    "text": "calloc\nvoid* calloc(size_t num, size_t size);\n\nPer inizializzare array torna comoda anche la funzione calloc, che ha due parametri: numero di membri e dimensione (in byte) dei membri\nInoltre ha come effetto aggiuntivo di porre a zero tutti i byte interessati (quindi tutti i membri dell’array che creo)\n\ndouble *a;\na = calloc(10, sizeof(double));\nL’effetto di questo codice è lo stesso del precedente (con la malloc), ma con tutti i membri dell’array inizializzati a 0."
  },
  {
    "objectID": "lessons/06/slide.html#realloc",
    "href": "lessons/06/slide.html#realloc",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "realloc",
    "text": "realloc\nvoid* realloc(void* ptr, size_t size);\n\nQuesta funzione cambia la dimensione di uno spazio allocato dinamicamente.\nL’argomento ptr deve essere un puntatore ottenuto da una funzione ..alloc, altrimenti porta a comportamento non definito.\nI dati già presenti nella zona di memoria vengono mantenuti."
  },
  {
    "objectID": "lessons/06/slide.html#null",
    "href": "lessons/06/slide.html#null",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "NULL",
    "text": "NULL\n\nQuando si usa la memoria dinamica, è importante controllare che l’allocazione sia andata a buon fine.\nSe malloc, calloc o realloc non riescono a trovare spazio in memoria, restituiscono NULL.\nNULL è una costante che rappresenta un puntatore all’indirizzo 0x0. NULL è definito in stdlib.h."
  },
  {
    "objectID": "lessons/06/slide.html#malloc-calloc-realloc",
    "href": "lessons/06/slide.html#malloc-calloc-realloc",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "malloc, calloc, realloc",
    "text": "malloc, calloc, realloc\n\nQueste funzioni scrivono in una zona di memoria nota come heap;\nLe variabili locali e i parametri delle funzioni sono invece memorizzati nello stack;\nUsando ricorsione e molta memoria dinamica si può esaurire la memoria disponibile\nOccorre quindi fare uso oculato della memoria e pulire quella usata che non serve più"
  },
  {
    "objectID": "lessons/06/slide.html#free",
    "href": "lessons/06/slide.html#free",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "free",
    "text": "free\nvoid free(void* ptr);\n\nLa funzione free permette di liberare un blocco di memoria (e quindi renderlo disponibile per un’altra allocazione)\nptr dopo l’esecuzione di free continua a puntare alla stessa zona di memoria, ma il contenuto di quella zona non è più garantito, si chiama dangling pointer\nOccorre, subito dopo la free, assegnare a ptr il valore NULL (oppure una nuova memoria)\naccedere un blocco deallocato è un gravissimo errore"
  },
  {
    "objectID": "lessons/06/slide.html#array-dinamico",
    "href": "lessons/06/slide.html#array-dinamico",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "Array dinamico",
    "text": "Array dinamico\nUn array dinamico è un array la cui dimensione può cambiare durante l’esecuzione del programma.\nPer implementare un array dinamico si può usare una struttura che contiene un puntatore all’array e la sua lunghezza:\ntypedef struct {\n    int *array;\n    int capacity;\n    int length;\n} ArrayList;"
  },
  {
    "objectID": "lessons/06/slide.html#arraylist",
    "href": "lessons/06/slide.html#arraylist",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "ArrayList",
    "text": "ArrayList\nIl nuovo tipo ArrayList ha tre membri:\n\narray è un puntatore ad interi, che punta all’array dinamico\ncapacity è la dimensione massima dell’array\nlength è il numero di elementi attualmente presenti nell’array\n\nQuando length raggiunge capacity, bisogna riallocare la memoria per l’array, aumentando la sua dimensione.\nScarica l’implementazione dell’arraylist"
  },
  {
    "objectID": "lessons/06/slide.html#linked-list",
    "href": "lessons/06/slide.html#linked-list",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "Linked list",
    "text": "Linked list\n\nUna lista concatenata è una struttura dati composta da nodi, ciascuno dei quali contiene un valore e un puntatore al nodo successivo.\nLa differenza con un array è che i nodi non sono memorizzati in posizioni contigue di memoria.\nLa lista concatenata è una struttura ricorsiva: un nodo contiene un valore e un puntatore al nodo successivo."
  },
  {
    "objectID": "lessons/06/slide.html#linked-list-1",
    "href": "lessons/06/slide.html#linked-list-1",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "Linked list",
    "text": "Linked list\nL’implementazione classica della lista concatenata in C è:\ntypedef struct node {\n    int value;\n    struct node *next;\n} Node;\nScarica l’implementazione della linked list"
  },
  {
    "objectID": "lessons/06/slide.html#esercizio-lista-concatenata",
    "href": "lessons/06/slide.html#esercizio-lista-concatenata",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "Esercizio: lista concatenata",
    "text": "Esercizio: lista concatenata\nDato il file con il main e i prototipi delle funzioni, implementare:\n\nrecursive_list_print\nrecursive_list_delete"
  },
  {
    "objectID": "lessons/06/slide.html#operatori-bitwise",
    "href": "lessons/06/slide.html#operatori-bitwise",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "Operatori bitwise",
    "text": "Operatori bitwise\nGli operatori bitwise permettono di effettuare calcoli al livello dei bit delle variabili.\nGli operatori bitwise in C sono:\n\n& AND\n| OR\n^ XOR\n~ NOT\n&lt;&lt; Shift a sinistra\n&gt;&gt; Shift a destra"
  },
  {
    "objectID": "lessons/06/slide.html#calcoli",
    "href": "lessons/06/slide.html#calcoli",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "Calcoli",
    "text": "Calcoli\nQuesti operatori applicano le regole dell’algebra booleana, pertanto sarà importante conoscere le tabelle di verità delle operazioni AND, OR e XOR.\n\n\n\nA\nB\nA & B\nA\nB\nA ^ B\n\n\n\n\n0\n0\n0\n0\n0\n1\n\n\n0\n1\n0\n1\n1\n0\n\n\n1\n0\n0\n1\n1\n0\n\n\n1\n1\n1\n1\n0\n1"
  },
  {
    "objectID": "lessons/06/slide.html#la-rappresentazione-dei-numeri",
    "href": "lessons/06/slide.html#la-rappresentazione-dei-numeri",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "La rappresentazione dei numeri",
    "text": "La rappresentazione dei numeri\nPer effettuare le operazioni bitwise conviene sempre cercare di rappresentare i numeri in binario.\nC permette di dichiarare numeri in binario utilizzando il prefisso 0b:\nunsigned char switches = 0b00001000;\n// è equivalente a\nunsigned char switches = 8;"
  },
  {
    "objectID": "lessons/06/slide.html#or",
    "href": "lessons/06/slide.html#or",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "OR",
    "text": "OR\nL’operatore OR viene spesso usato per unire due insiemi di bit. Ad esempio, se si ha una variabile switches che rappresenta lo stato di accensione di 8 interruttori, si può accendere un interruttore utilizzando l’operatore OR:\n// switches = 0b00001000\nswitches = switches | 0b00000100;\n// oppure\nswitches = switches | 4;\nOra il valore di switches sarà 0b00001100. Il che rappresenta il fatto che gli interruttori 3 e 4 sono accesi."
  },
  {
    "objectID": "lessons/06/slide.html#and",
    "href": "lessons/06/slide.html#and",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "AND",
    "text": "AND\nPer spegnere tutti gli interruttori si può utilizzare l’operatore AND:\nswitches = switches & 0b00000000;\n// oppure\nswitches = switches & 0;\n// switches: 0b00000000"
  },
  {
    "objectID": "lessons/06/slide.html#esercizio",
    "href": "lessons/06/slide.html#esercizio",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "Esercizio",
    "text": "Esercizio\nScrivere un programma che stampi a monitor il valore del bit meno significativo di un numero intero.\n#include &lt;stdio.h&gt;\nvoid print_lsb(int n);\n\nint main(void)\n{\n    int a = 127, b = 128;\n\n    print_lsb(a);\n    print_lsb(b);\n}\n\nvoid print_lsb(int n)\n{\n    printf(\"The least significant bit of %d is: \", n);\n    printf(\"%d\\n\", n & 1);\n}"
  },
  {
    "objectID": "lessons/06/slide.html#esercizio-1",
    "href": "lessons/06/slide.html#esercizio-1",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "Esercizio",
    "text": "Esercizio\nScrivere una funzione che dato un numero intero \\(n\\), restituisca true se \\(n\\) è pari, false altrimenti. Usare l’operatore AND per verificare se un numero è pari.\n#include &lt;stdbool.h&gt;\nbool is_even(int n);\n\nint main(void) {\n    int a = 55, b = 48;\n\n    printf(\"%d is even: %d\\n\", a, is_even(a));\n    printf(\"%d is even: %d\\n\", b, is_even(b));\n}"
  },
  {
    "objectID": "lessons/06/slide.html#xor",
    "href": "lessons/06/slide.html#xor",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "XOR",
    "text": "XOR\nL’operatore XOR è molto utile per invertire lo stato di un bit.\n\n\n\n\n\n\nNota\n\n\nEseguire l’operazione di XOR due volte su un bit restituisce il valore originale.\nchar c = 'A';\nc = c ^ 'h';\nc = c ^ 'h';\n// c: 'A'"
  },
  {
    "objectID": "lessons/06/slide.html#esempio",
    "href": "lessons/06/slide.html#esempio",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "Esempio",
    "text": "Esempio\n65: 0b01000001\n73: 0b01001001\n08: 0b00001000\n65 ^ 73 = 8\n8 ^ 73 = 65\n‘A’ ^ ‘I’ = ’"
  },
  {
    "objectID": "lessons/06/slide.html#esempio-1",
    "href": "lessons/06/slide.html#esempio-1",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "Esempio",
    "text": "Esempio\n#include &lt;stdio.h&gt;\n#define KEY 'h'\n\nint main(void)\n{\n    char c = 'A';\n    c = c ^ KEY;\n    printf(\"%c\\n\", c);\n\n    c = c ^ KEY;\n    printf(\"%c\\n\", c);\n}"
  },
  {
    "objectID": "lessons/06/slide.html#esercizi",
    "href": "lessons/06/slide.html#esercizi",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "Esercizi",
    "text": "Esercizi\nScrivere un programma di semplice crittografia in grado di cifrare e decifrare una stringa utilizzando l’operatore XOR.\nScarica il main dell’esercizio"
  },
  {
    "objectID": "lessons/06/slide.html#shift",
    "href": "lessons/06/slide.html#shift",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "Shift",
    "text": "Shift\nGli operatori di shift permettono di spostare i bit di una variabile a sinistra o a destra.\nunsigned char c = 0b00000001;\nc = c &lt;&lt; 1;\n// c: 0b00000010\nc = c &lt;&lt; 3;\n// c: 0b00010000\nc = c &gt;&gt; 2;\n// c: 0b00000100"
  },
  {
    "objectID": "lessons/06/slide.html#esempio-shift",
    "href": "lessons/06/slide.html#esempio-shift",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "Esempio Shift",
    "text": "Esempio Shift\nScrivere un programma che moltiplichi un numero intero per 2 utilizzando l’operatore di shift.\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    int n = 5;\n    n = n &lt;&lt; 1;\n    printf(\"%d\\n\", n);\n}"
  },
  {
    "objectID": "lessons/06/slide.html#esercizi-1",
    "href": "lessons/06/slide.html#esercizi-1",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "Esercizi",
    "text": "Esercizi\nScrivere un programma che stampi a monitor la codifica in binario di un unsigned char.\nAd esempio, se il valore di c è 5, il programma dovrà stampare 00000101."
  },
  {
    "objectID": "lessons/06/slide.html#esercizi-2",
    "href": "lessons/06/slide.html#esercizi-2",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "Esercizi",
    "text": "Esercizi\nImmaginando che una serie di 8 bit rappresenti lo stato di accensione di 8 led, scrivere un programma che:\n\nAccenda il led più a destra;\nAccenda il led più a sinistra;\nInverta lo stato di tutti i led;\nSpenga tutti i led.\n\nScarica il main dell’esercizio\n\n\n\n\nDati e Algoritmi"
  },
  {
    "objectID": "lessons/06/index.html",
    "href": "lessons/06/index.html",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "",
    "text": "Le strutture sono molto utili per definire… strutture dati. Per esempio si possono definire array dinamici, liste concatenate, alberi, pile, code…\nGli array in C sono molto limitati, infatti dobbiamo gestire la loro lunghezza a mano, ad esempio passandola come argomento di una funzione.\nSi può creare una struttura che contenga un array e la sua lunghezza:\n\n\n\nLista 1: Implementazione di un array di interi con lunghezza variabile.\n\n\n#define MAX 1024 /* &lt;1&gt; */\n\ntypedef struct intarray {\n    int array[MAX]; /* &lt;2&gt; */\n    int length; /* &lt;3&gt; */\n} IntArray;\n\n\n\n\nDefiniamo una costante MAX che rappresenta il numero massimo di elementi che possono essere memorizzati nell’array;\nLa struttura dati contiene l’array di interi (che, in questo caso, è di dimensione \\(1024 \\times 4 = 4096\\) byte)\nLa struttura contiene anche un intero che rappresenta la lunghezza attuale dell’array: cioè il numero di elementi effettivamente contenuti dall’array.\n\nSi noti che il membro lenght è aggiornato solo quando si aggiungono o rimuovono elementi dall’array.\nAdesso si può passare la struttura come argomento di una funzione, senza dover tenere traccia in maniera esplicita della lunghezza dell’array:\n\n\n\nLista 2: Implementazione della funzione per stampare un IntArray.\n\n\nvoid stampa_array(IntArray a) {\n    for (int i = 0; i &lt; a.length; i++) {\n        printf(\"%d \", a.array[i]);\n    }\n    printf(\"\\n\");\n}\n\n\n\nLa routine per aggiungere un elemento all’array è la seguente:\n1int append(IntArray *a, int value) {\n2    if (a-&gt;length &lt; MAX) {\n3        a-&gt;array[a-&gt;length] = value;\n4        a-&gt;length++;\n5        return 0;\n    }\n6    return 1;\n}\n\n1\n\nLa funzione append prende come argomento un puntatore a IntArray e un intero da aggiungere all’array, l’array è passato by reference perché i suoi campi vengono modificati;\n\n2\n\nPrima di effettuare l’inserimento viene controllato che l’array non sia già pieno, per accedere ai membri di un puntatore a una struttura si usa l’operatore -&gt;, che è una forma abbreviata di (*p).membro;\n\n3\n\nSi aggiunge il valore all’array;\n\n4\n\nSi incrementa la lunghezza dell’array;\n\n5\n\nLa funzione restituisce 0 se l’inserimento è andato a buon fine;\n\n6\n\nRestituisce 1 se l’array è pieno.\n\n\n\n\nPer esercizio si implementino le funzioni: 1. int get(IntArray a, int index) che restituisce l’elemento in posizione index dell’array a; 2. int insert(IntArray *a, int index, int value) che inserisce l’elemento value in posizione index dell’array a; 3. int remove(IntArray *a, int index) che rimuove l’elemento in posizione index dell’array a.\n\n\n\n\n\n\nConsiglio\n\n\n\nSi noti che le funzioni insert e remove possono fallire se l’array è pieno o vuoto, rispettivamente, inoltre è necessario spostare tutti gli elementi dell’array.",
    "crumbs": [
      "Lezioni",
      "Memoria dinamica e operatori bitwise"
    ]
  },
  {
    "objectID": "lessons/06/index.html#esercizio-2",
    "href": "lessons/06/index.html#esercizio-2",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "",
    "text": "Per esercizio si implementino le funzioni: 1. int get(IntArray a, int index) che restituisce l’elemento in posizione index dell’array a; 2. int insert(IntArray *a, int index, int value) che inserisce l’elemento value in posizione index dell’array a; 3. int remove(IntArray *a, int index) che rimuove l’elemento in posizione index dell’array a.\n\n\n\n\n\n\nConsiglio\n\n\n\nSi noti che le funzioni insert e remove possono fallire se l’array è pieno o vuoto, rispettivamente, inoltre è necessario spostare tutti gli elementi dell’array.",
    "crumbs": [
      "Lezioni",
      "Memoria dinamica e operatori bitwise"
    ]
  },
  {
    "objectID": "lessons/06/index.html#malloc-1",
    "href": "lessons/06/index.html#malloc-1",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "malloc",
    "text": "malloc\nvoid* malloc(size_t size);\nSupponendo di voler creare un array di interi di dimensione variabile, c’è bisogno di creare un puntatore ad interi e poi assegnargli l’indirizzo della nuova zona di memoria:\nint *a;\na = malloc(10 * sizeof(int));\nLa funzione malloc accetta come argomento il numero di byte da allocare. L’esempio crea 10 cellette di memoria, ciascuna grande quanto un intero (4 byte).",
    "crumbs": [
      "Lezioni",
      "Memoria dinamica e operatori bitwise"
    ]
  },
  {
    "objectID": "lessons/06/index.html#calloc-1",
    "href": "lessons/06/index.html#calloc-1",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "calloc",
    "text": "calloc\nvoid* calloc(size_t num, size_t size);\n\nPer inizializzare array torna comoda anche la funzione calloc, che ha due parametri: numero di membri e dimensione (in byte) dei membri\nInoltre ha come effetto aggiuntivo di porre a zero tutti i byte interessati (quindi tutti i membri dell’array che creo)\n\ndouble *a;\na = calloc(10, sizeof(double));\nL’effetto di questo codice è lo stesso del precedente (con la malloc), ma con tutti i membri dell’array inizializzati a 0.",
    "crumbs": [
      "Lezioni",
      "Memoria dinamica e operatori bitwise"
    ]
  },
  {
    "objectID": "lessons/06/index.html#realloc-1",
    "href": "lessons/06/index.html#realloc-1",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "realloc",
    "text": "realloc\nvoid* realloc(void* ptr, size_t size);\n\nQuesta funzione cambia la dimensione di uno spazio allocato dinamicamente.\nL’argomento ptr deve essere un puntatore ottenuto da una funzione ..alloc, altrimenti porta a comportamento non definito.\nI dati già presenti nella zona di memoria vengono mantenuti.",
    "crumbs": [
      "Lezioni",
      "Memoria dinamica e operatori bitwise"
    ]
  },
  {
    "objectID": "lessons/06/index.html#null-1",
    "href": "lessons/06/index.html#null-1",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "NULL",
    "text": "NULL\n\nQuando si usa la memoria dinamica, è importante controllare che l’allocazione sia andata a buon fine.\nSe malloc, calloc o realloc non riescono a trovare spazio in memoria, restituiscono NULL.\nNULL è una costante che rappresenta un puntatore all’indirizzo 0x0. NULL è definito in stdlib.h.",
    "crumbs": [
      "Lezioni",
      "Memoria dinamica e operatori bitwise"
    ]
  },
  {
    "objectID": "lessons/06/index.html#malloc-calloc-realloc-1",
    "href": "lessons/06/index.html#malloc-calloc-realloc-1",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "malloc, calloc, realloc",
    "text": "malloc, calloc, realloc\n\nQueste funzioni scrivono in una zona di memoria nota come heap;\nLe variabili locali e i parametri delle funzioni sono invece memorizzati nello stack;\nUsando ricorsione e molta memoria dinamica si può esaurire la memoria disponibile\nOccorre quindi fare uso oculato della memoria e pulire quella usata che non serve più",
    "crumbs": [
      "Lezioni",
      "Memoria dinamica e operatori bitwise"
    ]
  },
  {
    "objectID": "lessons/06/index.html#free-1",
    "href": "lessons/06/index.html#free-1",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "free",
    "text": "free\nvoid free(void* ptr);\n\nLa funzione free permette di liberare un blocco di memoria (e quindi renderlo disponibile per un’altra allocazione)\nptr dopo l’esecuzione di free continua a puntare alla stessa zona di memoria, ma il contenuto di quella zona non è più garantito, si chiama dangling pointer\nOccorre, subito dopo la free, assegnare a ptr il valore NULL (oppure una nuova memoria)\naccedere un blocco deallocato è un gravissimo errore",
    "crumbs": [
      "Lezioni",
      "Memoria dinamica e operatori bitwise"
    ]
  },
  {
    "objectID": "lessons/06/index.html#array-dinamico-1",
    "href": "lessons/06/index.html#array-dinamico-1",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "Array dinamico",
    "text": "Array dinamico\nUn array dinamico è un array la cui dimensione può cambiare durante l’esecuzione del programma.\nPer implementare un array dinamico si può usare una struttura che contiene un puntatore all’array e la sua lunghezza:\ntypedef struct {\n    int *array;\n    int capacity;\n    int length;\n} ArrayList;",
    "crumbs": [
      "Lezioni",
      "Memoria dinamica e operatori bitwise"
    ]
  },
  {
    "objectID": "lessons/06/index.html#arraylist-1",
    "href": "lessons/06/index.html#arraylist-1",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "ArrayList",
    "text": "ArrayList\nIl nuovo tipo ArrayList ha tre membri:\n\narray è un puntatore ad interi, che punta all’array dinamico\ncapacity è la dimensione massima dell’array\nlength è il numero di elementi attualmente presenti nell’array\n\nQuando length raggiunge capacity, bisogna riallocare la memoria per l’array, aumentando la sua dimensione.\n Scarica l'implementazione dell'arraylist",
    "crumbs": [
      "Lezioni",
      "Memoria dinamica e operatori bitwise"
    ]
  },
  {
    "objectID": "lessons/06/index.html#linked-list-2",
    "href": "lessons/06/index.html#linked-list-2",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "Linked list",
    "text": "Linked list\n\nUna lista concatenata è una struttura dati composta da nodi, ciascuno dei quali contiene un valore e un puntatore al nodo successivo.\nLa differenza con un array è che i nodi non sono memorizzati in posizioni contigue di memoria.\nLa lista concatenata è una struttura ricorsiva: un nodo contiene un valore e un puntatore al nodo successivo.",
    "crumbs": [
      "Lezioni",
      "Memoria dinamica e operatori bitwise"
    ]
  },
  {
    "objectID": "lessons/06/index.html#linked-list-3",
    "href": "lessons/06/index.html#linked-list-3",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "Linked list",
    "text": "Linked list\nL’implementazione classica della lista concatenata in C è:\ntypedef struct node {\n    int value;\n    struct node *next;\n} Node;\n Scarica l'implementazione dell'arraylist \nUn esempio completo in cui vengono implementate le classi ArrayList e LinkedList, oltre all’interfaccia List, è disponibile qui.",
    "crumbs": [
      "Lezioni",
      "Memoria dinamica e operatori bitwise"
    ]
  },
  {
    "objectID": "lessons/06/index.html#calcoli-1",
    "href": "lessons/06/index.html#calcoli-1",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "Calcoli",
    "text": "Calcoli\nQuesti operatori applicano le regole dell’algebra booleana, pertanto sarà importante conoscere le tabelle di verità delle operazioni AND, OR e XOR.\n\n\n\nA\nB\nA AND B\nA OR B\nA XOR B\n\n\n\n\n0\n0\n0\n0\n0\n\n\n0\n1\n0\n1\n1\n\n\n1\n0\n0\n1\n1\n\n\n1\n1\n1\n1\n0",
    "crumbs": [
      "Lezioni",
      "Memoria dinamica e operatori bitwise"
    ]
  },
  {
    "objectID": "lessons/06/index.html#esempi",
    "href": "lessons/06/index.html#esempi",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "Esempi",
    "text": "Esempi\nIn elettronica digitale, spesso si utilizzano serie di bit per rappresentare lo stato di un sistema. Ad esempio, si può utilizzare un byte per rappresentare lo stato di 8 interruttori. Supponiamo che l’interruttore 3 sia acceso e gli altri spenti. Per rappresentare lo stato degli interruttori si può utilizzare una variabile di tipo char:\nunsigned char switches = 0b00001000;\n// oppure\nunsigned char switches = 8;\nIn questa configurazione il quarto bit interruttore è acceso, mentre gli altri sono spenti.\nIpotizzando di voler accendere un altro interruttore, si può utilizzare l’operatore OR:\n// switches = 0b00001000\nswitches = switches | 0b00000100;\n// oppure\nswitches = switches | 4;\nOra il valore di switches sarà 0b00001100. Il che rappresenta il fatto che gli interruttori 3 e 4 sono accesi.\nPer spegnere tutti gli interruttori si può utilizzare l’operatore AND:\nswitches = switches & 0b00000000;\n// oppure\nswitches = switches & 0;\n// switches: 0b00000000",
    "crumbs": [
      "Lezioni",
      "Memoria dinamica e operatori bitwise"
    ]
  },
  {
    "objectID": "lessons/06/index.html#esercizio-3",
    "href": "lessons/06/index.html#esercizio-3",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "Esercizio",
    "text": "Esercizio\nScrivere un programma che stampi a monitor il valore del bit meno significativo di un numero intero.\n#include &lt;stdio.h&gt;\nvoid print_lsb(int n);\n\nint main(void)\n{\n    int a = 127, b = 128;\n\n    print_lsb(a);\n    print_lsb(b);\n}\n\nvoid print_lsb(int n)\n{\n    printf(\"The least significant bit of %d is: \", n);\n    printf(\"%d\\n\", n & 1);\n}",
    "crumbs": [
      "Lezioni",
      "Memoria dinamica e operatori bitwise"
    ]
  },
  {
    "objectID": "lessons/06/index.html#esercizio-4",
    "href": "lessons/06/index.html#esercizio-4",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "Esercizio",
    "text": "Esercizio\nScrivere una funzione che dato un numero intero \\(n\\), restituisca true se \\(n\\) è pari, false altrimenti. Usare l’operatore AND per verificare se un numero è pari.\n#include &lt;stdbool.h&gt;\nbool is_even(int n);\n\nint main(void) {\n    int a = 55, b = 48;\n\n    printf(\"%d is even: %d\\n\", a, is_even(a));\n    printf(\"%d is even: %d\\n\", b, is_even(b));\n}\nL’operatore XOR è molto utile per invertire lo stato di un bit.\n\n\n\n\n\n\nNota\n\n\n\nEseguire l’operazione di XOR due volte su un bit restituisce il valore originale.\nchar c = 'A';\nc = c ^ 'h';\nc = c ^ 'h';\n// c: 'A'",
    "crumbs": [
      "Lezioni",
      "Memoria dinamica e operatori bitwise"
    ]
  },
  {
    "objectID": "lessons/06/index.html#esempio-2",
    "href": "lessons/06/index.html#esempio-2",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "Esempio",
    "text": "Esempio\n65: 0b01000001\n73: 0b01001001\n08: 0b00001000\n65 ^ 73 = 8\n8 ^ 73 = 65\n‘A’ ^ ‘I’ = ’",
    "crumbs": [
      "Lezioni",
      "Memoria dinamica e operatori bitwise"
    ]
  },
  {
    "objectID": "lessons/06/index.html#esempio-3",
    "href": "lessons/06/index.html#esempio-3",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "Esempio",
    "text": "Esempio\n#include &lt;stdio.h&gt;\n#define KEY 'h'\n\nint main(void)\n{\n    char c = 'A';\n    c = c ^ KEY;\n    printf(\"%c\\n\", c);\n\n    c = c ^ KEY;\n    printf(\"%c\\n\", c);\n}",
    "crumbs": [
      "Lezioni",
      "Memoria dinamica e operatori bitwise"
    ]
  },
  {
    "objectID": "lessons/06/index.html#esercizi-3",
    "href": "lessons/06/index.html#esercizi-3",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "Esercizi",
    "text": "Esercizi\nScrivere un programma di semplice crittografia in grado di cifrare e decifrare una stringa utilizzando l’operatore XOR.\n Scarica il main dell'esercizio",
    "crumbs": [
      "Lezioni",
      "Memoria dinamica e operatori bitwise"
    ]
  },
  {
    "objectID": "lessons/06/index.html#shift-1",
    "href": "lessons/06/index.html#shift-1",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "Shift",
    "text": "Shift\nGli operatori di shift permettono di spostare i bit di una variabile a sinistra o a destra.\nunsigned char c = 0b00000001;\nc = c &lt;&lt; 1;\n// c: 0b00000010\nc = c &lt;&lt; 3;\n// c: 0b00010000\nc = c &gt;&gt; 2;\n// c: 0b00000100",
    "crumbs": [
      "Lezioni",
      "Memoria dinamica e operatori bitwise"
    ]
  },
  {
    "objectID": "lessons/06/index.html#esempio-shift-1",
    "href": "lessons/06/index.html#esempio-shift-1",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "Esempio Shift",
    "text": "Esempio Shift\nScrivere un programma che moltiplichi un numero intero per 2 utilizzando l’operatore di shift.\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    int n = 5;\n    n = n &lt;&lt; 1;\n    printf(\"%d\\n\", n);\n}",
    "crumbs": [
      "Lezioni",
      "Memoria dinamica e operatori bitwise"
    ]
  },
  {
    "objectID": "lessons/06/index.html#esercizi-4",
    "href": "lessons/06/index.html#esercizi-4",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "Esercizi",
    "text": "Esercizi\nScrivere un programma che stampi a monitor la codifica in binario di un unsigned char.\nAd esempio, se il valore di c è 5, il programma dovrà stampare 00000101.",
    "crumbs": [
      "Lezioni",
      "Memoria dinamica e operatori bitwise"
    ]
  },
  {
    "objectID": "lessons/06/index.html#esercizi-5",
    "href": "lessons/06/index.html#esercizi-5",
    "title": "Memoria dinamica e operatori bitwise",
    "section": "Esercizi",
    "text": "Esercizi\nImmaginando che una serie di 8 bit rappresenti lo stato di accensione di 8 led, scrivere un programma che:\n\nAccenda il led più a destra;\nAccenda il led più a sinistra;\nInverta lo stato di tutti i led;\nSpenga tutti i led.\n\n Scarica il main dell'esercizio",
    "crumbs": [
      "Lezioni",
      "Memoria dinamica e operatori bitwise"
    ]
  },
  {
    "objectID": "lessons.html",
    "href": "lessons.html",
    "title": "Lezioni",
    "section": "",
    "text": "Le lezioni sono organizzate in maniera da illustrare di volta in volta un argomento specifico, prima da un punto di vista teorico e poi da un punto di vista pratico. Gli eserci sono propedeutici e servono a fissare i concetti appresi, ma anche a stimolare la creatività e la capacità di problem solving, pertanto è importante svolgerli con attenzione e dedizione seppure non siano obbligatori."
  },
  {
    "objectID": "lessons.html#calendario",
    "href": "lessons.html#calendario",
    "title": "Lezioni",
    "section": "Calendario",
    "text": "Calendario\n\n\n\nData\nArgomento\nCapitoli del libro di testo\n\n\n\n\n12/03/2024\nIntroduzione al corso e fondamenti di C\n1-3\n\n\n19/03/2024\nStrutture di controllo e tipi di base\n4-7\n\n\n26/03/2024\nFunzioni e array\n8-9\n\n\n09/04/2024\nPuntatori\n11-12\n\n\n10/04/2024\nStruct e puntatori\n15-17\n\n\n23/04/2024\nMemoria dinamica e operatori bitwise\n20\n\n\n21/05/2024\nPreparazione per l’esame\n–\n\n\n25/06/2024\nPrimo appello\n–\n\n\n09/07/2024\nSecondo appello\n–"
  },
  {
    "objectID": "faq.html",
    "href": "faq.html",
    "title": "FAQ",
    "section": "",
    "text": "Io conosco Python, Ruby, Haskell, Kotlin, Perl e ieri ho implementato un compilatore per il mio unico e innovativo linguaggio di programmazione. Perché dovrei imparare C?\n\nAffermazioni del tipo “Il nostro linguaggio è veloce quasi quanto il C, ma è più facile da scrivere” sono così comuni da diventare quasi cliché. Bene, C è sicuramente veloce quanto C, e lo scopo del corso è facilitare la comprensione di un linguaggio spesso conosciuto come ostico. La comprensione di un linguaggio che non astrae molti concetti e lascia molta responsabilità al programmatore è importante per avere delle solide basi su concetti che pervadono tutti i linguaggi di programmazione.\n\nIl mio telefono ha 6 GB di RAM, quindi perché i libri di testo dedicano così tante pagine a tecniche per risparmiare kilobytes di peso ai file eseguibili?\nIl mio vecchissimo computer riesce ad eseguire 3,200,000,000 istruzioni al secondo, perché dovrei interessarmi se un’operazione confronta 8 o 16 bit?\n\nDovremmo scrivere codice che possiamo scrivere velocemente e che sia leggibile dai nostri simili. Stiamo ancora scrivendo in C, quindi il nostro codice leggibile ma non perfettamente ottimizzato verrà comunque eseguito un ordine di grandezza più velocemente che se avessimo scritto codice comparabile in un numero qualsiasi di linguaggi alternativi.",
    "crumbs": [
      "Risorse",
      "FAQ"
    ]
  },
  {
    "objectID": "faq.html#come-si-svolge-lesame",
    "href": "faq.html#come-si-svolge-lesame",
    "title": "FAQ",
    "section": "Come si svolge l’esame?",
    "text": "Come si svolge l’esame?\nL’esame del corso di Dati e Algoritmi è scritto, in presenza e si svolge in 3 parti:\n\ndomande: verifica della conoscenza teorica in programma, semplici dimostrazioni;\nesercizi: capacità di risolvere problemi di progetto e analisi di algoritmi (simili a quelli affrontati durante il corso);\ncodice: scrittura in linguaggio C di algoritmi che utilizzano strutture dati;\n\nogni parte dell’esame dura 45 minuti, per un totale di 2 ore e 15 minuti.",
    "crumbs": [
      "Risorse",
      "FAQ"
    ]
  },
  {
    "objectID": "faq.html#come-si-calcola-il-voto-finale",
    "href": "faq.html#come-si-calcola-il-voto-finale",
    "title": "FAQ",
    "section": "Come si calcola il voto finale?",
    "text": "Come si calcola il voto finale?\nOgnuna delle tre parti dell’esame è valutata al massimo 11 punti, il voto è la somma delle tre parti.\n\n\n\n\n\n\nImportante\n\n\n\nSe in una delle tre parti si ottiene una valutazione inferiore a 4, l’esame è da considerarsi non superato nella sua interezza.\n\n\nCon 33 punti si ottiene la lode.\nDi seguito è riportato l’algoritmo di calcolo del voto finale:\n// algoritmo per calcolare il voto dell'esame\nint voto_finale(int domande, int esercizi, int codice)\n{\n    int voto = domande + esercizi + codice;\n\n    // se una delle tre parti è inferiore a 4,\n    // l'esame è da considerarsi non superato\n    if (domande &lt; 4 || esercizi &lt; 4 || codice &lt; 4)\n    {\n        voto = 0;\n    }\n\n    switch (voto)\n    {\n        case 31:\n        case 32:\n            voto = 30;\n            break;\n\n        case 33:\n            voto = 31; // 31 equivale a 30 e lode\n            break;\n\n        case default:\n            break;\n    }\n\n  return voto;\n}",
    "crumbs": [
      "Risorse",
      "FAQ"
    ]
  },
  {
    "objectID": "faq.html#posso-usare-il-mio-computer-per-scrivere-codice",
    "href": "faq.html#posso-usare-il-mio-computer-per-scrivere-codice",
    "title": "FAQ",
    "section": "Posso usare il mio computer per scrivere codice?",
    "text": "Posso usare il mio computer per scrivere codice?\nNo, la parte di scrittura di codice si svolge tramite i computer del laboratorio.",
    "crumbs": [
      "Risorse",
      "FAQ"
    ]
  },
  {
    "objectID": "faq.html#non-ho-un-computer-posso-svolgere-lesame",
    "href": "faq.html#non-ho-un-computer-posso-svolgere-lesame",
    "title": "FAQ",
    "section": "Non ho un computer, posso svolgere l’esame?",
    "text": "Non ho un computer, posso svolgere l’esame?\nSì, tuttavia per poter svolgere gli esercizi di programmazione è necessario avere una buona dimestichezza con l’uso di un computer ed è fortemente consigliato fare pratica a casa.",
    "crumbs": [
      "Risorse",
      "FAQ"
    ]
  },
  {
    "objectID": "exercises.html",
    "href": "exercises.html",
    "title": "Esercizi",
    "section": "",
    "text": "Gli esercizi sono divisi per lezione. Ogni lezione tratta un numero variabile di argomenti, quindi gli esercizi sono divisi in base a questi argomenti. Gli esercizi di lezioni più avanzate fanno spesso riferimento a concetti appresi in lezioni precedenti, quindi è consigliabile svolgerli in ordine.\nPer compilare gli esercizi si suggerisce di usare il comando gcc con i warning attivati e l’opzione -std=c99 per compilare in standard C99. Di seguito il comando che si può usare per compilare un file sorgente esercizio.c:\ngcc -std=c99 -Wall -Wextra -pedantic -Werror -g -o esercizio esercizio.c\nTalvolta può essere utile usare un file Makefile per compilare più file sorgente. Di seguito un esempio di Makefile:\n\n\n Scarica il file \nFILES=esercizio.c\nEXECUTABLE=esercizio\n\nCC=gcc\nCFLAGS=-std=c99 -Wall -Wextra -pedantic -Werror -g\n\n$(EXECUTABLE): $(FILES)\n    $(CC) $(CFLAGS) -o $@ $^"
  },
  {
    "objectID": "extra/books.html",
    "href": "extra/books.html",
    "title": "Libri di testo",
    "section": "",
    "text": "Il libro del corso è Programmazione in C di Kim N. King, in particolare nell’edizione italiana edita da Apogeo.\n\nLetture consigliate\n\n\n\n\n\n\nNota\n\n\n\nQuesta è una lista di letture suggerite per approfondire concetti visti durante il corso, i contenuti di questi libri però non sono richiesti in sede d’esame.\n\n\n\n21st Century C di Ben Klemens\nExpert C Programming: Deep C secrets di Peter Van Der Linden\nHead First C di David e Dawn Griffiths\nAn introduction to C&GUI programming di Simon Long\nModern C di Jens Gustedt",
    "crumbs": [
      "Risorse",
      "Libri di testo"
    ]
  },
  {
    "objectID": "extra/gcc.html",
    "href": "extra/gcc.html",
    "title": "Il compilatore C",
    "section": "",
    "text": "Nota\n\n\n\nQuesta guida è una traduzione parziale di Unix Programming Tools, una guida scritta per il corso CS107 presso la Stanford University.\nSolitamente i sistemi operativi mettono a disposizione il comando cc (che starebbe per C compiler) per compilare i programmi in C, questo comando è in realtà un alias che si riferisce al compilatore C installato sul sistema, solitamente gcc (GNU C Compiler) o clang (C Language Compiler).\nIn questa sezione viene presentato il compilatore gcc, un prodotto del progetto GNU open source. L’uso di gcc presenta diversi vantaggi: tende ad essere abbastanza aggiornato e affidabile, è disponibile su una varietà di piattaforme e, ovviamente, è gratuito e open source. Gcc può compilare C, C++ e Objective-C. Gcc in realtà è sia un compilatore che un linker. Ciò vuol dire che una singola chiamata a gcc eseguirà l’intera operazione di linking e di compilazione. Ad esempio, per piccoli progetti potresti utilizzare un comando come il seguente che compila e collega insieme tre file .c per creare un eseguibile chiamato “program”:\nLa riga precedente potrebbe essere riscritta in modo equivalente per separare i tre passaggi di compilazione dei file .c seguiti da un passaggio di collegamento per creare il programma:\nLa forma generale per invocare il comando gcc è:\ndove options è una lista di flag che dicono a gcc come effettuare la compilazione e files è una lista di file che verranno processati da gcc.",
    "crumbs": [
      "Risorse",
      "Strumenti di sviluppo",
      "Il compilatore GCC"
    ]
  },
  {
    "objectID": "extra/gcc.html#opzioni-del-compilatore",
    "href": "extra/gcc.html#opzioni-del-compilatore",
    "title": "Il compilatore C",
    "section": "Opzioni del compilatore",
    "text": "Opzioni del compilatore\nCome la maggior parte dei programmi Unix, gcc supporta molte opzioni della riga di comando per controllarne il funzionamento. Sono tutti documentati nella sua pagina man. Possiamo tranquillamente ignorare la maggior parte di queste opzioni e concentrarci su quelle più comunemente usate: -c, -o, -g e -Wall.\n\n\n\nOpzione\nDescrizione\n\n\n\n\n-c files\ncompila i file sorgente in file oggetto senza passare attraverso la fase di collegamento. I Makefile (sotto) usano questa opzione per compilare i file uno alla volta.\n\n\n-o file\nSpecifica che l’output di gcc dovrebbe essere denominato file. Se questa opzione non è specificata, il nome predefinito utilizzato dipende dal contesto: (a) se si compila un file sorgente .c, il file oggetto di output verrà nominato con lo stesso nome ma con estensione .o. In alternativa, (b) se si effettua il collegamento per creare un eseguibile, il file di output verrà denominato a.out. Molto spesso, l’opzione -o viene utilizzata per specificare il nome del file di output quando si collega un eseguibile, mentre per la compilazione, le persone lasciano semplicemente che prenda il sopravvento la denominazione predefinita .c/.o.\n\n\n-g\nIndica al compilatore di includere informazioni di debug aggiuntive nel proprio output. Ti consiglio di compilare sempre il tuo codice sorgente con questa opzione, in modo da poter usare il debugger.\n\n\n-Wall\nFornisce avvisi su possibili errori nel codice sorgente. I problemi rilevati da -Wall non sono esattamente errori, sono costrutti che il compilatore ritiene possano essere errori. Ti consiglio vivamente di compilare il codice con -Wall. Trovare bug in fase di compilazione è davvero molto più semplice che in fase di esecuzione. L’opzione -Wall può sembrare fastidiosa, ma ne vale la pena.",
    "crumbs": [
      "Risorse",
      "Strumenti di sviluppo",
      "Il compilatore GCC"
    ]
  },
  {
    "objectID": "extra/formatting.html",
    "href": "extra/formatting.html",
    "title": "Guida per formattare il codice",
    "section": "",
    "text": "Clang-Format è uno strumento di formattazione del codice sorgente basato su Clang, il front-end del compilatore LLVM. La sua principale funzione è quella di formattare il codice sorgente in base a regole di stile specifiche, garantendo coerenza e leggibilità del codice. Questo strumento è particolarmente utile in contesti di sviluppo collaborativo, dove diversi programmatori possono avere differenti preferenze di formattazione. Utilizzare clang-format permette di mantenere uno stile uniforme nel codice sorgente, facilitando la comprensione, la manutenzione e la revisione del codice.\nNel caso di questo corso invece permette di assicurarsi che il codice sorgente segua lo stile esplicitato nella guida di stile e garantisce che sia leggibile prima di condividere il codice con qualcun altro.\nIn generale si consiglia di utilizzare clang-format specificando lo stile microsoft nella seguente maniera:",
    "crumbs": [
      "Risorse",
      "Come scrivere codice",
      "Formatting"
    ]
  },
  {
    "objectID": "extra/formatting.html#installazione-e-uso-su-linux",
    "href": "extra/formatting.html#installazione-e-uso-su-linux",
    "title": "Guida per formattare il codice",
    "section": "Installazione e uso su Linux",
    "text": "Installazione e uso su Linux\nSu Linux, l’installazione di clang-format può essere effettuata tramite il gestore dei pacchetti della distribuzione utilizzata. Ad esempio, su Ubuntu e derivate, si può installare con il seguente comando:\nsudo apt-get install clang-format\nUna volta installato, è possibile utilizzare clang-format direttamente da riga di comando specificando il file sorgente da formattare. Ad esempio:\nclang-format -i file.c\nQuesto comando formatta il file “file.c” utilizzando le impostazioni predefinite di clang-format.",
    "crumbs": [
      "Risorse",
      "Come scrivere codice",
      "Formatting"
    ]
  },
  {
    "objectID": "extra/formatting.html#installazione-e-uso-su-macos",
    "href": "extra/formatting.html#installazione-e-uso-su-macos",
    "title": "Guida per formattare il codice",
    "section": "Installazione e uso su macOS",
    "text": "Installazione e uso su macOS\nSu macOS, clang-format può essere installato utilizzando Homebrew, un gestore di pacchetti per macOS. Per installare clang-format con Homebrew, eseguire i seguenti comandi:\nbrew update\nbrew install clang-format\nDopo l’installazione, è possibile utilizzare clang-format come descritto in precedenza per Linux.",
    "crumbs": [
      "Risorse",
      "Come scrivere codice",
      "Formatting"
    ]
  },
  {
    "objectID": "extra/formatting.html#installazione-e-uso-su-windows",
    "href": "extra/formatting.html#installazione-e-uso-su-windows",
    "title": "Guida per formattare il codice",
    "section": "Installazione e uso su Windows",
    "text": "Installazione e uso su Windows\nSu Windows, clang-format può essere installato come parte del pacchetto LLVM. Per installare LLVM e quindi clang-format, seguire questi passaggi:\n\nScaricare il pacchetto di installazione di LLVM dal sito ufficiale (https://llvm.org/).\nEseguire il programma di installazione e seguire le istruzioni guidate.\nAssicurarsi di selezionare l’opzione per installare clang-format durante il processo di installazione.\n\nDopo l’installazione, è possibile utilizzare clang-format da riga di comando come descritto in precedenza per Linux e macOS.",
    "crumbs": [
      "Risorse",
      "Come scrivere codice",
      "Formatting"
    ]
  },
  {
    "objectID": "extra/formatting.html#utilizzo-avanzato",
    "href": "extra/formatting.html#utilizzo-avanzato",
    "title": "Guida per formattare il codice",
    "section": "Utilizzo avanzato",
    "text": "Utilizzo avanzato\nClang-Format offre numerose opzioni per personalizzare la formattazione del codice sorgente. È possibile specificare un file di configurazione .clang-format per definire regole di formattazione personalizzate. Inoltre, clang-format supporta diversi stili di formattazione predefiniti, come Google, LLVM, Mozilla e altri.\nPer ulteriori informazioni sulle opzioni di configurazione e sugli stili di formattazione supportati, consultare la documentazione ufficiale di Clang-Format.",
    "crumbs": [
      "Risorse",
      "Come scrivere codice",
      "Formatting"
    ]
  },
  {
    "objectID": "extra/makefile.html",
    "href": "extra/makefile.html",
    "title": "Automatizzare la compilazione con make",
    "section": "",
    "text": "Nota\n\n\n\nQuesta guida è una traduzione parziale di Unix Programming Tools, una guida scritta per il corso CS107 presso la Stanford University.\nDigitare i comandi gcc per un progetto diventa meno attraente man mano che il progetto diventa più grande. L’utility make automatizza il processo di compilazione e collegamento. Con make, il programmatore specifica quali sono i file nel progetto e come si incastrano tra loro, quindi make si occupa dei passaggi appropriati di compilazione e collegamento. Make può velocizzare la compilazione in quanto è abbastanza intelligente da sapere che se hai 10 file .c ma ne hai modificato solo uno, solo quel file deve essere compilato prima del passaggio di linking. Make ha alcune funzionalità complesse, ma usarlo per cose semplici è piuttosto facile.",
    "crumbs": [
      "Risorse",
      "Strumenti di sviluppo",
      "Makefile"
    ]
  },
  {
    "objectID": "extra/makefile.html#eseguire-make",
    "href": "extra/makefile.html#eseguire-make",
    "title": "Automatizzare la compilazione con make",
    "section": "Eseguire make",
    "text": "Eseguire make\nNella directory del tuo progetto esegui make direttamente dalla shell senza argomenti. Di default, make cerca nella directory corrente un file chiamato Makefile o makefile per eseguire le sue istruzioni di compilazione. Se si verifica un problema durante la creazione di uno dei target, i messaggi di errore vengono scritti nello standard error.",
    "crumbs": [
      "Risorse",
      "Strumenti di sviluppo",
      "Makefile"
    ]
  },
  {
    "objectID": "extra/makefile.html#makefiles",
    "href": "extra/makefile.html#makefiles",
    "title": "Automatizzare la compilazione con make",
    "section": "Makefiles",
    "text": "Makefiles\nUn makefile è costituito da una serie di definizioni di variabili e regole di dipendenza. Una variabile in un makefile è un nome definito per rappresentare una stringa di testo. Funziona in modo molto simile alla sostituzione delle macro nel preprocessore C. Le variabili vengono spesso utilizzate per rappresentare un elenco di directory in cui cercare, opzioni per il compilatore e nomi di programmi da eseguire. Le variabili non sono pre-dichiarate, le imposti semplicemente con ‘=’. Ad esempio, la linea:\nCC = gcc\ncreerà una variabile chiamata CC impostando il suo contenuto a gcc. I nomi delle variabili sono case sensitive, e, solitamente, vengono scritti in maiuscolo.\nSeppure si sia liberi di nominare le variabili a proprio piacimento ci sono alcuni nomi standard, pertanto è fortemente suggerito usarli. I più importanti sono:\n\n\n\nNome Variabile\nSignificato\n\n\n\n\nCC\nIl compilatore C da usare\n\n\nCFLAGS\nLe opzioni da passare al compilatore C\n\n\nLDFLAGS\nLe opzioni da passare al linker\n\n\n\nPer utilizzare una variabile basta scrivere il simbolo $ seguito dal nome della variabile tra parentesi, per esempio:\nCFLAGS = -g -Wall -pedantic -std=c99\n$(CC) $(CFLAGS) -o hello hello.c\nLa prima riga di questo esempio imposta il contenuto di CFLAGS a -g -Wall -pedantic -std=c99. La seconda riga compila hello.c con le opzioni definite in CFLAGS.\nIl secondo componente principale di un makefile sono le regole di dipendenza/costruzione. Una regola spiega come creare un target in base alle modifiche apportate a un elenco di determinati file. L’ordine delle regole non fa alcuna differenza, eccetto che la prima regola è considerata quella predefinita – la regola che verrà invocata quando make viene chiamato senza argomenti.\nUna regola generalmente è composta da due righe: una riga di dipendenza seguita da una riga di comando. Ecco una regola di esempio:\nhello.o: hello.c hello.#\n    $(CC) $(CFLAGS) -c hello.c",
    "crumbs": [
      "Risorse",
      "Strumenti di sviluppo",
      "Makefile"
    ]
  },
  {
    "objectID": "exercises/01/libretto.html",
    "href": "exercises/01/libretto.html",
    "title": "Esercizio: il libretto degli esami",
    "section": "",
    "text": "Si vuole scrivere un programma che, dati in input i voti di più esami e i relativi crediti, calcoli la media ponderata dei voti e la visualizzi a video.\n\n\n\n\n\n\nSi assume che gli esami siano 3: algebra lineare, analisi matematica e introduzione alla programmazione (java).\n\n\n\nQuando il programma viene eseguito deve chiedere all’utente di inserire il voto di un certo esame e il relativo numero di crediti associato. Una volta inseriti tutti i voti e i crediti, il programma deve calcolare la media ponderata e visualizzarla a video.\nOpzionale:\n\nProvare a visualizzare anche la media aritmetica dei voti;\nVisualizzare anche l’elenco dei voti e dei crediti inseriti.\nProva a stampare il voto con 2 cifre decimali, ad esempio 27.11 (per fare questo bisogna cambiare il tipo di dato usato per memorizzare la media e usare il type casting durante la divisione).\n\n\n\n\n\n\n\nSuggerimento\n\n\n\nLa media ponderata si calcola come la somma dei prodotti tra ciascun voto e i relativi crediti, diviso la somma dei crediti. Formalmente:\n\\[\n\\text{media} = \\frac{\\sum_{i=1}^{n} voto_i \\cdot crediti_i}{\\sum_{i=1}^{n} crediti_i}\n\\] dove \\(voto_i\\) è il voto dell’esame \\(i\\)-esimo e \\(crediti_i\\) è il numero di crediti dell’esame \\(i\\)-esimo.\nAd esempio, se si hanno tre esami con voti 30, 28 e 25 e i rispettivi crediti sono 6, 9 e 12, la media ponderata è: \\[\n\\frac{30 \\cdot 6 + 28 \\cdot 9 + 25 \\cdot 12}{6 + 9 + 12} = \\frac{180 + 252 + 300}{27} = \\frac{732}{27} \\approx 27.11\n\\]\n\n\nEsempio di main:\n\n\n Scarica il file \n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    int voto_analisi1, voto_algebra_lineare, voto_java;\n    int crediti_analisi1, crediti_algebra_lineare, crediti_java;\n    int media_ponderata;\n\n    // TODO: Chiedere all'utente i voti e i crediti dei tre esami\n\n    // TODO: Calcolare la media ponderata\n\n    printf(\"La media ponderata è: %d\\n\", media_ponderata);\n}\n\n\n\n\n\n\nSoluzione\n\n\n\n\n\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    int voto_analisi1, voto_algebra_lineare, voto_java;\n    int crediti_analisi1, crediti_algebra_lineare, crediti_java;\n    int media_ponderata;\n\n    printf(\"Inserisci il volto di analisi 1 e i crediti: \");\n    scanf(\"%d %d\", &voto_analisi1, &crediti_analisi1);\n\n    printf(\"Inserisci il volto di algebra lineare e i crediti: \");\n    scanf(\"%d %d\", &voto_algebra_lineare, &crediti_algebra_lineare);\n\n    printf(\"Inserisci il volto di introduzione alla programmazione e i crediti: \");\n    scanf(\"%d %d\", &voto_java, &crediti_java);\n\n    int numeratore, denominatore;\n    numeratore =\n        voto_analisi1 * crediti_analisi1 + voto_algebra_lineare * crediti_algebra_lineare + voto_java * crediti_java;\n    denominatore = crediti_analisi1 + crediti_algebra_lineare + crediti_java;\n    media_ponderata = numeratore / denominatore;\n\n    printf(\"La media ponderata è: %d\\n\", media_ponderata);\n}",
    "crumbs": [
      "Lezioni",
      "Basi di C",
      "Libretto universitario"
    ]
  },
  {
    "objectID": "exercises/01/somma_interi.html",
    "href": "exercises/01/somma_interi.html",
    "title": "Esercizio: somma di interi",
    "section": "",
    "text": "Si vuole scrivere un programma che accetti in input due numeri interi e ne calcoli la somma. Il programma deve chiedere all’utente di inserire i due numeri, effettuare il calcolo e visualizzare il risultato a video.\nAd esempio:\nInserisci il primo numero: 5\nInserisci il secondo numero: 7\nLa somma dei due numeri è 12\nUna volta compilato il programma eseguilo con gdb e controlla il valore delle variabili prima e dopo l’assegnamento. Cosa noti?\n\n\n\n\n\n\nGNU Debugger\n\n\n\nPer eseguire un programma con gdb è sufficiente digitare il comando gdb nome_programma da terminale. Una volta avviato il debugger è possibile aggiungere breakpoints con il comando break nome_funzione o break numero_riga. A questo punto è possibile eseguire il programma con il comando run e controllare il valore delle variabili con il comando print nome_variabile. Per andare avanti di un passo è possibile usare il comando next o step. Per uscire dal debugger è sufficiente digitare quit.\n\n\n\n\n\n\n\n\nSoluzione\n\n\n\n\n\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    int a, b;\n\n    printf(\"Inserisci due numeri: \");\n    scanf(\"%d %d\", &a, &b);\n\n    printf(\"La somma di %d e %d è %d\\n\", a, b, a + b);\n}",
    "crumbs": [
      "Lezioni",
      "Basi di C",
      "Somma di interi"
    ]
  },
  {
    "objectID": "exercises/extra/palindromi.html",
    "href": "exercises/extra/palindromi.html",
    "title": "Palindromi",
    "section": "",
    "text": "Implementiamo un algoritmo per determinare se la parola contenuta in una lista concatenata è palindroma (parole che restano uguali se lette al contrario. Ad esempio \"anna\", \"bob\" sono palindromi, \"ciao\" e \"bod\" non lo sono). Esistono vari modi per farlo, noi implementiamo un semplice algoritmo che crea una copia in ordine invertito della lista da controllare e verifica se la lista di origine e quella invertita son identiche.\nSi chiede di implementare le seguenti funzioni:\n\nvoid add(Nodo**lis, char c);\nint compareLists(Nodo*lis, Nodo* comp);\nvoid copyReversed(Nodo* lis, Nodo** copy);\nint checkPalindrome(Nodo*lis);\n\nDelle ultime due viene fornito lo pseudocodice:\n\n\n\\begin{algorithm} \\caption{copyReversed} \\begin{algorithmic} \\State \\textbf{Input:} lis (una lista), copy (una lista vuota) \\State \\textbf{Output:} Nessuno. \\textbf{Side effect}: copy contiene una lista di lunghezza uguale a lis, in cui i nodi contengono gli stessi caratteri di quelli di lis ma in ordine inverso. \\If{$list = \\text{nil}$} \\Return \\EndIf \\State $copyReversed$(lista a partire dal nodo successivo di lis, $copy$) \\State $add$($copy$, carattere contenuto nel primo nodo di lis) \\end{algorithmic} \\end{algorithm}\n\n\n\n\n\\begin{algorithm} \\caption{checkPalindrome} \\begin{algorithmic} \\State \\textbf{Input:} lis (una lista) \\State \\textbf{Output:} TRUE se la lista passata contiene una sequenza di caratteri palindroma, FALSE altrimenti \\State $inv \\leftarrow$ nuova lista vuota \\State $copyReversed(lis, inv)$ \\Return $compareLists(lis, inv)$ \\end{algorithmic} \\end{algorithm}\n\n\nadd serve ad ad aggiungere un nodo in coda alla lista lis contenente il carattere c come valore.\ncompareLists deve restituire True se lis e comp sono due liste identiche (hanno lo stesso numero di nodi e il contenuto dei nodi è identico). Esistono più modi di eseguire questo controllo ma si consiglia di usare la ricorsione.\nSe necessario, si possono aggiungere funzioni di supporto, ma è necessario che le funzioni richieste siano implementate esattamente con i prototipi forniti.\n\nLo pseudocodice non è codice completo in C: non considera i tipi dei vari oggetti, l’uso di puntatori/riferimenti, e dunque dell’operatore “-&gt;” anziché l’operatore “.”: `e lasciato allo studente il compito di determinare questi dettagli come adeguato.\n\n Scarica i file per svolgere l'esercizio \n\n\n\n\n\n\nSoluzione (fare click per visualizzare)\n\n\n\n\n\nLa soluzione proposta è la seguente:\nvoid add(Nodo **lista, char c)\n{\n    if (lista == NULL)\n    {\n        printf(\"Passare per riferimento ad ADD\\n\");\n    }\n    if (*lista == NULL)\n    {\n        *lista = malloc(sizeof(Nodo));\n        assert(*lista != NULL);\n        (*lista)-&gt;value = c;\n        (*lista)-&gt;next = NULL;\n    }\n    else\n    {\n        add(&(*lista)-&gt;next, c);\n    }\n}\n\nvoid copyReversed(Nodo *src, Nodo **copy)\n{\n    if (copy == NULL)\n    {\n        printf(\"Passare la lista di destinazione di copia per puntatore\");\n    }\n    if (src == NULL)\n    {\n        return;\n    }\n    copyReversed(src-&gt;next, copy);\n    add(copy, src-&gt;value);\n}\n\nint compareLists(Nodo *list_a, Nodo *list_b)\n{\n    if (list_a == NULL)\n    {\n        if (list_b == NULL)\n        {\n            return 1;\n        }\n        else\n        {\n            return 0;\n        }\n    }\n    if (list_a-&gt;value != list_b-&gt;value)\n    {\n        return 0;\n    }\n    else\n    {\n        return compareLists(list_a-&gt;next, list_b-&gt;next);\n    }\n}\n\nint checkPalindrome(Nodo *lista)\n{\n    if (lista == NULL)\n    {\n        return 0;\n    }\n    Nodo *inv = NULL;\n    copyReversed(lista, &inv);\n    int result = compareLists(lista, inv);\n    deleteList(inv);\n    return result;\n}",
    "crumbs": [
      "Lezioni",
      "Preparazione esame",
      "Palindromi"
    ]
  },
  {
    "objectID": "exercises/extra/secrets.html",
    "href": "exercises/extra/secrets.html",
    "title": "XOR cipher",
    "section": "",
    "text": "I membri di un’organizzazione segreta hanno inventato un nuovo algoritmo crittografico basato sull’operatore bitwise XOR per scambiarsi messaggi cifrati. Un detective ha intercettato diversi messaggi ed è riuscito ad ottenere lo pseudocodice dell’algoritmo.\nI messaggi sono codificati in liste concatenate di caratteri, ad ognuno dei quali è stato applicato l’algoritmo di codifica con una chiave segreta. La chiave è una stringa alfanumerica di lunghezza variabile.\nLo pseudocodice dell’algoritmo è il seguente:\n\n\n\\begin{algorithm} \\caption{listEncodec($list, key, seed$)} \\begin{algorithmic} \\State \\textbf{Input:} una lista di caratteri $list$, la stringa $key$ usata per decifrare il messaggio, un intero $seed$: $seed \\in \\mathbb{N}$. \\State \\textbf{Output:} Nessuno. \\textbf{Side effect}: $list$ contiene i caratteri decifrati. \\If{$list = \\text{nil}$} \\Return \\EndIf \\State $list.value \\leftarrow$ charEncodec($list.value$, $key[seed \\mod \\text{len}(key)]$) \\State listEncodec($list.next$, key, seed + 1) \\end{algorithmic} \\end{algorithm}\n\n\n\n\n\\begin{algorithm} \\caption{charEncodec(c, key)} \\begin{algorithmic} \\State \\textbf{Input:} $c$ carattere contenente l'informazione da decifrare, il carattere $key$ usato per decifrare l'informazione. \\State \\textbf{Output:} un carattere decifrato. \\State $result \\leftarrow c \\oplus key$ \\If{\\Not isPrintable($result$)} \\State $result \\leftarrow c$ \\EndIf \\Return $result$ \\end{algorithmic} \\end{algorithm}\n\n\nIl simbolo \\(\\oplus\\) è l’operatore bitwise xor (^), mentre mod corrisponde all’operatore modulo (%).\nAiuta il detective implementando lo pseudocodice nelle seguenti funzioni C:\n\nchar charEncodec(const char c, const char key)\nvoid listEncodec(Node *list, const char *key, const int seed)\n\nSe necessario, si possono aggiungere funzioni di supporto, ma è necessario che le funzioni richieste siano implementate esattamente con i prototipi forniti.\n\nLo pseudocodice non è codice completo in C: non considera i tipi dei vari oggetti, l’uso di puntatori/riferimenti, e dunque dell’operatore “-&gt;” anziché l’operatore “.”: `e lasciato allo studente il compito di determinare questi dettagli come adeguato.\n\n\n\n\n\n\n\nNota\n\n\n\nL’implementazione della lista in C è quella utilizzata durante le lezioni del corso e viene fornita già implementata nei file dell’esercizio come segue:\ntypedef struct node {\n    char value;\n    struct node *next;\n} Node;\nLa funzione isPrintable viene fornita con il testo dell’esercizio, accetta in input un singolo carattere e restituisce un intero:\n\n0 se non può essere stampato a terminale (ad esempio se si tratta dei caratteri \\0, \\n, \\t, …)\n1 altrimenti\n\nLa funzione len prende in input un stringa e restituisce la lunghezza della stringa. Viene fornita già implementata nel testo dell’esercizio.\n\n\n Scarica i file per svolgere l'esercizio \n\n\n\n\n\n\nSoluzione (fare click per visualizzare)\n\n\n\n\n\nLa soluzione proposta è la seguente:\nchar charEncodec(const char c, const char key)\n{\n    char result = c ^ key;\n    if (!isPrintable(result))\n        result = c;\n    return result;\n}\n\nvoid listEncodec(Node *list, const char *key, const int seed)\n{\n    if (list == NULL)\n        return;\n    // È necessario l'operatore -&gt; poiché list è un puntatore\n    // in tal modo si accede al campo value della struttura\n    // puntata da list\n    list-&gt;value = charEncodec(list-&gt;value, key[seed % len(key)]);\n    // Chiamata ricorsiva\n    listEncodec(list-&gt;next, key, seed + 1);\n}",
    "crumbs": [
      "Lezioni",
      "Preparazione esame",
      "XOR cipher"
    ]
  },
  {
    "objectID": "exercises/02/sum_matrix.html",
    "href": "exercises/02/sum_matrix.html",
    "title": "Esercizio: somma righe e colonne",
    "section": "",
    "text": "Si vuole scrivere un programma che legga un vettore di \\(5\\times 5\\) interi e calcoli la somma di ciascuna riga e di ciascuna colonna.\n\nUn’esecuzione del programma potrebbe essere la seguente:\n$ ./row_col_sum\nRiga 1: 8 3 9 0 10\nRiga 2: 3 5 17 1 1\nRiga 3: 2 8 6 23 1\nRiga 4: 15 7 3 2 9\nRiga 5: 6 14 2 6 0\nSomma righe: 30 27 40 36 28\nSomma colonne: 34 37 37 32 21\n\n\n\n\n\n\nSuggerimento\n\n\n\nLa maniera più semplice di iterare su tutte le righe e colonne di una matrice è utilizzare due cicli annidati.\nLa funzione scanf può essere usata all’interno di un ciclo, consumendo un valore alla volta. Ad esempio:\nint main(void)\n{\n    int arr[5];\n    printf(\"Inserisci 5 interi: \")\n    for (int i = 0; i &lt; 5; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    for (int i = 0; i &lt; 5; i++) {\n        printf(\"%d \", arr[i]);\n    }\n}\nL’esecuzione di questo programma leggerà 5 interi e li memorizzerà nell’array arr. Di seguito un esempio di esecuzione:\n$ ./a.out\nInserisci 5 interi: 1 2 3 4 5\n1 2 3 4 5",
    "crumbs": [
      "Lezioni",
      "Array e funzioni",
      "Somma di righe e colonne"
    ]
  },
  {
    "objectID": "exercises/02/word_average.html",
    "href": "exercises/02/word_average.html",
    "title": "Esercizio: lunghezza media delle parole",
    "section": "",
    "text": "Si vuole scrivere un programma che calcoli la lunghezza media delle parole di un messaggio scritto in input.\n\nIl programma deve leggere una sequenza di caratteri da tastiera e calcolare la lunghezza media delle parole presenti nel messaggio. Si considera una parola una sequenza di caratteri separata da spazi, tabulazioni o a capo.\nUn’esecuzione del programma potrebbe essere la seguente:\n$ ./lunghezza_media\nScrivi una frase: Era solo un abbaglio.\nLunghezza media: 4.5\n\n\n\n\n\n\nSuggerimento\n\n\n\nLa funzione getchar legge un carattere alla volta da standard input. Ad esempio:\nchar c = getchar(); // legge un carattere da stdin\n// oppure\nwhile ((c = getchar()) != '\\n') {\n    // legge caratteri fino a quando\n    // non viene premuto il tasto enter\n}",
    "crumbs": [
      "Lezioni",
      "Array e funzioni",
      "Lunghezza media delle parole"
    ]
  },
  {
    "objectID": "exercises/02/deal.html",
    "href": "exercises/02/deal.html",
    "title": "Esercizio: una mano di poker",
    "section": "",
    "text": "Si vuole scrivere un programma pescare una mano di poker.\n\nScrivere un programma che simuli il pescaggio di una mano di poker. Il programma deve pescare cinque carte casuali da un mazzo di 52 carte e stamparle a video.\nUn’esecuzione del programma potrebbe essere la seguente:\n$ ./poker\nLe carte pescate sono:\n7c 3d 9h 10s 2d\nOpzionale:\n\nscrivere una funzione draw_card che restituisca una carta casuale.\nimplementare una funzione discard che permetta di scartare un numero arbitrario di carte e di pescarne altrettante di nuove.\n\n\n\n\n\n\n\nSuggerimento\n\n\n\nPer pescare una carta casuale si devono generare dei numeri casuali. In C si utilizza la funzione rand per generare numeri casuali. Prima di utilizzare rand è necessario inizializzare il generatore di numeri casuali con la funzione srand. Per fare questo si può utilizzare il valore restituito dalla funzione time della libreria time.h come seme per srand. Ad esempio:\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n\nint main() {\n    srand(time(NULL)); // imposta il seed\n    int n = rand(); // genera un numero casuale\n    // se si vuole generare un numero tra 0 e 51 si può usare l'operatore modulo\n    int card = rand() % 52;\n    // ...\n}\nPer avere maggiori dettagli su rand e srand si può consultare la documentazione disponibile digitando man rand e man srand da terminale.",
    "crumbs": [
      "Lezioni",
      "Array e funzioni",
      "Una mano a poker"
    ]
  }
]